%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Runge-Kutta Methods and Linear Algebra}
\date{Sep 05, 2022}
\release{}
\author{Dr Jon Shiach}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
These are the lecture notes that accompany the teaching of Runge\sphinxhyphen{}Kutta methods and computational linear algebra on the third year of the Mathematics course at the Manchester Metropolitan university. They can be accessed through a standard web browser on a computer or mobile device. Whilst these notes cover all of the material necessary for students to successfully pass the unit, it is advisable to seek out other sources of information either on the internet or textbooks. Mathematical notation can differ between authors and these notes have been written to use notation that is most commonly found online.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Runge\sphinxhyphen{}Kutta methods}
\end{DUlineblock}

\sphinxAtStartPar
The content for this half of the unit is split into two main topic areas. The first deals with Runge\sphinxhyphen{}Kutta methods which are the most common methods used to solve ordinary differential equations.

\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{text-center}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-row-cols-1}
\begin{sphinxuseclass}{sd-row-cols-xs-1}
\begin{sphinxuseclass}{sd-row-cols-sm-1}
\begin{sphinxuseclass}{sd-row-cols-md-2}
\begin{sphinxuseclass}{sd-row-cols-lg-3}
\begin{sphinxuseclass}{sd-g-3}
\begin{sphinxuseclass}{sd-g-xs-3}
\begin{sphinxuseclass}{sd-g-sm-3}
\begin{sphinxuseclass}{sd-g-md-3}
\begin{sphinxuseclass}{sd-g-lg-3}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Initial Value Problems

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{IVP}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{1_IVPs/1.0_IVPs::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Explicit Runge\sphinxhyphen{}Kutta Methods

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{ERK}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{2_ERKs/2.0_ERKs::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Implicit Runge\sphinxhyphen{}Kutta Methods

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{IRK}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{3_IRKs/3.0_IRKs::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Stability

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{ERK_stability}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{4_Stability/4.0_Stability::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Boundary Value Problems

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{BVP}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{5_BVPs/5.0_BVPs::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Linear Algebra}
\end{DUlineblock}

\sphinxAtStartPar
The other topic area that is covered in this half of the unit is the solution of linear systems of equations. There are two approaches to this, direct methods are algebraic methods that require a single application to solve a linear system. An example of a direct method is Gaussian elimination. The other approach is indirect methods which uses multiple iterations to improve on a guess of the solution until it is achieved a level of accuracy.

\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{text-center}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-g-3}
\begin{sphinxuseclass}{sd-g-xs-3}
\begin{sphinxuseclass}{sd-g-sm-3}
\begin{sphinxuseclass}{sd-g-md-3}
\begin{sphinxuseclass}{sd-g-lg-3}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Direct Methods

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{LU}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{6_Direct_methods/6.0_Direct_methods::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-col-4}
\begin{sphinxuseclass}{sd-col-xs-4}
\begin{sphinxuseclass}{sd-col-sm-4}
\begin{sphinxuseclass}{sd-col-md-4}
\begin{sphinxuseclass}{sd-col-lg-4}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-hover}
\begin{sphinxuseclass}{sd-card-header}
\begin{sphinxuseclass}{bg-light}
\sphinxAtStartPar
Indirect Methods

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{sor_2}.png}
\end{figure}

\end{sphinxuseclass}{\hyperref[\detokenize{7_Indirect_methods/7.0_Indirect_methods::doc}]{\sphinxcrossref{\DUrole{doc}{}}}}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Students are advised to read through the relevant section of the lecture notes prior to attending the lecture. Do not worry about trying to understand everything when you first read through them. Reading mathematics is not like reading a novel, it often requires repeated reading of a passage before you fully grasp the concepts that are being explained. In the lectures we will explain the various topics and provide more insight than what is written in the notes.

\sphinxAtStartPar
The exercises contained in this book have the solutions hidden from the reader by default but can be revealed by clicking on the drop down link. Readers are advised to avoid the temptation of accessing the solutions before an attempt has been made to answer the questions.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Contact information}
\end{DUlineblock}

\noindent{\sphinxincludegraphics[width=125\sphinxpxdimen]{{jon_shiach}.jpeg}\hspace*{\fill}}

\sphinxAtStartPar
\sphinxhref{https://jonshiach.github.io/}{Dr Jon Shiach}
Email: \sphinxhref{mailto:j.shiach@mmu.ac.uk}{j.shiach@mmu.ac.uk} 
Tel: 0161 247 1515 
Office: E115b 

\sphinxstepscope


\part{Part}

\sphinxstepscope


\chapter{Teaching schedule}
\label{\detokenize{0_Preamble/0.1_Teaching_schedule:teaching-schedule}}\label{\detokenize{0_Preamble/0.1_Teaching_schedule:teaching-schedule-section}}\label{\detokenize{0_Preamble/0.1_Teaching_schedule::doc}}
\sphinxAtStartPar
The teaching schedule for this part of the unit is as follows


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Week
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Date (w/c)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Lecture
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Tutorial
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
03/10/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{1_IVPs/1.0_IVPs:ivp-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Initial Value Problems (IVPs)}}}}}: {\hyperref[\detokenize{1_IVPs/1.0_IVPs:ivp-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Definition of an IVP}}}}, the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}}, the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}}, {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:error-analysis-section}]{\sphinxcrossref{\DUrole{std,std-ref}{error analysis}}}}, the {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-section}]{\sphinxcrossref{\DUrole{std,std-ref}{RK2 method}}}}, solving {\hyperref[\detokenize{1_IVPs/1.5_Higher_Order_ODEs:higher-order-odes-section}]{\sphinxcrossref{\DUrole{std,std-ref}{higher order ODEs}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{1_IVPs/1.7_Exercises:ex1-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 1.1}}}} to {\hyperref[\detokenize{1_IVPs/1.7_Exercises:ex1-5}]{\sphinxcrossref{\DUrole{std,std-ref}{1.5}}}}
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
10/10/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.0_ERKs:erk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Explicit Runge\sphinxhyphen{}Kutta Methods (ERK)}}}}}: {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Definition of a Runge\sphinxhyphen{}Kutta method}}}}, the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:butcher-tableau-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher tableau}}}}, derivation of the {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-section}]{\sphinxcrossref{\DUrole{std,std-ref}{RK2}}}} and {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:derivation-of-rk4-section}]{\sphinxcrossref{\DUrole{std,std-ref}{RK4}}}} methods
&
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 2.1}}}} to {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-5}]{\sphinxcrossref{\DUrole{std,std-ref}{2.5}}}}
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
17/10/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.0_ERKs:erk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Explicit Runge\sphinxhyphen{}Kutta Methods (ERK) cont}}}}}:  {\hyperref[\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:applying-erk-methods-to-solve-ivps-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Solving IVPs using ERK methods}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-6}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 2.6}}}} to {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-11}]{\sphinxcrossref{\DUrole{std,std-ref}{2.11}}}}
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
24/10/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{3_IRKs/3.0_IRKs:irk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Implicit Runge\sphinxhyphen{}Kutta Methods (IRK)}}}}}: {\hyperref[\detokenize{3_IRKs/3.0_IRKs:order-of-irk-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Order of an IRK method}}}}, {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:deriving-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{deriving IRK methods}}}}, {\hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-ivps-using-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{solving IVPs using IRK methods}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{3_IRKs/3.4_IRK_exercises:ex3-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 3.1}}}} to {\hyperref[\detokenize{3_IRKs/3.4_IRK_exercises:ex3-5}]{\sphinxcrossref{\DUrole{std,std-ref}{3.5}}}}
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
31/10/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{4_Stability/4.0_Stability:stability-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Stability}}}}}:  {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Definition of stability}}}}, {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stiff ODEs}}}}, {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:stability-functions-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stability functions}}}}, {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:absolute-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{absolute stability}}}}, plotting the {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:plot-stability-region-section}]{\sphinxcrossref{\DUrole{std,std-ref}{region of absolute stability}}}}, {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stability}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{4_Stability/4.5_Stability_exercises:ex4-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 4.1}}}} to {\hyperref[\detokenize{4_Stability/4.5_Stability_exercises:ex4-4}]{\sphinxcrossref{\DUrole{std,std-ref}{4.4}}}}
\\
\hline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
07/11/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{5_BVPs/5.0_BVPs:bvp-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Boundary Value Problems (BVPs)}}}}}:  Definition, {\hyperref[\detokenize{5_BVPs/5.0_BVPs:existence-and-uniqueness-of-bvp-solutions-section}]{\sphinxcrossref{\DUrole{std,std-ref}{existence and uniqeness of solutions}}}}, the {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{shooting method}}}}, the {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference method}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 5.1}}}} to {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-3}]{\sphinxcrossref{\DUrole{std,std-ref}{5.3}}}}
\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
14/11/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{5_BVPs/5.0_BVPs:bvp-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Boundary Value Problems (BVPs) cont.}}}}}: The {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference method}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-4}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 5.4}}}} and {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-5}]{\sphinxcrossref{\DUrole{std,std-ref}{5.5}}}}
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
21/11/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.0_Direct_methods:direct-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Direct methods}}}}}:  {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-section}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}}, {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:crouts-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Crouts method}}}}, {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-section}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition with partial pivoting}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:ex6-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 6.1}}}} and {\hyperref[\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:ex6-2}]{\sphinxcrossref{\DUrole{std,std-ref}{6.2}}}}
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
28/11/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-section}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Direct methods cont.}}}}}:  {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky decomposition}}}}, {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}]{\sphinxcrossref{\DUrole{std,std-ref}{QR decomposition}}}}, the {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gram-schmidt-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gram\sphinxhyphen{}Schmidt process}}}}, {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Householder transformations}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:ex6-3}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 6.3}}}} to {\hyperref[\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:ex6-5}]{\sphinxcrossref{\DUrole{std,std-ref}{6.5}}}}
\\
\hline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
05/12/2022
&
\sphinxAtStartPar
{\hyperref[\detokenize{7_Indirect_methods/7.0_Indirect_methods:indirect-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{Indirect methods}}}}}:  {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi}}}}, {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel}}}} and {\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:sor-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SOR}}}} methods,{\hyperref[\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods:convergence-of-indirect-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{convergence of indirect methods}}}}
&
\sphinxAtStartPar
{\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-1}]{\sphinxcrossref{\DUrole{std,std-ref}{Exercises 7.1}}}} to {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-6}]{\sphinxcrossref{\DUrole{std,std-ref}{7.6}}}}
\\
\hline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
12/12/2022
&
\sphinxAtStartPar
\sphinxstylestrong{Consolidation and exam preparation}  \sphinxstylestrong{Coursework deadline 9pm on 16/12/2022}
&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\chapter{Software}
\label{\detokenize{0_Preamble/0.2_Software:software}}\label{\detokenize{0_Preamble/0.2_Software::doc}}
\sphinxAtStartPar
The calculations required for the computational methods covered here will require the writing of computer programs. These notes contain example Python code which you can enter and adapt as necessary. You may also use MATLAB to perform the calculations and the MATLAB code can be easily translated from the Python examples.


\section{Python}
\label{\detokenize{0_Preamble/0.2_Software:python}}
\sphinxAtStartPar
Python is open source software which means it is free to download and install on your home machine. The easiest way to do this is to download and install Anaconda which is a suite of science and data analytics software which includes Python in addition to Jupyter notebook and Spyder integrated development environment which allow us to write an execute Python code.

\sphinxAtStartPar
To install Anaconda click on the link below and then click on the download button. This should download the installer appropriate for your operating system.

\sphinxAtStartPar
Download Anaconda


\section{MATLAB}
\label{\detokenize{0_Preamble/0.2_Software:matlab}}
\sphinxAtStartPar
As a student of Manchester Met you can download and install MATLAB to your computer free of charge. To do this click on the link below and follow the installation instructions

\sphinxAtStartPar
MATLAB installation instructions

\sphinxstepscope


\chapter{Learning and teaching}
\label{\detokenize{0_Preamble/0.3_Learning_and_teaching:learning-and-teaching}}\label{\detokenize{0_Preamble/0.3_Learning_and_teaching::doc}}
\sphinxAtStartPar
Having got to this stage in your studies you should already be familiar with the learning and teaching practices employed at undergraduate level. However, since this is a final year unit there will be certain expectations of the students from the teaching team. Our advice would be to try and stay on top of the material as much as possible and make sure you are completing the required number of hours of independent study outside of class time.

\sphinxAtStartPar
In order to successfully complete this unit students should:
\begin{itemize}
\item {} 
\sphinxAtStartPar
attend all of the lectures and tutorials;

\item {} 
\sphinxAtStartPar
complete all examples by yourself â€“ these notes contain the solutions to the examples which will be worked through in class, however, it is important that you write down the solutions as this will help you understand the material;

\item {} 
\sphinxAtStartPar
attempt all of the tutorial exercises;

\item {} 
\sphinxAtStartPar
if you are struggling, ask for help at the earliest opportunity.

\end{itemize}

\sphinxAtStartPar
In return the teaching team will:
\begin{itemize}
\item {} 
\sphinxAtStartPar
provide students with detailed lecture notes and other supporting material;

\item {} 
\sphinxAtStartPar
answer student queries regarding the material;

\item {} 
\sphinxAtStartPar
provide solutions/answers to worked examples and tutorial exercises;

\item {} 
\sphinxAtStartPar
provide formative feedback based on the tutorial exercises;

\item {} 
\sphinxAtStartPar
provide exam style questions for use as revision materials.

\end{itemize}

\sphinxAtStartPar
Most students find the step up to the final challenging and there will be times during the year that you may not fully understand all of the concepts being taught. In these situations we would advise you to read over the material again, follow the examples given and most importantly ask questions in lectures and tutorials. If there are gaps in your knowledge from previous years, you must make sure that you address these as there will not be much time to go over previous level material again.

\sphinxstepscope


\part{Runge\sphinxhyphen{}Kutta Methods}

\sphinxstepscope


\chapter{Initial Value Problems}
\label{\detokenize{1_IVPs/1.0_IVPs:initial-value-problems}}\label{\detokenize{1_IVPs/1.0_IVPs:ivp-chapter}}\label{\detokenize{1_IVPs/1.0_IVPs::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning Outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
identify an {\hyperref[\detokenize{1_IVPs/1.0_IVPs:ivp-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{initial value problem}}}};

\item {} 
\sphinxAtStartPar
approximate a function using the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}};

\item {} 
\sphinxAtStartPar
derive the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} and apply it to solve first\sphinxhyphen{}order ordinary differential equations;

\item {} 
\sphinxAtStartPar
express a {\hyperref[\detokenize{1_IVPs/1.5_Higher_Order_ODEs:higher-order-odes-section}]{\sphinxcrossref{\DUrole{std,std-ref}{higher\sphinxhyphen{}order ordinary differential equation}}}} as a system of first\sphinxhyphen{}order ordinary differential equation;

\item {} 
\sphinxAtStartPar
apply an ODE solver to {\hyperref[\detokenize{1_IVPs/1.5_Higher_Order_ODEs:solving-systems-of-odes-section}]{\sphinxcrossref{\DUrole{std,std-ref}{solve a system of ordinary differential equation}}}}.

\end{itemize}


\bigskip\hrule\bigskip



\section{Ordinary Differential Equations}
\label{\detokenize{1_IVPs/1.0_IVPs:ordinary-differential-equations}}\label{\detokenize{1_IVPs/1.0_IVPs:ode-section}}
\sphinxAtStartPar
An Ordinary Differential Equation (ODE) is an equation which contains the derivatives of a function e.g., \(y(t)\), of a \sphinxstylestrong{single} independent variable \(t\). ODEs occur in many different applications so it is important that we are able to solve them. Simple ODEs can be solved using \sphinxstylestrong{analytical} methods such as integration and Laplace transforms, however, the vast majority of ODEs used in the real world cannot be solved using analytical methods which is why we need a \sphinxstylestrong{numerical} approach.

\begin{sphinxadmonition}{note}{Definition: Ordinary Differential Equation}

\sphinxAtStartPar
An Ordinary Differential Equation (ODE) is an equation of the form
\begin{equation*}
\begin{split}y^{(n)} = f(t, y, y', y'', \ldots, y^{(n-1)}),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(y = y(t)\) is some function of the independent variable \(t\), \(y^{(n)}\) is the \(n\)th derivative of \(y\) and \(f\) is some function of \(t\), \(y\) and its derivatives.
\end{sphinxadmonition}

\sphinxAtStartPar
The solution of an ODE is a function \(y = y(t)\) that satisfies the ODE over the domain of \(t\). For example, consider the following ODE
\begin{equation}\label{equation:1_IVPs/1.0_IVPs:simple-ode}
\begin{split} y' = y,\end{split}
\end{equation}
\sphinxAtStartPar
where \(t \in \mathbb{R}\). Rewriting this using Leibniz notation and integrating both sides we have
\begin{align*}
    \frac{\mathrm{d} y}{\mathrm{d} t} & = y \\
    \frac{\mathrm{d} y}{y} &= \mathrm{d} t \\
    \int \frac{1}{y} \mathrm{d} y &= \int 1 \mathrm{d} t \\
    \ln (y) + c_1 &= t + c_2 \\
    \ln (y) &= t + c_1 + c_2 \\
    y &= e^{t + c},
\end{align*}
\sphinxAtStartPar
where \(c = c_1 + c_2\) is some constant. The solution can be verified by differentiating \(y\) and check that it satisfies the original ODE. This solution has been plotted for various values of the constant \(c\) in \hyperref[\detokenize{1_IVPs/1.0_IVPs:ode-plot-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.0_IVPs:ode-plot-figure}}}. Note that there are an infinite number of solutions since \(c\) can be any value.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.0_IVPs_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Plots of some of the possible solution to the ODE \(y' = y\).}\label{\detokenize{1_IVPs/1.0_IVPs:ode-plot-figure}}\end{figure}

\sphinxAtStartPar
However, if we know that the value of the solution \(y\) for some \(t\) then we can calculate \(c\). For example, if the solution to the ODE in equation \eqref{equation:1_IVPs/1.0_IVPs:simple-ode} is known to be \(y(0) = \alpha\) then
\begin{align*}
    \alpha &= e^{0 + c} = e^c \\
    \therefore c &= \ln(\alpha)
\end{align*}
\sphinxAtStartPar
so the ODE has the solution
\begin{align*}
    y &= e^{t + \ln(\alpha)}.
\end{align*}
\sphinxAtStartPar
Different values of \(\alpha\) in the initial solution \(y(0)=\alpha\) give different unique solutions to the ODE. Problems of this type are known as \sphinxstylestrong{initial value problems}.

\begin{sphinxadmonition}{note}{Definition: Initial value problem}

\sphinxAtStartPar
An Initial Value Problem (IVP) is an ODE where the initial solution at the lower boundary of the domain is known. For example,
\begin{align*}
    y' = f(t,y), \qquad t\in [a ,b ], \qquad y(a) = \alpha.
\end{align*}
\sphinxAtStartPar
Here a first\sphinxhyphen{}order ODE \(y'=f(t,y)\) is defined over the domain \(t\in [a ,b]\) and the initial solution \(y(a)\) is the known value \(\alpha\).
\end{sphinxadmonition}

\sphinxAtStartPar
Unfortunately, for most real world practical applications initial value problems cannot be solved using analytical methods so instead we use numerical methods to approximate the solution.

\sphinxstepscope


\section{The Taylor Series}
\label{\detokenize{1_IVPs/1.1_Taylor_Series:the-taylor-series}}\label{\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-section}}\label{\detokenize{1_IVPs/1.1_Taylor_Series::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Taylor series} named after English mathematician \sphinxhref{https://en.wikipedia.org/wiki/Brook\_Taylor}{Brook Taylor} is a series expansion of a function.

\begin{sphinxadmonition}{note}{Definition: The Taylor series}

\sphinxAtStartPar
Let \(f(t)\) be a differentiable function of the variable \(t\) then the value \(f(t+h)\) where \(h\) is some small value can be written using the Taylor series
\begin{align*}
    f(t+h) &= \sum_{n = 0}^\infty \frac{h^n}{n!}f^{(n)}(t) \\
    &= f(t) + hf'(t) + \frac{h^2}{2!}f''(t) + \frac{h^3}{3!}f'''(t) + \cdots
\end{align*}\end{sphinxadmonition}

\sphinxAtStartPar
We can use the Taylor series to approximate the value of \(f(t)\) where the smaller the value of \(h\) the closer the approximation \(f(t+h)\) is to actual value \(f(t)\). The problem with we have is that we cannot sum an infinite number of terms so instead we only consider the first \(n\) terms in the summation
\begin{align*}
    f(t+h) &= \underbrace{f(t) + hf'(t) + \frac{h^2}{2!}f''(t) \cdots + \frac{h^n}{n!}f^{(n)}(t)}_{\mathrm{first }\,n\,\mathrm{ terms}} \\
    & \qquad + \underbrace{\frac{h^{n+1}}{(n+1)!}f^{(n+1)}(t) + \frac{h^{n+2}}{(n+2)!}f^{(n+2)}(t) + \cdots}_{\mathrm{Highter\,Order\,Terms \,(HOT)}}
\end{align*}
\sphinxAtStartPar
It is important to note that since we are omitting the higher order terms in the truncation of the Taylor series we only have an \sphinxstylestrong{approximation} of \(f(t+h)\). When we omit the Higher\sphinxhyphen{}Order Terms (HOT) from the Taylor series we say we have \sphinxstylestrong{truncated} the Taylor series. So if for example we omit all terms higher than fourth\sphinxhyphen{}order we have the \sphinxstylestrong{fourth\sphinxhyphen{}order Taylor series expansion} of \(f(t+h)\).
\begin{equation*}
\begin{split}f(t+h) = f(t) + hf' (t)+\frac{h^2}{2}f'' (t) + \frac{h^3}{3!}f^{''')}(t) + \frac{h^4}{4!}f^{(4)} + \mathrm{HOT}.\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Example 1.1}

\sphinxAtStartPar
Use the first, second, third and fourth\sphinxhyphen{}order Taylor series expansions to calculate the value of \(\cos\left(\frac{\pi}{3} + h\right)\) where \(h=0.2\).
\subsubsection*{Solution}

\sphinxAtStartPar
Here \(t=\frac{\pi}{3}\), \(h=0.2\), \(f(t) = \cos(t)\) and \(f'(t) = -\sin(t)\) so the first\sphinxhyphen{}order expansion is
\begin{align*}
    \cos(t + h) &\approx \cos(t) - h \sin(t) \\
    \cos\left(\frac{\pi}{3} + 0.2 \right) &\approx \cos\left(\frac{\pi}{3}\right) - 0.2 \sin\left(\frac{\pi}{3}\right)
    \\
    &= 0.5 - 0.173205 = 0.326795.
\end{align*}
\sphinxAtStartPar
We know that the exact value is \(\cos(\frac{\pi}{3} + 0.2) = 0.317980\ldots\) so the error in the first\sphinxhyphen{}order Taylor series approximation is \(|0.317980 - 0.326795| = 0.008814\).

\sphinxAtStartPar
The second derivative of \(f(t) = \cos(t)\) is \(f''(t) = \dfrac{\mathrm{d}}{\mathrm{d}t}(-\sin(t)) = -\cos(t)\) so the second\sphinxhyphen{}order expansion is
\begin{align*}
    \cos(t + h) &\approx \underbrace{\cos(t) - h \sin(t)}_{\mathrm{first\,order\,expansion}} - \frac{h^2}{2!} \cos(t).
\end{align*}
\sphinxAtStartPar
The first two terms in the second\sphinxhyphen{}order expansion is the first\sphinxhyphen{}order expansion which we have already calculated so
\begin{align*}
    \cos\left(\frac{\pi}{3} + 0.2 \right) &\approx 0.326795 - \frac{0.2^2}{2} \cos\left(\frac{\pi}{3}\right) \\
    &= 0.326795 - 0.010000 = 0.316795.
\end{align*}
\sphinxAtStartPar
Doing similar for the third and fourth\sphinxhyphen{}order expansions
\begin{align*}
    \mathrm{3rd\,order}: && \cos\left(\frac{\pi}{3} + 0.2 \right) &\approx 0.316795 + \frac{0.2^3}{6} \sin\left(\frac{\pi}{3}\right) \\
    &&& = 0.316795 + 0.001155 = 0.317950, \\
    \mathrm{4th\,order}: && \cos(\left(\frac{\pi}{3} + 0.2 \right) &\approx 0.317950 + \frac{0.2^4}{6} \cos\left(\frac{\pi}{3}\right) \\
    &&& = 0.317950 + 0.000033 = 0.317983.
\end{align*}
\sphinxAtStartPar
The Taylor series approximations and the errors have been tabulated below. Note that as we include more terms in the Taylor series expansion the error tends to zero.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(n\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Taylor series approximation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
error
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0.500000
&
\sphinxAtStartPar
1.82e\sphinxhyphen{}01
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0.326795
&
\sphinxAtStartPar
8.81e\sphinxhyphen{}03
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0.316795
&
\sphinxAtStartPar
1.19e\sphinxhyphen{}03
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0.317950
&
\sphinxAtStartPar
3.10e\sphinxhyphen{}05
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0.317983
&
\sphinxAtStartPar
2.35e\sphinxhyphen{}06
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{Using Python to calculate a Taylor series approximation}
\label{\detokenize{1_IVPs/1.1_Taylor_Series:using-python-to-calculate-a-taylor-series-approximation}}
\sphinxAtStartPar
The code below calculates the Taylor series approximation of \(\cos(t + h)\) using the first \(n\) terms of the series. Note that since the derivative of \(\cos(t)\) is \(-\sin(t)\) so if \(n\) is even then \(f^{(n)}(t) = \pm \cos\) and when \(n\) is odd \(f^{(n)}(t) = \pm \sin(t)\). To calculate this we can use an \sphinxcode{\sphinxupquote{if}} statement that checks whether the current value of \(n\) is even or odd and calculates the value \(f(t)\) accordingly and change the sign of \(f^{(n)}(t)\) when \(n\) is odd.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{3}  \PYG{c+c1}{\PYGZsh{} variable}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.2}        \PYG{c+c1}{\PYGZsh{} step length}
\PYG{n}{nmax} \PYG{o}{=} \PYG{l+m+mi}{4}       \PYG{c+c1}{\PYGZsh{} highest order term retained}
\PYG{n}{sign} \PYG{o}{=} \PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} sign for the nth term}
\PYG{n}{approx} \PYG{o}{=} \PYG{l+m+mi}{0}     \PYG{c+c1}{\PYGZsh{} value of the approximation}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  n  | approximation |  error   |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nmax} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{f} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{f} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
        \PYG{n}{sign} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{sign} 
    
    \PYG{n}{approx} \PYG{o}{+}\PYG{o}{=} \PYG{n}{sign} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{math}\PYG{o}{.}\PYG{n}{factorial}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{  |    }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{approx}\PYG{l+s+si}{:}\PYG{l+s+s2}{7.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{   | }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{t} \PYG{o}{+} \PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{approx}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{7.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|  n  | approximation |  error   |
|:\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|
|  0  |    0.500000   | 1.82e\PYGZhy{}01 |
|  1  |    0.326795   | 8.81e\PYGZhy{}03 |
|  2  |    0.316795   | 1.19e\PYGZhy{}03 |
|  3  |    0.317950   | 3.10e\PYGZhy{}05 |
|  4  |    0.317983   | 2.35e\PYGZhy{}06 |
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{The Euler method}
\label{\detokenize{1_IVPs/1.2_Euler_Method:the-euler-method}}\label{\detokenize{1_IVPs/1.2_Euler_Method:euler-method-section}}\label{\detokenize{1_IVPs/1.2_Euler_Method::doc}}
\sphinxAtStartPar
The \sphinxhref{https://en.wikipedia.org/wiki/Euler\_method}{\sphinxstylestrong{Euler method}} is the simplest numerical method used to solve ODEs can be derived very easily by truncating equation the Taylor series after the first\sphinxhyphen{}order term
\begin{equation*}
\begin{split}y(t + h) = y(t) + h y'(t).\end{split}
\end{equation*}
\sphinxAtStartPar
We wish to solve the ODE \(y'(t) = f(t, y)\) so replacing \(y'(t)\) with \(f(t,y)\) we have
\begin{equation*}
\begin{split}y(t + h) = y(t) + h f(t, y),\end{split}
\end{equation*}
\sphinxAtStartPar
and introducing subscript notation where \(y(t) = y_n\) and \(y(t+h) = y_{n+1}\) then this gives us the Euler method.

\begin{sphinxadmonition}{note}{Definition: The Euler method}

\sphinxAtStartPar
The Euler method for solving the initial value problem \(y' = f(t, y)\), \(t \in [a, b]\), \(y_0 = y(a)\) is
\begin{equation}\label{equation:1_IVPs/1.2_Euler_Method:euler-method-equation}
\begin{split}\begin{align}
y_{n+1} = y_n + h f(t_n ,y_n),
\end{align}\end{split}
\end{equation}
\sphinxAtStartPar
where \(h = t_{n+1} - t_n\).
\end{sphinxadmonition}

\sphinxAtStartPar
The solution of the initial value problem using the Euler method will result in two vectors containing the values of \(t\) and \(y\)
\begin{align*}
    \mathbf{t} &= \begin{pmatrix} t_0 \\ t_0 + h \\ t_0 + 2h \\ \vdots \\ t_0 + nh \end{pmatrix}, &
    \mathbf{y} &= \begin{pmatrix} y_0 \\ y_1 \\ y_2 \\ \vdots \\ y_n \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
To apply the Euler method we first calculate the number of steps of the method that are required to calculate the solution over the \(t\) domain from \(t_0 = a\) up to \(t_n = b\). If we are using a constant value for the step length than the number of steps required is
\begin{equation*}
\begin{split}n = \left\lfloor \frac{b - a}{h} \right\rfloor,\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\lfloor x \rfloor\) rounds the number \(x\) to the integer below. If \(h\) divides \(b - a\) exactly then the last value of \(t_n = b\). If \(h\) does not divide \(b - a\) exactly then \(t_n < b\), in these cases we can use a smaller step length for the last step or leave it as it is (here we will use a constant value of \(h\)).

\sphinxAtStartPar
To solve an initial value problem using the Euler method we first initialise the \(t_0 = a\) and \(y_0 = \alpha\) and then calculate the value of \(y_1\) using equation \eqref{equation:1_IVPs/1.2_Euler_Method:euler-method-equation} and \(t_1 = t_0 + h\). Then we use \(t_1\) and \(y_1\) to calculate the value of \(y_2\) and \(t_2 = t_1 + h\). We continue in this way until we have calculated up to \(y_n\) and \(t_n\). The Euler method is an example of a \sphinxstylestrong{single step method} since it only requires information from a single step of the solution to calculate the next step. The other type of numerical method for solving ODEs is the \sphinxhref{https://en.wikipedia.org/wiki/Linear\_multistep\_method}{\sphinxstylestrong{linear multistep method}} that requires information from multiple previous steps.

\begin{sphinxadmonition}{note}{Example 1.2}

\sphinxAtStartPar
Calculate the solution to the following initial value problem using the Euler method with \(h = 0.2\)
\begin{equation*}
\begin{split}y' = ty, \qquad t\in [0,1], \qquad y(0)=1,\end{split}
\end{equation*}
\sphinxAtStartPar
and compare the computed solution to the exact solution which is \(y = \exp\left(\dfrac{t^2}{2}\right)\).
\subsubsection*{Solution}

\sphinxAtStartPar
Since \(t\in[0,1]\) and \(h=0.2\) then the number of steps required is
\begin{equation*}
\begin{split}n = \operatorname{int}\left(\frac{1 - 0}{0.2}\right) = 5, \end{split}
\end{equation*}
\sphinxAtStartPar
therefore the \(t\) values are
\begin{equation*}
\begin{split}\mathbf{t} = (0, 0.2, 0.4, 0.6, 0.8, 1.0).\end{split}
\end{equation*}
\sphinxAtStartPar
We know the ODE function is \(f(t, y) = ty\) and initial value is \(y_0 = 1\) so using equation \eqref{equation:1_IVPs/1.2_Euler_Method:euler-method-equation} we have
\begin{align*}
    y_1 &= y_0 + h f(t_0, y_0) = 1 + 0.2(0)(1) = 1,  \\
    y_2 &= y_1 + h f(t_1, y_1) = 1 + 0.2(0.2)(1) = 1.04, \\
    y_3 &= y_2 + h f(t_2, y_2) = 1.04 + 0.2(0.4)(1.04) = 1.1232, \\
    y_4 &= y_3 + h f(t_3, y_3) = 1.1232 + 0.2(0.6)(1.1232) = 1.257984, \\
    y_5 &= y_4 + h f(t_4, y_4) = 1.257984 + 0.2(0.8)(1.257984) = 1.459261.
\end{align*}
\sphinxAtStartPar
The computed solutions, the exact solutions and the errors between the computed and exact solutions are tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Euler
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Error
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
1.000000
&
\sphinxAtStartPar
1.000000
&
\sphinxAtStartPar
0.00e+00
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
1.000000
&
\sphinxAtStartPar
1.020201
&
\sphinxAtStartPar
2.02e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
1.040000
&
\sphinxAtStartPar
1.083287
&
\sphinxAtStartPar
4.33e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
1.123200
&
\sphinxAtStartPar
1.197217
&
\sphinxAtStartPar
7.40e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.257984
&
\sphinxAtStartPar
1.377128
&
\sphinxAtStartPar
1.19e\sphinxhyphen{}01
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
1.459261
&
\sphinxAtStartPar
1.648721
&
\sphinxAtStartPar
1.89e\sphinxhyphen{}01
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{1_IVPs/1.2_Euler_Method:python-code}}\label{\detokenize{1_IVPs/1.2_Euler_Method:py-euler}}
\sphinxAtStartPar
You may have noticed that calculating the solution to an initial value problem using a numerical method using a pen, paper and calculator is a tedious exercise requiring lots of repeated calculations. This is way we use computers to do this work for us. First we import the \sphinxhref{https://numpy.org/}{NumPy} and \sphinxhref{https://matplotlib.org/}{matplotlib} libraries so that we can perform numerical calculations and produce plots of the solutions.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Next we define a function called \sphinxcode{\sphinxupquote{euler()}} which uses the Euler method to calculate calculates the solution to an initial value problem.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The inputs to the function \sphinxcode{\sphinxupquote{euler()}} are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{f}} \sphinxhyphen{} the name of the ODE function to be solved (this needs to be defined elsewhere)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tspan}} \sphinxhyphen{} an array of two values defining the lower and upper boundaries of the \(t\) domain

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{y0}} \sphinxhyphen{} an array of values containing the solution of the ODE at the initial value \(t=a\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{h}} \sphinxhyphen{} the step length used

\end{itemize}

\sphinxAtStartPar
The function first determines the number of steps required and the number of ODEs being solved and stores these in \sphinxcode{\sphinxupquote{nsteps}} and \sphinxcode{\sphinxupquote{neq}} respectively. In the example here we are only solving for one equation we will need to be able to {\hyperref[\detokenize{1_IVPs/1.5_Higher_Order_ODEs:solving-systems-of-odes-section}]{\sphinxcrossref{\DUrole{std,std-ref}{solve multiple ODEs at the same time}}}}. It then calculates two arrays called \sphinxcode{\sphinxupquote{t}} and \sphinxcode{\sphinxupquote{y}}. The array \sphinxcode{\sphinxupquote{t}} array contains the values of \(t_n\) for which the Euler method calculates the solution and is determined by \sphinxcode{\sphinxupquote{h}} and \sphinxcode{\sphinxupquote{nsteps}}%
\begin{footnote}[1]\sphinxAtStartFootnote
This assumes that we are using a constant step length. Some methods use \sphinxhref{https://en.wikipedia.org/wiki/Adaptive\_step\_size}{adaptive step size} where the value of \(h\) is modified at each step to optimise the accuracy. These methods are outside the scope of this unit so will not be considered here)
%
\end{footnote}. The \sphinxcode{\sphinxupquote{y}} array has \sphinxcode{\sphinxupquote{nsteps + 1}} rows and \sphinxcode{\sphinxupquote{neq}} columns (short for the \sphinxstyleemphasis{number of equations}) will contain the solutions of the ODE(s) where each row contains the solution at each step of the Euler method and the first row of \sphinxcode{\sphinxupquote{y}} is set to \sphinxcode{\sphinxupquote{y0}} since it contains the initial solution. A \sphinxcode{\sphinxupquote{for}} loop is used to loop through each of the steps and calculate the solution using the Euler method. The arrays \sphinxcode{\sphinxupquote{t}} and \sphinxcode{\sphinxupquote{y}} containing the solution to the IVP are returned.

\sphinxAtStartPar
The code below defines the functions \sphinxcode{\sphinxupquote{f(t, y)}} and \sphinxcode{\sphinxupquote{exact(t)}} which calculate the ODE function and exact solution to the IVP. In most practical cases the exact solution will not be known, if it was we wouldnâ€™t need a numerical method to solve the ODE, however we often use ODEs with known exact solutions to assess the effectiveness of the numerical methods used to solve the ODEs.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{*} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below defines the IVP parameters and calls the \sphinxcode{\sphinxupquote{euler()}} function to solve the IVP. The solutions are outputted in a table containing the numerical solution, the exact solution and the absolute error.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define IVP parameters}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.2}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Calculate the solution to the IVP}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print table of solution values}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  t   |   Euler   |   Exact   |  Error   |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{4.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{8.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|  t   |   Euler   |   Exact   |  Error   |
|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|
| 0.00 |  1.000000 |  1.000000 | 0.00e+00 |
| 0.20 |  1.000000 |  1.020201 | 2.02e\PYGZhy{}02 |
| 0.40 |  1.040000 |  1.083287 | 4.33e\PYGZhy{}02 |
| 0.60 |  1.123200 |  1.197217 | 7.40e\PYGZhy{}02 |
| 0.80 |  1.257984 |  1.377128 | 1.19e\PYGZhy{}01 |
| 1.00 |  1.459261 |  1.648721 | 1.89e\PYGZhy{}01 |
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In most cases, a plot of the solution is more useful for looking at the behaviour of the solution. The code below plots the numerical solution obtained using the Euler method with the exact solution.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate exact solution}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot solution}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Euler}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.2_Euler_Method_11_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The solution to the IVP \(y'=ty\), \(t\in [0, 1]\), \(y(0) = 1\) using the Euler method with \(h=0.2\).}\label{\detokenize{1_IVPs/1.2_Euler_Method:euler-figure}}\end{figure}

\sphinxAtStartPar
Note that the solution obtained using the Euler method deviates away from the exact solution as the value of \(t\) increases. We will see why this is the case in the next section on {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:error-analysis-section}]{\sphinxcrossref{\DUrole{std,std-ref}{error analysis}}}}.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Error analysis}
\label{\detokenize{1_IVPs/1.3_Error_Analysis:error-analysis}}\label{\detokenize{1_IVPs/1.3_Error_Analysis:error-analysis-section}}\label{\detokenize{1_IVPs/1.3_Error_Analysis::doc}}
\sphinxAtStartPar
We have seen in the previous section that the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-figure}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method solution}}}} of the initial value problem  in {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 1.2}}}} deviates from the exact solution. This is because we have truncated the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}} so that any term after the first\sphinxhyphen{}order derivative is ignored. The omission of the higher\sphinxhyphen{}order terms means that the Taylor series is longer equal to \(f(t+h)\) and we have introduced an error. It is important that we study this error and the effect that the errors have on our solutions.


\subsection{Big\sphinxhyphen{}O notation}
\label{\detokenize{1_IVPs/1.3_Error_Analysis:big-o-notation}}\label{\detokenize{1_IVPs/1.3_Error_Analysis:big-o-notation-section}}
\sphinxAtStartPar
Analyising the error of numerical method is challenging since we do not know what the exact solution is (if we did we wouldnâ€™t need a numerical method). Also, if we did know the exact solution the value of the difference between the numerical solution and the exact solution would only apply to that specific problem. So instead we look at the behaviour of the error. Recall the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} which is
\begin{equation*}
\begin{split}y_{n+1} = y_n + h f(t_n, y_n),\end{split}
\end{equation*}
\sphinxAtStartPar
so the solution over a single time step is changed from the current solution \(y_n\) by \(h\) times the value of \(f(t_n, y_n)\). If we assume that that value of \(y_n\) has some error associated to it then the error will also be changed by \(h\) times some value. Therefore, the smaller the value of \(h\) then the smaller the change in the error converging to zero when \(h\) is infintesimally small. Different numerical methods will converge to zero at different rates and since we want our numerical solutions to be accurate we would favour a method which converges quickly.

\sphinxAtStartPar
To compare the accuracy of different numerical methods we use \sphinxhref{https://en.wikipedia.org/wiki/Big\_O\_notation}{\sphinxstylestrong{big\sphinxhyphen{}O notation}} which describes the rate at which a function tends to zero (or infinity).

\begin{sphinxadmonition}{note}{Definition: Big\sphinxhyphen{}O notation}

\sphinxAtStartPar
Let \(f(h) = O(h^n)\) then
\begin{equation*}
\begin{split}\lim_{h \to 0} f(h) = Ch^n\end{split}
\end{equation*}
\sphinxAtStartPar
for some positive constant \(C\).
\end{sphinxadmonition}

\sphinxAtStartPar
If \(f(h) = O(h^n)\) then we say that \sphinxstyleemphasis{â€œf of h is big O of h to the power nâ€} which means \(f(h)\) tends to zero at least as fast as \(h^n\). For example, if \(f(h) = O(h)\) then if we halve \(h\) then we would expect \(f(h)\) to also be halved (known as linear convergence), however if \(f(h) = O(h^2)\) then if we halve \(h\) then the value of \(f(h)\) would be quartered since \((\frac{1}{2})^2 = \frac{1}{4}\) (known as quadratic convergence). So the higher the power of \(h\) the faster the function \(f(h)\) converges to zero as \(h\) is decreased.

\sphinxAtStartPar
Since the error of a numerical method is dependent upon the step length \(h\) then we can say that it behaves like a polynomial function \(f(h) = O(h^n)\).

\begin{sphinxadmonition}{note}{Definition: Order of a method}

\sphinxAtStartPar
If the error of a numerical method is \(O(h^n)\) then the method is said to be of order \(n\).
\end{sphinxadmonition}


\subsection{Local truncation error}
\label{\detokenize{1_IVPs/1.3_Error_Analysis:local-truncation-error}}\label{\detokenize{1_IVPs/1.3_Error_Analysis:local-truncation-error-section}}
\begin{sphinxadmonition}{note}{Definition: Local Truncation Error}

\sphinxAtStartPar
The Local Truncation Error (LTE), \(\tau_n\), is the error in the calculation of a single step of a numerical method assuming that the previous values used are exact.
\end{sphinxadmonition}

\sphinxAtStartPar
Writing the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}} expansion for \(y(t)\) and if \(y'(t) = f(t, y)\) then
\begin{equation*}
\begin{split}y(t + h) = y(t) + hf(t, y) + \frac{h^2}{2!}f'(t, y) + \frac{h^3}{3!}f''(t, y) + \frac{h^4}{4!}f'''(t, y) + \cdots \end{split}
\end{equation*}
\sphinxAtStartPar
Since when deriving the Euler method we truncated the Taylor series to first\sphinxhyphen{}order then
\begin{equation*}
\begin{split}y_{n+1} = y_n + h f(t_n, y_n) + \tau_n,\end{split}
\end{equation*}
\sphinxAtStartPar
where the local truncation error is
\begin{equation*}
\begin{split} \tau_n = \frac{h^2}{2!}f'(t_n, y_n) + \frac{h^3}{3!}f''(t_n, y_n) + \frac{h^4}{4!}f'''(t_n, y_n) + \cdots \end{split}
\end{equation*}
\sphinxAtStartPar
The value of the first term is larger than that of all of the other terms so we can say that \(\tau = O(h^2)\).


\subsection{Global truncation error}
\label{\detokenize{1_IVPs/1.3_Error_Analysis:global-truncation-error}}\label{\detokenize{1_IVPs/1.3_Error_Analysis:global-truncation-error-section}}
\begin{sphinxadmonition}{note}{Definition: Global Truncation Error}

\sphinxAtStartPar
The Global Truncation Error (GTE), \(e_n\), is the error that has accumulated over all previous steps of a numerical method assuming the initial solution was known to be exact.
\end{sphinxadmonition}

\sphinxAtStartPar
The global truncation error is calculated using
\begin{align*}
    e_n = |y_n - \tilde{y}_n |,
\end{align*}
\sphinxAtStartPar
where \(y_n\) and \(\tilde{y}_n\) are the exact and numerical solutions. This is represented graphically in \hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:gte-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.3_Error_Analysis:gte-figure}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.3_Error_Analysis_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The global truncation error, \(e_n\), is the difference between the exact solution, \(y_n\), and the numerical solution, \(\tilde{y}_n\).}\label{\detokenize{1_IVPs/1.3_Error_Analysis:gte-figure}}\end{figure}

\sphinxAtStartPar
We can use the global and local truncations errors to analyse the accuracy of a method. Comparing the application of the Euler method using the exact and approximated solutions
\begin{align*}
    y_{n+1} &= y_{n} + hf(t_n, y_n), \\
    \tilde{y}_{n+1} &= \tilde{y}_n + hf(t_n, \tilde{y}_n) + \tau_{n+1}
\end{align*}
\sphinxAtStartPar
and subtracting the first equation from the second gives
\begin{align*}
    y_{n+1} - \tilde{y}_{n+1} &= y_n - \tilde{y}_n + h(f(t_n, y_n) - f(t_n, \tilde{y}_n)) + \tau_{n+1} \\
    e_{n+1} &= e_n + h(f(t_n, y_n) - f(t_n, \tilde{y}_n)) + \tau_{n+1} 
\end{align*}
\sphinxAtStartPar
Assuming that \(f(t,y)\) satisfies the \sphinxhref{https://en.wikipedia.org/wiki/Lipschitz\_continuity}{\sphinxstylestrong{Lipschitz condition}} which is
\begin{align*}
    |f(t_n, y_n) - f(t_{n+1}, y_{n+1})| \leq L|y_n - y_{n+1}|,
\end{align*}
\sphinxAtStartPar
where \(L\) is the \sphinxstylestrong{Lipschitz constant}, then it can be shown that \(e_n\) satisfies
\begin{align*}
    |e_n| \leq \frac{\max_i (\tau_i)}{h} \left(\frac{\exp(L(t_n - t_0)) - 1}{L}\right).
\end{align*}
\sphinxAtStartPar
The term in the brackets is just some constant, \(C\) say, and since \(\tau = O(h^2)\) then
\begin{align*}
    |e_n| \leq C\frac{O(h^2)}{h} = O(h).
\end{align*}
\sphinxAtStartPar
We can demonstrate this with the Euler method. The plot shown in \hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:euler-hvalues-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.3_Error_Analysis:euler-hvalues-figure}}} below shows the solutions to the IVP from {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-example}]{\sphinxcrossref{\DUrole{std,std-ref}{the Euler method example}}}} calculated using step lengths of \(h=0.2\), \(h=0.1\), \(h=0.05\) and \(h=0.025\). As the step length decreases the numerical solution gets closer to the exact solution as expected.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.3_Error_Analysis_3_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Solutions to the IVP \(y'=ty\), \(t\in[0,1]\), \(y(0)=1\) using the Euler method with step lengths \(h=0.2, 0.1, 0.05, 0.025\).}\label{\detokenize{1_IVPs/1.3_Error_Analysis:euler-hvalues-figure}}\end{figure}

\sphinxAtStartPar
The global truncation errors for the solution to the IVP at \(t=1\) are plotted against the values of the step length in \hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:euler-gte-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.3_Error_Analysis:euler-gte-figure}}} below. Note how the errors approximate a straight line which show that has \(h\) decreases, the errors also decrease in a linear fashion indicating that the Euler method is a first\sphinxhyphen{}order method.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.3_Error_Analysis_5_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The global truncation errors for the Euler method solution of \(y'=t y\), \(y(0)=1\) at \(t=1\).}\label{\detokenize{1_IVPs/1.3_Error_Analysis:euler-gte-figure}}\end{figure}

\sphinxstepscope


\section{The Second\sphinxhyphen{}Order Runge\sphinxhyphen{}Kutta Method}
\label{\detokenize{1_IVPs/1.4_RK2:the-second-order-runge-kutta-method}}\label{\detokenize{1_IVPs/1.4_RK2:rk2-section}}\label{\detokenize{1_IVPs/1.4_RK2::doc}}
\sphinxAtStartPar
We have seen in previous sections on the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} and {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:error-analysis-section}]{\sphinxcrossref{\DUrole{std,std-ref}{error analysis}}}} that the Euler method gives a poor approximation of the exact solution. This is because the Euler method is only first\sphinxhyphen{}order accurate and we can obtain a more accurate approximation of the solution using a second\sphinxhyphen{}order method such as the second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method (RK2).

\begin{sphinxadmonition}{note}{Definition: The second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method (RK2)}

\sphinxAtStartPar
The RK2 method for solving the initial value problem \(y' = f(t, y)\), \(t \in [a, b]\), \(y_0 = y(a)\) is
\begin{equation}\label{equation:1_IVPs/1.4_RK2:rk2-equation}
\begin{split}\begin{align*}
    y_{n+1} &= y_n + \frac{h}{2}(k_1 + k_2),\\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + h, y_n + h k_1).
\end{align*} \end{split}
\end{equation}
\sphinxAtStartPar
where \(h = t_{n+1} - t_n\).
\end{sphinxadmonition}

\sphinxAtStartPar
The derivation of the RK2 method is covered in the {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-section}]{\sphinxcrossref{\DUrole{std,std-ref}{derivation of Explicit Runge\sphinxhyphen{}Kutta Methods}}}}.

\begin{sphinxadmonition}{note}{Example 1.3}

\sphinxAtStartPar
Calculate the solution to the initial value problem from {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 1.2}}}} using the RK2 method with a step length of \(h = 0.2\)
\begin{align*}
    y'=ty, \qquad t\in [0,1], \qquad y(0)=1,
\end{align*}
\sphinxAtStartPar
and compare the computed solution to the exact solution which is \(y = \exp\left(\dfrac{t^2}{2}\right)\).
\subsubsection*{Solution}

\sphinxAtStartPar
From {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 1.2}}}} we know that the number of steps is 5 and \(\mathbf{t} = (0, 0.2, 0.4, 0.6, 0.8, 1.0).\) The ODE function is \(f(t, y) = t y\) and initial value is \(y_0 = 1\) so using equation \eqref{equation:1_IVPs/1.4_RK2:rk2-equation}
\begin{align*}
    k_1 &= f(t_0, y_0) = (0.0)(1) = 0, \\
    k_2 &= f(t_0 + h, y_0 + hk_1) = (0.0 + 0.2)(1 + 0.2(0)) = 0.2, \\
    y_1 &= y_0 + \frac{h}{2}(k_1 + k_2) = 1 + 0.1(0 + 0.2) = 1.02, \\ \\
    k_1 &= f(t_1, y_1) = (0.2)(1.02) = 0.204, \\
    k_2 &= f(t_1 + h, y_1 + hk_1) = (0.2 + 0.2)(1.02 + 0.2(0.204)) \\
    &= 0.424320, \\
    y_2 &= y_1 + \frac{h}{2}(k_1 + k_2) = 1.02 + 0.1(0.204 + 0.424320) \\
    &= 1.082832, \\ \\
    k_1 &= f(t_2, y_2) = (0.4)(1.082832) = 0.433133, \\
    k_2 &= f(t_2 + h, y_2 + hk_1) = (0.4 + 0.2)(1.082832 + 0.2(0.433133)) \\
    &= 0.701675, \\
    y_3 &= y_2 + \frac{h}{2}(k_1 + k_2) = 1.082832 + 0.1(0.433133 + 0.701675) \\
    &= 1.196313, \\ \\
    k_1 &= f(t_3, y_3) = (0.6)(1.196313) = 0.717788, \\
    k_2 &= f(t_3 + h, y_3 + hk_1) = (0.6 + 0.2)(1.196313 + 0.2(0.717788)) \\
    &= 1.071896, \\
    y_4 &= y_3 + \frac{h}{2}(k_1 + k_2) = 1.196313 + 0.1(0.717788 + 1.071896) \\
    &= 1.375281, \\ \\
    k_1 &= f(t_4, y_4) = (0.8)(1.375281) = 1.100225, \\
    k_2 &= f(t_4 + h, y_4 + hk_1) = (0.8 + 0.2)(1.375281 + 0.2(1.100225)) \\
    &= 1.595326, \\
    y_5 &= y_4 + \frac{h}{2}(k_1 + k_2) = 1.375281 + 0.1(1.100225 + 1.595326) \\
    &= 1.644836.
\end{align*}\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{1_IVPs/1.4_RK2:python-code}}\label{\detokenize{1_IVPs/1.4_RK2:rk2-python-code}}
\sphinxAtStartPar
The Python code below defines a function called \sphinxcode{\sphinxupquote{rk2()}} which computes the solution to an initial value problem using the RK2 method. The function is very similar to the function for the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:py-euler}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} with the exception the commands are added to the \sphinxcode{\sphinxupquote{for}} loop to calculate the stage values and update the solution.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{n}{k2}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The computed solutions to the initial value problem from {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 1.3}}}} using the Euler and RK2 methods and the exact solutions are plotted in \hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-example-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.4_RK2:rk2-example-figure}}} below. Note that the RK2 method is significantly more accurate than the Euler method.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.4_RK2_5_2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The solutions to the IVP \(y'=ty\), \(t\in[0,1]\), \(y(0)=1\) using the Euler and RK2 methods with \(h=0.2\).}\label{\detokenize{1_IVPs/1.4_RK2:rk2-example-figure}}\end{figure}


\subsection{Analysing the accuracy of the RK2 method}
\label{\detokenize{1_IVPs/1.4_RK2:analysing-the-accuracy-of-the-rk2-method}}
\sphinxAtStartPar
In order to analyse the accuracy of the RK2 method it has been applied to solve the initial value problem from the {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-example}]{\emph{example}}} above using a range of values of the step length starting at \(0.2\) and progressively halving it each time until \(h=0.025\). The global truncation errors have been calculated for the solution at \(t=1\) and plotted against \(h\) in \hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-gte-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.4_RK2:rk2-gte-figure}}} below. The errors tend to zero as the step lengths decrease in a \sphinxstylestrong{quadratic} manner as expected of a second order method.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.4_RK2_7_2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The global truncation errors for the RK2 method solution of  \(y' = t y\), \(t\in [0, 1]\) and \(y(0)=1\) at \(t=1\).}\label{\detokenize{1_IVPs/1.4_RK2:rk2-gte-figure}}\end{figure}

\sphinxAtStartPar
The Euler and RK2 methods have been used to solve the initial value problem from the {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-example}]{\emph{example}}} and the global truncation errors for the solution at \(t=1\) are tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(h\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Euler
&\sphinxstyletheadfamily 
\sphinxAtStartPar
RK2
\\
\hline
\sphinxAtStartPar
0.200
&
\sphinxAtStartPar
1.89e\sphinxhyphen{}01
&
\sphinxAtStartPar
3.88e\sphinxhyphen{}03
\\
\hline
\sphinxAtStartPar
0.100
&
\sphinxAtStartPar
1.02e\sphinxhyphen{}01
&
\sphinxAtStartPar
8.40e\sphinxhyphen{}04
\\
\hline
\sphinxAtStartPar
0.050
&
\sphinxAtStartPar
5.28e\sphinxhyphen{}02
&
\sphinxAtStartPar
1.92e\sphinxhyphen{}04
\\
\hline
\sphinxAtStartPar
0.025
&
\sphinxAtStartPar
2.69e\sphinxhyphen{}02
&
\sphinxAtStartPar
4.55e\sphinxhyphen{}05
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
We can see that the RK2 method has significantly smaller global truncation errors than the Euler method. A graphical comparison is shown in \hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-euler-gte-plot-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.4_RK2:rk2-euler-gte-plot-figure}}}, however, on this scale is is difficult to see the convergence behaviour of the RK2 method.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.4_RK2_7_4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The global truncation errors for the RK2 method and the Euler method solutions to the IVP \(y'=ty\), \(t\in[0,1]\), \(y(0) = 1\) at \(t = 1\).}\label{\detokenize{1_IVPs/1.4_RK2:rk2-euler-gte-plot-figure}}\end{figure}

\sphinxAtStartPar
We know that the value of the global truncation error of an \(n\)th order method as \(h \to 0\) should approximate the function \(e(h) = h^n\). Using logarithms we can write this as
\begin{equation*}
\begin{split}\log(e(h)) = n \log(h).\end{split}
\end{equation*}
\sphinxAtStartPar
This is a linear equation where the slope of \(\log(e(h))\) has a gradient of \(n\). Therefore we can approximate the order of a method using
\begin{equation}\label{equation:1_IVPs/1.4_RK2:order-approximation-equation}
\begin{split}n \approx \frac{\log(e(h_1)) - \log(e(h_2))}{\log(h_1) - \log(h_2)}\end{split}
\end{equation}
\sphinxAtStartPar
where \(h_1 > h_2\) are different step lengths. The global truncation errors for the Euler method and the RK2 method have been plotted on a \sphinxhref{https://en.wikipedia.org/wiki/Log\%E2\%80\%93log\_plot}{loglog} scale in \hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-euler-gte-loglog-plot-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.4_RK2:rk2-euler-gte-loglog-plot-figure}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.4_RK2_7_6}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{A loglog plot of the global truncation errors for the Euler and RK2 method solutions of \(y' = t y\), \(y(0) = 1\) at \(t = 1\).}\label{\detokenize{1_IVPs/1.4_RK2:rk2-euler-gte-loglog-plot-figure}}\end{figure}

\sphinxAtStartPar
If we calculate the gradients of \(\log(e)\) for the Euler and RK2 methods using equation \eqref{equation:1_IVPs/1.4_RK2:order-approximation-equation} we have
\begin{align*}
    &\mathsf{Euler\, method}: & n &\approx \frac{\log(0.189460) - \log(0.026921)}{\log(0.2) - \log(0.025)} = 0.94, \\
    &\mathsf{RK2\, method}: & n & \approx \frac{\log(0.003885) - \log(0.000045)}{\log(0.2) - \log(0.025)} = 2.14,
\end{align*}
\sphinxAtStartPar
which are approximations of \(n\) for a first and second\sphinxhyphen{}order method as expected.

\sphinxstepscope


\section{Higher\sphinxhyphen{}order Ordinary Differential Equations}
\label{\detokenize{1_IVPs/1.5_Higher_Order_ODEs:higher-order-ordinary-differential-equations}}\label{\detokenize{1_IVPs/1.5_Higher_Order_ODEs:higher-order-odes-section}}\label{\detokenize{1_IVPs/1.5_Higher_Order_ODEs::doc}}
\sphinxAtStartPar
The numerical methods that we have looked at are applied to calculate the solutions to ODEs can only be applied to first\sphinxhyphen{}order ODEs. To apply them to higher\sphinxhyphen{}order ODEs we first need to rewrite them as a system of first\sphinxhyphen{}order ODEs. Consider the \(n\)th\sphinxhyphen{}order ODE
\begin{equation*}
\begin{split} y^{(n)} = f(t, y, y', y'' ,\ldots ,y^{(n-1)}). \end{split}
\end{equation*}
\sphinxAtStartPar
If we let \(y_1=y\), \(y_2 =y'\), \(y_3 =y''\) and so on up to \(y_n =y^{(n-1)}\) then we have
\begin{align*}
    y_1' &= y_2,\\
    y_2' &= y_3,\\
    &\vdots \\
    y_n' &= f(t, y_1 , y_2 , y_3 , \ldots, y_n).
\end{align*}
\sphinxAtStartPar
Now we have a system of \(n\) first\sphinxhyphen{}order ODEs so we can apply our numerical methods for solving ODEs to each equation in the system to give an equivalent solution to the \(n\)th order ODE.

\begin{sphinxadmonition}{note}{Example 7.4}

\sphinxAtStartPar
Rewrite the following ODE as a system of first\sphinxhyphen{}order ODEs
\begin{align*}
    y''' + yy'' -2y' + ty'' - 10 = 0.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
First rearrange the ODE so that the highest derivative is the subject
\begin{align*}
    y''' = -yy'' + 2y' - ty'' + 10,
\end{align*}
\sphinxAtStartPar
then let \(y_1 = y\), \(y_2 = y'\), \(y_3 = y''\) then we can rewrite this ODE as
\begin{align*}
    y_1' &= y_2, \\
    y_2' &= y_3, \\
    y_3' &= - y_1 y_3 + 2y_2 - t y_3 + 10. 
\end{align*}\end{sphinxadmonition}


\subsection{Solving systems of ordinary differential equations}
\label{\detokenize{1_IVPs/1.5_Higher_Order_ODEs:solving-systems-of-ordinary-differential-equations}}\label{\detokenize{1_IVPs/1.5_Higher_Order_ODEs:solving-systems-of-odes-section}}
\sphinxAtStartPar
Consider a system of \(n\) first\sphinxhyphen{}order ODEs written in the form
\begin{align*}
    y_1' &= f_1(t, y_1), \\
    y_2' &= f_2(t, y_2), \\
    & \vdots \\
    y_n' &= f_n(t, y_n).
\end{align*}
\sphinxAtStartPar
Let \(\mathbf{y}\) and \(\mathbf{f}(t_n, \mathbf{y})\) be vectors such that
\begin{align*}
    \mathbf{y} &= \begin{pmatrix} y_1 \\ y_2 \\ \vdots \\ y_n \end{pmatrix}, &
    \mathbf{f}(t, \mathbf{y}) &= 
    \begin{pmatrix} f_1(t, y_1) \\ f_2(t, y_2) \\ \vdots \\ f_n(t, y_n) \end{pmatrix},
\end{align*}
\sphinxAtStartPar
then we can write the system in vector form
\begin{align*}
    \mathbf{y}' = \mathbf{f}(t, \mathbf{y}).
\end{align*}
\sphinxAtStartPar
The Euler method for solving a system of first\sphinxhyphen{}order ODEs is
\begin{align*}
    \mathbf{y}_{n+1} &= \mathbf{y}_n + h \mathbf{f}(t_n, \mathbf{y}_n).
\end{align*}
\sphinxAtStartPar
Initial value problems that are defined using systems of ODEs we need to know the initial solution for each of the individual ODEs, i.e., \(y_1(a), y_2(a), \ldots\), in order to be able to obtain a unique solution.

\begin{sphinxadmonition}{note}{Example 7.5}

\sphinxAtStartPar
Calculate solution to the following initial value problem using the Euler method with \(h=0.2\)
\begin{align*}
    y'' + y = 0, \qquad t \in [0,10], \qquad y(0) = 2, \qquad y'(0) = 0
\end{align*}
\sphinxAtStartPar
and compare the computed solution to the exact solution which is \(y = 2\cos(t)\).
\subsubsection*{Solution}

\sphinxAtStartPar
First we need to rewrite the second\sphinxhyphen{}order ODE as two first\sphinxhyphen{}order ODEs. Let \(y_1 = y\) and \(y_2 = y'\) then
\begin{align*}
    y_1' &= y_2, & y_1(0) &= 2,\\
    y_2' &= -y_1, & y_2(0) &= 0,
\end{align*}
\sphinxAtStartPar
so
\begin{align*}
    \mathbf{y} &= \begin{pmatrix} y_1 \\ y_2 \end{pmatrix}, &
    \mathbf{f}(t, \mathbf{y}) &= \begin{pmatrix} y_2 \\ -y_1 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Calculating the first few steps of the {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}}
\begin{align*}
    \mathbf{y}_1 &= \mathbf{y}_0 + h \mathbf{f}(t_0, \mathbf{y}_0) 
    = \begin{pmatrix} 2 \\ 0 \end{pmatrix} + 0.2 \begin{pmatrix} 0 \\ -2 \end{pmatrix}
    = \begin{pmatrix} 2 \\ -0.4 \end{pmatrix}, \\
    \mathbf{y}_2 &= \mathbf{y}_1 + h \mathbf{f}(t_1, \mathbf{y}_1) 
    = \begin{pmatrix} 2 \\ -0.4 \end{pmatrix} + 0.2\begin{pmatrix} -0.4 \\ -2 \end{pmatrix}
    = \begin{pmatrix} 1.92 \\ -0.8 \end{pmatrix},\\
    \mathbf{y}_3 &= \mathbf{y}_2 + h \mathbf{f}(t_2, \mathbf{y}_2)
    = \begin{pmatrix} 1.92 \\ -0.8 \end{pmatrix} + 0.2 \begin{pmatrix} 1.92 \\ -0.8 \end{pmatrix}
    = \begin{pmatrix} 1.76 \\ -1.184 \end{pmatrix}, \\
    &\vdots
\end{align*}
\sphinxAtStartPar
The exact solution to this IVP is \(y(t) = 2 \cos(t)\). The Euler method solution has been calculated over the whole domain and a selection of the domain is tabulated below. Note that the solution \(y(t)\) is contained in the \(y_1\) column and the \(y_2\) column is the first derivative \(y'(t)\).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t_n\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_2\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Error
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
2.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
2.000000
&
\sphinxAtStartPar
0.00e+00
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
2.000000
&
\sphinxAtStartPar
\sphinxhyphen{}0.400000
&
\sphinxAtStartPar
1.960133
&
\sphinxAtStartPar
3.99e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
1.920000
&
\sphinxAtStartPar
\sphinxhyphen{}0.800000
&
\sphinxAtStartPar
1.842122
&
\sphinxAtStartPar
7.79e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
1.760000
&
\sphinxAtStartPar
\sphinxhyphen{}1.184000
&
\sphinxAtStartPar
1.650671
&
\sphinxAtStartPar
1.09e\sphinxhyphen{}01
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.523200
&
\sphinxAtStartPar
\sphinxhyphen{}1.536000
&
\sphinxAtStartPar
1.393413
&
\sphinxAtStartPar
1.30e\sphinxhyphen{}01
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
1.216000
&
\sphinxAtStartPar
\sphinxhyphen{}1.840640
&
\sphinxAtStartPar
1.080605
&
\sphinxAtStartPar
1.35e\sphinxhyphen{}01
\\
\hline
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
\\
\hline
\sphinxAtStartPar
10.00
&
\sphinxAtStartPar
\sphinxhyphen{}4.812425
&
\sphinxAtStartPar
2.295061
&
\sphinxAtStartPar
\sphinxhyphen{}1.678143
&
\sphinxAtStartPar
3.13e+00
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The solution using the Euler and RK2 methods is plotted below. The Euler method solution is very inaccurate since it is a first\sphinxhyphen{}order method.

\begin{figure}[H]
\centering
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{1.5_Higher_Order_ODEs_1_2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\end{figure}
\end{sphinxadmonition}

\sphinxstepscope


\section{Initial Value Problems Chapter Summary}
\label{\detokenize{1_IVPs/1.6_IVP_Summary:initial-value-problems-chapter-summary}}\label{\detokenize{1_IVPs/1.6_IVP_Summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
An {\hyperref[\detokenize{1_IVPs/1.0_IVPs:ivp-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Initial Value Problem (IVP)}}}} is expressed as an ODE where the solution at the lower bound of the domain is known.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} is derived by truncating the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}} after the first\sphinxhyphen{}order term. It advances the solution over a small step of length \(h\) using known values of \(t_n\) and \(y_n\) to calculate the solution at \(y_{n+1} =y(t_n +h)\).

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:lte-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Local Truncation Error}}}} is the error accrued by a method over a single step assuming the solution at the start of the step is known to be exact.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:gte-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Global Truncation Error}}}} is the error accrued over all previous steps of a method assuming the initial solution is known to be exact.

\item {} 
\sphinxAtStartPar
The global truncation error for an \(n\)th order method is \(O(h^{n})\) which means as \(h\) tends to zero, the error will tend to zero at least as fast as \(h^n\).

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} is first\sphinxhyphen{}order accurate so the solutions tend to be inaccurate unless using a very small value of the step length \(h\).

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta (RK2) method}}}} uses two intermediate stage values that are then used to calculate the solution over the full step.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{1_IVPs/1.5_Higher_Order_ODEs:higher-order-odes-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Higher\sphinxhyphen{}order ODEs}}}} can be rewritten as a system of first\sphinxhyphen{}order ODEs which can be solved using numerical solution methods.

\end{itemize}

\sphinxstepscope


\section{Initial Value Problems Exercises}
\label{\detokenize{1_IVPs/1.7_Exercises:initial-value-problems-exercises}}\label{\detokenize{1_IVPs/1.7_Exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 1.1}

\sphinxAtStartPar
Using pen and a calculator solve the following IVP using the Euler method with a step length of \(h=0.4\). Write down your solutions correct to 4 decimal places.
\begin{align*}
    y' =t + y, \qquad t\in [0,2],\qquad y(0)=2.
\end{align*}\subsubsection*{Solution (click to show)}
\begin{align*}
    \mathbf{t} &= (0, 0.4, 0.8, 1.2, 1.6, 2), \\
    \\
    y_0 &= 2, \\
    y_1 &= y_0 + h(t_0 + y_0) = 2 + 0.4(0 + 2) = 2.8, \\
    y_2 &= y_1 + h(t_1 + y_1) = 2.8 + 0.4(0.4 + 2.8) = 4.08, \\
    y_3 &= y_2 + h(t_2 + y_2) = 4.08 + 0.4(0.8 + 4.08) = 6.032, \\
    y_4 &= y_3 + h(t_3 + y_3) = 6.032 + 0.4(1.2 + 6.032) = 8.9248, \\
    y_5 &= y_4 + h(t_4 + y_4) = 8.9248 + 0.4(1.6 + 8.9248) = 13.1347.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 1.2}

\sphinxAtStartPar
Repeat {\hyperref[\detokenize{1_IVPs/1.7_Exercises:ex1-1}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 1.1}}}} using the RK2 method.
\subsubsection*{Solution}
\begin{align*}
    k_1 &= f(t_0, y_0) = (0.0) + (2.000000) = 2.000000, \\
    k_2 &= f(t_0 + h, y_0 + hk_1) = (0.0 + 0.4) + (2.000000 + 0.4(2.000000)) \\
    &= 3.200000, \\
    y_1 &= y_0 + \frac{h}{2}(k_1 + k_2) = 2.000000 + 0.2(2.000000 + 3.200000) \\
    &= 3.040000, \\ \\
    k_1 &= f(t_1, y_1) = (0.4) + (3.040000) = 3.040000, \\
    k_2 &= f(t_1 + h, y_1 + hk_1) = (0.4 + 0.4) + (3.040000 + 0.4(3.440000)) \\
    &= 5.216000, \\
    y_2 &= y_1 + \frac{h}{2}(k_1 + k_2) = 3.040000 + 0.2(3.440000 + 5.216000) \\
    &= 4.771200, \\ \\
    k_1 &= f(t_2, y_2) = (0.8) + (4.771200) = 4.771200, \\
    k_2 &= f(t_2 + h, y_2 + hk_1) = (0.8 + 0.4) + (4.771200 + 0.4(5.571200)) \\
    &= 8.199680, \\
    y_3 &= y_2 + \frac{h}{2}(k_1 + k_2) = 4.771200 + 0.2(5.571200 + 8.199680) \\
    &= 7.525376, \\ \\
    k_1 &= f(t_3, y_3) = (1.2) + (7.525376) = 7.525376, \\
    k_2 &= f(t_3 + h, y_3 + hk_1) = (1.2 + 0.4) + (7.525376 + 0.4(8.725376)) \\
    &= 12.615526, \\
    y_4 &= y_3 + \frac{h}{2}(k_1 + k_2) = 7.525376 + 0.2(8.725376 + 12.615526) \\
    &= 11.793556, \\ \\
    k_1 &= f(t_4, y_4) = (1.6) + (11.793556) = 11.793556, \\
    k_2 &= f(t_4 + h, y_4 + hk_1) = (1.6 + 0.4) + (11.793556 + 0.4(13.393556)) \\
    &= 19.150979, \\
    y_5 &= y_4 + \frac{h}{2}(k_1 + k_2) = 11.793556 + 0.2(13.393556 + 19.150979) \\
    &= 18.302464.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 1.3}

\sphinxAtStartPar
Write a Python program to calculate the solutions to {\hyperref[\detokenize{1_IVPs/1.7_Exercises:ex1-1}]{\sphinxcrossref{\DUrole{std,std-ref}{exercises 1.1}}}} and {\hyperref[\detokenize{1_IVPs/1.7_Exercises:ex1-2}]{\sphinxcrossref{\DUrole{std,std-ref}{1.2}}}}.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 


\PYG{k}{def} \PYG{n+nf}{rk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{n}{k2}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{+} \PYG{n}{y}


\PYG{c+c1}{\PYGZsh{} Define IVP}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Calculate the solution to the IVP}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}euler} \PYG{o}{=} \PYG{n}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}rk2} \PYG{o}{=} \PYG{n}{rk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Output table of solutions}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|   t   |   Euler   |    RK2    |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{5.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y\PYGZus{}euler}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y\PYGZus{}rk2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{|}   \PYG{n}{t}   \PYG{o}{|}   \PYG{n}{Euler}   \PYG{o}{|}    \PYG{n}{RK2}    \PYG{o}{|}
\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}
\PYG{o}{|}  \PYG{l+m+mf}{0.00} \PYG{o}{|}  \PYG{l+m+mf}{2.000000} \PYG{o}{|}  \PYG{l+m+mf}{2.000000} \PYG{o}{|}
\PYG{o}{|}  \PYG{l+m+mf}{0.40} \PYG{o}{|}  \PYG{l+m+mf}{2.800000} \PYG{o}{|}  \PYG{l+m+mf}{3.040000} \PYG{o}{|}
\PYG{o}{|}  \PYG{l+m+mf}{0.80} \PYG{o}{|}  \PYG{l+m+mf}{4.080000} \PYG{o}{|}  \PYG{l+m+mf}{4.771200} \PYG{o}{|}
\PYG{o}{|}  \PYG{l+m+mf}{1.20} \PYG{o}{|}  \PYG{l+m+mf}{6.032000} \PYG{o}{|}  \PYG{l+m+mf}{7.525376} \PYG{o}{|}
\PYG{o}{|}  \PYG{l+m+mf}{1.60} \PYG{o}{|}  \PYG{l+m+mf}{8.924800} \PYG{o}{|} \PYG{l+m+mf}{11.793556} \PYG{o}{|}
\PYG{o}{|}  \PYG{l+m+mf}{2.00} \PYG{o}{|} \PYG{l+m+mf}{13.134720} \PYG{o}{|} \PYG{l+m+mf}{18.302464} \PYG{o}{|}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 1.4}

\sphinxAtStartPar
The exact solution to the IVP in {\hyperref[\detokenize{1_IVPs/1.7_Exercises:ex1-1}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 1.1}}}} is \(y=3e^t - t - 1\). Produce a plot of the Euler solution, the Runge\sphinxhyphen{}Kutta solution and the exact solution on the same set of axes.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}


\PYG{c+c1}{\PYGZsh{} Plot solution}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}euler}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Euler}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}rk2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ro\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RK2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 1.5}

\sphinxAtStartPar
The motion of a pendulum can be modelled by the following ODE
\begin{align*}
    \theta'' + \frac{g}{L} \sin(\theta) = 0,
\end{align*}
\sphinxAtStartPar
where \(\theta\) is the angle between the pendulum and the vertical, \(L\) is the length of the pendulum and \(g=9.81\) ms\(^{-2}\) is the acceleration due to gravity.

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{pendulum}.png}
\end{figure}

\sphinxAtStartPar
Write a Python program that uses the RK2 method with \(h=0.1\) to calculate the solution for \(\theta\) over the interval \(t\in [0, 5]\) for a pendulum of length \(L = 1\) set at an initial angle \(\theta = \frac{\pi}{2}\). Produce a plot of the displacement angle \(\theta\) against \(t\).
\subsubsection*{Solution}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}


\PYG{k}{def} \PYG{n+nf}{rk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{n}{k2}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{+} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}


\PYG{c+c1}{\PYGZsh{} Define IVP}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Calculate the solution to the IVP}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}euler} \PYG{o}{=} \PYG{n}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}rk2} \PYG{o}{=} \PYG{n}{rk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Output table of solutions}
\PYG{n}{yexact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|   t   |   Euler   |    RK2    |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{5.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y\PYGZus{}euler}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y\PYGZus{}rk2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Plot solution}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}euler}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Euler}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}rk2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ro\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RK2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Explicit Runge\sphinxhyphen{}Kutta Methods}
\label{\detokenize{2_ERKs/2.0_ERKs:explicit-runge-kutta-methods}}\label{\detokenize{2_ERKs/2.0_ERKs:erk-chapter}}\label{\detokenize{2_ERKs/2.0_ERKs::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning Outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
identify a {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Runge\sphinxhyphen{}Kutta method}}}} and express it using a {\hyperref[\detokenize{2_ERKs/2.0_ERKs:butcher-tableau-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher tableau}}}};

\item {} 
\sphinxAtStartPar
distinguish between {\hyperref[\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-rk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{explicit and implicit}}}} Runge\sphinxhyphen{}Kutta methods;

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-section}]{\sphinxcrossref{\DUrole{std,std-ref}{derive}}}} an explicit Runge\sphinxhyphen{}Kutta method;

\item {} 
\sphinxAtStartPar
apply {\hyperref[\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:applying-erk-methods-to-solve-ivps-section}]{\sphinxcrossref{\DUrole{std,std-ref}{explicit Runge\sphinxhyphen{}Kutta methods to solve an initial value problem}}}}.

\end{itemize}


\bigskip\hrule\bigskip



\section{General form of a Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{2_ERKs/2.0_ERKs:general-form-of-a-runge-kutta-method}}\label{\detokenize{2_ERKs/2.0_ERKs:general-form-of-a-rk-method-section}}
\sphinxAtStartPar
Runge\sphinxhyphen{}Methods are the most popular family of methods used to solve Ordinary Differential Equations (ODEs). They are known as \sphinxstylestrong{single step methods} because they update the solution for the next step \(y_{n+1}\) using information from the single step \(y_n\). The other type of method for solving ODEs are \sphinxhref{https://en.wikipedia.org/wiki/Linear\_multistep\_method}{\sphinxstylestrong{linear multistep methods}} that calculate \(y_{n+1}\) using information from multiple steps \(y_n ,y_{n-1} ,y_{n-2} ,\ldots \)

\begin{sphinxadmonition}{note}{Definition: General form of a Runge\sphinxhyphen{}Kutta method}

\sphinxAtStartPar
The general form of a Runge\sphinxhyphen{}Kutta method for solving the initial value problem \(y' =f(t,y)\), \(t \in [a, b]\), \(y_0 = y(a)\) is
\begin{equation}\label{equation:2_ERKs/2.0_ERKs:rk-equation}
\begin{split}\begin{align}
    y_{n+1} &=y_n +h\sum_{i=1}^s b_i k_i,\\
    k_i &=f(t_n +c_i h,y_n +h\sum_{j=1}^s a_{ij} k_j ),
\end{align}\end{split}
\end{equation}
\sphinxAtStartPar
where
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(t_n\) is some value of the independent variable \(t\);

\item {} 
\sphinxAtStartPar
\(y_n=y(t_n)\) is the value of the function \(y\) at \(t=t_n\);

\item {} 
\sphinxAtStartPar
\(h=t_{n+1}-t_n\) is the \sphinxstylestrong{step length};

\item {} 
\sphinxAtStartPar
\(s\) is the number of \sphinxstylestrong{stages} of the method;

\item {} 
\sphinxAtStartPar
\(k_i\) are intermediate \sphinxstylestrong{stage values} used to calculate \(y_{n+1}\);

\item {} 
\sphinxAtStartPar
\(a_{ij}\), \(b_i\) and \(c_i\) are coefficients that defined a particular Runge\sphinxhyphen{}Kutta method.

\end{itemize}
\end{sphinxadmonition}


\subsection{Butcher tableau}
\label{\detokenize{2_ERKs/2.0_ERKs:butcher-tableau}}\label{\detokenize{2_ERKs/2.0_ERKs:butcher-tableau-section}}
\sphinxAtStartPar
Runge\sphinxhyphen{}Kutta methods are often summarised in a \sphinxstylestrong{Butcher tableau} named after the New Zealand mathematician \sphinxhref{https://en.wikipedia.org/wiki/John\_C.\_Butcher}{John Butcher}.

\begin{sphinxadmonition}{note}{Definition: Butcher Tableau}

\sphinxAtStartPar
A Butcher tableau is a table of values containing the coefficients \(a_{ij}\), \(b_i\) and \(c_i\) for a Runge\sphinxhyphen{}Kutta method
\begin{align*}
    \begin{array}{c|c}
        \mathbf{c} & A \\ \hline
        & \mathbf{b}^T
    \end{array}
\end{align*}
\sphinxAtStartPar
where \(A\) is a matrix of \(a_{ij}\) coefficients and \(\mathbf{b}\) and \(\mathbf{c}\) are column vectors containing the \(b_i\) and \(c_i\) coefficients
\begin{align*}
    A &= \begin{pmatrix}
        a_{11} & a_{12} & \cdots & a_{1s} \\
        a_{21} & a_{22} & \cdots & a_{2s} \\
        \vdots & \vdots & \ddots & \vdots \\
        a_{s1} & a_{2s} & \cdots & a_{ss}
    \end{pmatrix}, &
    \mathbf{b} &= \begin{pmatrix} b_1 \\ b_2 \\ \vdots \\ b_s \end{pmatrix}, &
    \mathbf{c} &= \begin{pmatrix} c_1 \\ c_2 \\ \vdots \\ c_s \end{pmatrix},
\end{align*}
\sphinxAtStartPar
i.e.,
\begin{align*}
    \begin{array}{c|cccc}
        c_1  & a_{11}  & a_{12}  & \cdots  & a_{1s} \\
        c_2  & a_{21}  & a_{22}  & \cdots  & a_{2s} \\
        \vdots  & \vdots  & \vdots  & \ddots  & \vdots \\
        c_s  & a_{s1}  & a_{s2}  & \cdots  & a_{ss} \\ \hline
        & b_1  & b_2  & \cdots  & b_s 
    \end{array}
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 2.1}

\sphinxAtStartPar
Express the second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method given below as a Butcher tableau
\begin{equation}\label{equation:2_ERKs/2.0_ERKs:butcher-tableau-example-equation-1}
\begin{split}\begin{align*}
    y_{n+1} &= y_n + \frac{h}{2}(k_1 + k_2), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f\left( t_n + h, y_n + hk_1 \right).
\end{align*}\end{split}
\end{equation}\subsubsection*{Solution}

\sphinxAtStartPar
The general form of a two\sphinxhyphen{}stage Runge\sphinxhyphen{}Kutta method is
\begin{equation}\label{equation:2_ERKs/2.0_ERKs:butcher-tableau-example-equation-2}
\begin{split}\begin{align*}
    y_{n+1} &= y_n + h(b_1 k_1 + b_2 k_2), \\
    k_1 &= f(t_n + c_1 h, y_n + h(a_{11}k_1 + a_{12}k_2)), \\
    k_2 &= f(t_n + c_2 h, y_n + h(a_{21}k_1 + a_{22}k_2)). 
\end{align*}\end{split}
\end{equation}
\sphinxAtStartPar
Comparing equations \eqref{equation:2_ERKs/2.0_ERKs:butcher-tableau-example-equation-1} and \eqref{equation:2_ERKs/2.0_ERKs:butcher-tableau-example-equation-2} we can see that \(a_{11} = a_{12} = a_{22} = 0\), \(b_1 = b_2 = 1\), \(c_1 = 0\) and \(c_2 = 1\) therefore the Butcher tableau for this method is
\begin{align*}
    \begin{array}{c|cc}
        0 & 0 & 0 \\
        1 & 1 & 0 \\ \hline
        & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}\end{sphinxadmonition}


\section{Explicit and implicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-runge-kutta-methods}}\label{\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-rk-methods-section}}
\sphinxAtStartPar
Expanding out the stage values from equation \eqref{equation:2_ERKs/2.0_ERKs:rk-equation} we see that the stage values of a general Runge\sphinxhyphen{}Kutta method are
\begin{align*}
    k_1 &=f(t_n +c_1 h,y_n +h(a_{11} k_1 +a_{12} k_2 +\cdots +a_{1s} k_s ),\\
    k_2 &=f(t_n +c_2 h,y_n +h(a_{21} k_1 +a_{22} k_2 +\cdots +a_{2s} k_s ),\\
    &\vdots \\
    k_s &=f(t_n +c_s h,y_n +h(a_{s1} k_1 +a_{s2} k_s +\cdots +a_{ss} k_s ).
\end{align*}
\sphinxAtStartPar
The first equation where we are calculating \(k_1\) includes \(k_1\) on the right\sphinxhyphen{}hand side and in the second equation where we are calculating \(k_2\) includes \(k_2\) on the right\sphinxhyphen{}hand side and so on. These are examples of \sphinxhref{https://en.wikipedia.org/wiki/Implicit\_function}{\sphinxstylestrong{implicit functions}} and Runge\sphinxhyphen{}Kutta methods where the stage values are expressed using implicit functions are known as \sphinxstylestrong{Implicit Runge\sphinxhyphen{}Kutta (IRK)} methods. To calculate the solution of the stage values of an IRK method involves solving a system of equations ({\hyperref[\detokenize{3_IRKs/3.0_IRKs:irk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{see Implicit Runge\sphinxhyphen{}Kutta Methods}}}}).

\sphinxAtStartPar
If the summation in the stage value \(k_i\) in equation \eqref{equation:2_ERKs/2.0_ERKs:rk-equation} is altered so the upper limit to the sum is \(i-1\), i.e.,
\begin{align*}
    k_i = f(t_n + c_1 h,y_n + h\sum_{j=1}^{i-1} a_{ij} k_j)
\end{align*}
\sphinxAtStartPar
and let \(c_1 = 0\) then we have the following equations for calculating the stage values
\begin{align*}
    k_1 &=f(t_n ,y_n),\\
    k_2 &=f(t_n +c_2 h,y_n +ha_{21} k_1 ),\\
    k_3 &=f(t_n +c_3 h,y_n +h(a_{31} k_1 +a_{32} k_2 )),\\
    &\vdots \\
    k_s &=f(t_n +c_s h,y_n +h(a_{s1} k_1 +a_{s2} k_s +\cdots +a_{s,s-1} k_{s-1} )).
\end{align*}
\sphinxAtStartPar
These stage values are \sphinxstylestrong{explicit functions} where the subject of the equation does not appear on the right\sphinxhyphen{}hand side. Runge\sphinxhyphen{}Kutta methods where the stages values are calculated using explicit functions are known as \sphinxstylestrong{Explicit Runge Kutta (ERK)} methods. These are easier to compute than implicit Runge\sphinxhyphen{}Kutta methods because the stage values can be calculated sequentially in order, i.e., \(k_1\) can be calculated using \(t_n\) and \(y_n\) and then used to calculate \(k_2\) and so on. However for some ODEs explicit methods require a very small value for the step length and and we must then use implicit methods (see the chapter on {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{Stability)}}}} for more detail).


\subsection{Butcher tableau for explicit and implicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{2_ERKs/2.0_ERKs:butcher-tableau-for-explicit-and-implicit-runge-kutta-methods}}
\sphinxAtStartPar
Explicit and implicit Runge\sphinxhyphen{}Kutta methods can be easily distinguished by looking at their Butcher tableaux. The \(A\) matrix in the top right region of a Butcher tableau for an explicit method is lower\sphinxhyphen{}triangular whereas for an implicit method the main\sphinxhyphen{}diagonal and upper triangular elements are non\sphinxhyphen{}zero.

\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-g-3}
\begin{sphinxuseclass}{sd-g-xs-3}
\begin{sphinxuseclass}{sd-g-sm-3}
\begin{sphinxuseclass}{sd-g-md-3}
\begin{sphinxuseclass}{sd-g-lg-3}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Explicit Runge\sphinxhyphen{}Kutta method
\end{sphinxuseclass}
\end{sphinxuseclass}\begin{align*}
    \begin{array}{c|ccccc}
        0 &  &  &  &  & \\
        c_2  & a_{21}  &  &  &  & \\
        c_3  & a_{31}  & a_{32}  &  &  & \\
        \vdots  & \vdots  & \vdots  & \ddots  &  & \\
        c_s  & a_{s1}  & a_{s2}  & \cdots  & a_{s,s-1}  & \\ \hline
        & b_1  & b_2  & \cdots  & b_{s-1}  & b_s 
    \end{array}
\end{align*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Implicit Runge\sphinxhyphen{}Kutta method
\end{sphinxuseclass}
\end{sphinxuseclass}\begin{align*}
    \begin{array}{c|ccccc}
        c_1  & a_{11}  & a_{12}  & a_{13}  & \cdots  & a_{1s} \\
        c_2  & a_{21}  & a_{22}  & a_{23}  & \cdots  & a_{2s} \\
        c_3  & a_{31}  & a_{32}  & a_{33}  & \cdots  & a_{3s} \\
        \vdots  & \vdots  & \vdots  & \vdots  & \ddots  & \vdots \\
        c_s  & a_{s1}  & a_{s2}  & a_{s3}  & \cdots  & a_{ss} \\ \hline
         & b_1  & b_2  & b_3  & \cdots  & b_s 
    \end{array}
\end{align*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\section{Derivation of Explicit Runge\sphinxhyphen{}Kutta Methods}
\label{\detokenize{2_ERKs/2.1_ERK_Derivation:derivation-of-explicit-runge-kutta-methods}}\label{\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-section}}\label{\detokenize{2_ERKs/2.1_ERK_Derivation::doc}}
\sphinxAtStartPar
The derivation of explicit Runge\sphinxhyphen{}Kutta methods is achieved by comparing the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}}  for the ODE \(y'=f(t,y)\) to that of the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{general Runge\sphinxhyphen{}Kutta method}}}} and ensuring the coefficients \(a_{ij}\), \(b_i\) and \(c_i\) match.

\sphinxAtStartPar
For example, consider the second\sphinxhyphen{}order Taylor series expansion of \(y_{n+1}\)
\begin{align*}
    y_{n+1} = y_n + h y_n' + \frac{h^2}{2} y_n'' + O(h^3).
\end{align*}
\sphinxAtStartPar
We wish to solve the ODE \(y' = f(t,y)\), applying the chain rule to differentiate \(y\) we have%
\begin{footnote}[1]\sphinxAtStartFootnote
Here we are using subscript notation where \(f_y(t, y) = \frac{\partial f}{\partial y}(t ,y)\) and similar for \(f_t(t, y)\).
%
\end{footnote}
\begin{align*}
    y''(t, y) = f'(t, y) = f_t(t, y) + f_y(t, y) y'(t, y) = f_t(t, y) + f(t, y) f_y(t, y),
\end{align*}
\sphinxAtStartPar
then the Taylor series becomes
\begin{equation}\label{equation:2_ERKs/2.1_ERK_Derivation:ode-taylor-equation}
\begin{split}\begin{align*}
    y_{n+1} &= y_n + h f(t_n, y_n) + \frac{h^2}{2}(f_t(t_n, y_n) + f(t_n, y_n) f_y(t_n, y_n)) + O(h^3)
\end{align*}\end{split}
\end{equation}
\sphinxAtStartPar
This is the second\sphinxhyphen{}order Taylor series expansion for the ODE \(y' = f(t,y)\). To be able to solve this ODE we need the Taylor series expansion of a Runge\sphinxhyphen{}Kutta method to be equivalent to equation \eqref{equation:2_ERKs/2.1_ERK_Derivation:ode-taylor-equation}. Recall that the general form of a second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method is
\begin{equation}\label{equation:2_ERKs/2.1_ERK_Derivation:general-rk2-equation}
\begin{split}y_{n+1} = y_n + h(b_1 k_1 + b_2 k_2),\end{split}
\end{equation}
\sphinxAtStartPar
with the stage values
\begin{align*}
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + c_2 h, y_n + h a_{21} k_1)
\end{align*}
\sphinxAtStartPar
We can use the first\sphinxhyphen{}order expansion of the bivariate Taylor series
\begin{align*}
    f(t + p, y + q) = f(t, y) + p f_t(t, y) + q f_y(t, y),
\end{align*}
\sphinxAtStartPar
to rewrite the \(k_2\) term as
\begin{align*}
    k_2 &= f(t_n, y_n) + c_2 h f_t(t_n, y_n) + h a_{21} f(t_n, y_n) f_y(t_n, y_n).
\end{align*}
\sphinxAtStartPar
Substituting \(k_1\) and \(k_2\) into equation \eqref{equation:2_ERKs/2.1_ERK_Derivation:general-rk2-equation} gives
\begin{equation}\label{equation:2_ERKs/2.1_ERK_Derivation:bivariate-rk2-equation}
\begin{split}\begin{align*}
y_{n+1} &= y_n + h (b_1 f(t_n, y_n) \\
& \qquad + b_2 (f(t_n, y_n) + c_2 h f_t(t_n, y_n) + h a_{21} f(t_n, y_n) f_y(t_n, y_n))) + O(h^3).
\end{align*}\end{split}
\end{equation}
\sphinxAtStartPar
We need equation \eqref{equation:2_ERKs/2.1_ERK_Derivation:bivariate-rk2-equation} to be equal to \eqref{equation:2_ERKs/2.1_ERK_Derivation:ode-taylor-equation}. Equating the coefficients of \(f(t_n, y_n)\) we have
\begin{align*}
    h b_1 + h b_2 &= h \\
    \therefore b_1 + b_2 &= 1.
\end{align*}
\sphinxAtStartPar
Equating the coefficients of \(f_t(t_n, y_n)\) we have
\begin{align*}
    h^2 b_2 c_2 &= \frac{h^2}{2}\\
    \therefore b_2c_2 &= \frac{1}{2},
\end{align*}
\sphinxAtStartPar
and equating the coefficients of \(f(t_n, y_n) f_y(t_n, y_n)\) we have
\begin{align*}
    h^2 b_2 a_{21} &= \frac{h^2}{2} \\
    \therefore a_{21}b_2 &= \frac{1}{2}.
\end{align*}
\sphinxAtStartPar
So we have three equations and four unknowns (\(a_{21}\), \(b_1\), \(b_2\), \(c_2\)). Any set of values that satisfy these this system of equations give a valid second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method. These conditions are known as the \sphinxstylestrong{order conditions} for a method. Since we have an underdetermined system to get a unique solution we choose a value for one of the unknowns and solve for the others.

\begin{sphinxadmonition}{note}{Definition: Order conditions for a second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}
\begin{equation}\label{equation:2_ERKs/2.1_ERK_Derivation:rk2-order-conditions-equation}
\begin{split}\begin{align*}
    b_1 +b_2 &=1,\\
    c_2 b_2 &=\frac{1}{2},\\
    a_{21} b_2 &=\frac{1}{2}
\end{align*}\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 2.2}

\sphinxAtStartPar
Derive a second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method where \(c_2 = 1\).
\subsubsection*{Solution}

\sphinxAtStartPar
Substituting \(c_2 = 1\) into equation \eqref{equation:2_ERKs/2.1_ERK_Derivation:rk2-order-conditions-equation} the second order condition gives \(b_2 = \frac{1}{2}\) so from the first order condition we know that \(b_1 = \frac{1}{2}\) and from the third order condition we know that \(a_{21} = 1\). So this second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method is
\begin{align*}
    y_{n+1} &=y_n +\frac{h}{2}(k_1 +k_2 ),\\
    k_1 &=f(t_n ,y_n ),\\
    k_2 &=f(t_n +h,y_n +hk_1 ),
\end{align*}
\sphinxAtStartPar
or expressed using a Butcher tableau
\begin{align*}
    \begin{array}{c|cc}
    0 & & \\
    1 & 1 & \\ \hline
    & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}
\sphinxAtStartPar
This version of a second order Runge\sphinxhyphen{}Kutta method uses the simplest values for \(a_{ij}\), \(b_i\) and \(c_i\) and is known as \sphinxstylestrong{the second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method (RK2)}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
There are an infinite number of combinations for the values of \(a_{ij}\), \(b_i\) and \(c_i\) which satisfy the order conditions for a Runge\sphinxhyphen{}Kutta method. All of the possible Runge\sphinxhyphen{}Kutta methods of a particular order will the same solutions (computational rounding permitted).
\end{sphinxadmonition}


\subsection{Using Python to solve the order conditions}
\label{\detokenize{2_ERKs/2.1_ERK_Derivation:using-python-to-solve-the-order-conditions}}
\sphinxAtStartPar
The algebra used to solve the order conditions in {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-example}]{\emph{example 2.2}}} above is quite easy to perform but for higher order methods it can soon get more complicated (see the {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk4-derivation-example}]{\emph{derivation of a fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}}} for an example) and it is therefore useful to use software to help with the algebra. There is a Python library called \sphinxhref{https://www.sympy.org/en/index.html}{\sphinxstylestrong{SymPy}} (short for \sphinxstyleemphasis{symbolic Python}) that has functions that can solve algebraic equations.

\sphinxAtStartPar
The code below derives the second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method from {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-example}]{\emph{example 2.2}}} using SymPy. After importing SymPy we need to declare each of the coefficients \(a_{21}\), \(b_1\), \(b_2\) and \(c_2\) as \sphinxstylestrong{symbolic variables} using the \sphinxcode{\sphinxupquote{sp.symbols}} command before setting \(c_2=1\). Each order condition is then defined using these symbolic variables. Note that SymPy assumes that equations are equal to zero which is why we have subtracted the right\sphinxhyphen{}hand side. We have also used the \sphinxcode{\sphinxupquote{sp.Rational(1,2)}} command for the fraction \(\frac{1}{2}\) so that SymPy will output any fractional values as fractions rather than decimals. The system of three equations \sphinxcode{\sphinxupquote{eq1}}, \sphinxcode{\sphinxupquote{eq2}} and \sphinxcode{\sphinxupquote{eq3}} is then solved using the \sphinxcode{\sphinxupquote{sp.solve}} command.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Declare symbolic variables}
\PYG{n}{a21}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a21, b1, b2, c2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{c2} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{*} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2.1_ERK_Derivation_2_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxstepscope


\section{Derivation of a fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{2_ERKs/2.2_RK4_Derivation:derivation-of-a-fourth-order-explicit-runge-kutta-method}}\label{\detokenize{2_ERKs/2.2_RK4_Derivation:derivation-of-rk4-section}}\label{\detokenize{2_ERKs/2.2_RK4_Derivation::doc}}
\sphinxAtStartPar
We saw in the {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-section}]{\sphinxcrossref{\DUrole{std,std-ref}{previous section}}}} that we obtain a set of order conditions by comparing the Taylor series expansions of the ODE \(y'=f(t,y)\) to that of the general form for an {\hyperref[\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-rk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{explicit Runge\sphinxhyphen{}Kutta method}}}}. If we do this using a fourth\sphinxhyphen{}order Taylor series expansion then we get the following order conditions (you will not be expected to remember or derive these order conditions).

\begin{sphinxadmonition}{note}{Definition: Order conditions for a fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}
\begin{equation}\label{equation:2_ERKs/2.2_RK4_Derivation:rk4-order-conditions-equation}
\begin{split}\begin{align}
    b_1 + b_2 + b_3 + b_4 &= 1,\\
    b_2 c_2 + b_3 c_3 + b_4 c_4 &=  \frac{1}{2},\\
    b_2 c_2^2 + b_3 c_3^2 + b_4 c_4^2 &= \frac{1}{3},\\
    b_2 c_2^3 + b_3 c_3^3 + b_4 c_4^3 &= \frac{1}{4},\\
    b_3 c_3 a_{32} c_2 + b_4 c_4 (a_{42} c_2 + a_{43} c_3 ) &= \frac{1}{8},\\
    b_3 a_{32} + b_4 a_{42} &= b_2 (1-c_2 ),\\
    b_4 a_{43} &= b_3 (1 - c_3 ),\\
    0 &= b_4 (1-c_4 ).
\end{align}\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
In addition to these, another condition that is placed on Runge\sphinxhyphen{}Kutta methods is the \sphinxstylestrong{row sum condition}.

\begin{sphinxadmonition}{note}{Definition: Row sum condition}
\label{equation:2_ERKs/2.2_RK4_Derivation:089ff539-b337-4289-85e8-0c62ff339609}\begin{align}
    c_i =\sum_{j=1}^{s} a_{ij},
\end{align}
\sphinxAtStartPar
i.e., the value of \(c_i\) is equal to the sum of row \(i\) of the matrix \(A\).
\end{sphinxadmonition}

\sphinxAtStartPar
Since we have an explicit method we know that \(c_1 = 0\) then the row sum conditions for a fourth\sphinxhyphen{}order explicit method are
\begin{equation}\label{equation:2_ERKs/2.2_RK4_Derivation:rk4-row-sum-conditions-equation}
\begin{split}\begin{align*}
    c_2 &=a_{21} ,\\
    c_3 &=a_{31} + a_{32} ,\\
    c_4 &=a_{41} + a_{42} + a_{43} .
\end{align*}\end{split}
\end{equation}
\sphinxAtStartPar
Combining the conditions in equations \eqref{equation:2_ERKs/2.2_RK4_Derivation:rk4-order-conditions-equation} and \eqref{equation:2_ERKs/2.2_RK4_Derivation:rk4-row-sum-conditions-equation} then we have a total of 11 order conditions expressed in 13 unknowns  which can be expressed in the Butcher tableau
\begin{align*}
    \begin{array}{c|cccc}
        0 & 0 \\
        c_2 & a_{21} \\
        c_3 & a_{31} & a_{32} \\
        c_4 & a_{41} & a_{42} & a_{43} \\ \hline
        & b_1 & b_2 & b_3 & b_4
    \end{array}
\end{align*}
\sphinxAtStartPar
To determine a unique solution we choose values for some of the unknowns and solve the order conditions for the remaining unknowns.

\phantomsection\label{\detokenize{2_ERKs/2.2_RK4_Derivation:rk4-derivation-example}}
\begin{sphinxadmonition}{note}{Example 2.3}

\sphinxAtStartPar
Derive a fourth\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method where \(c_2 = c_3 = \frac{1}{2}\), \(c_4 =1\) and \(b_2 = \frac{1}{3}\).
\subsubsection*{Solution}

\sphinxAtStartPar
Substituting the known values of \(c_2\), \(c_3\), \(c_4\) and \(b_2\) into the first three order conditions in equation \eqref{equation:2_ERKs/2.2_RK4_Derivation:rk4-order-conditions-equation} (we only need the first three to solve for \(b_1\), \(b_3\) and \(b_4\)) we have
\begin{align*}
    b_1 + b_3 + b_4 &= \frac{2}{3}, \\
    \frac{1}{2}b_3 + b_4 &= \frac{1}{3}, \\
    \frac{1}{4}b_3 + b_4 &= \frac{1}{4}.
\end{align*}
\sphinxAtStartPar
Subtracting the third order condition from the second gives
\begin{align*}
    \frac{1}{4}b_3 = \frac{1}{12},
\end{align*}
\sphinxAtStartPar
therefore \(b_3 = \frac{1}{3}\) and from the third order condition we have \(b_4 = \frac{1}{6}\). Substituting \(b_3\) and \(b_4\) into the first order condition gives \(b_1 = \frac{1}{3}\). Substituting the known values of \(b_3\) and \(c_3\) into the seventh order condition gives
\begin{align*}
    \frac{1}{6}a_{43} &= \frac{1}{3}\left(1 - \frac{1}{2}\right) = \frac{1}{6},
\end{align*}
\sphinxAtStartPar
so \(a_{43} = 1\). Substituting the known values of \(b_i\) and \(c_i\) into the sixth order condtion gives
\begin{align*}
    \left( \frac{1}{3} \right) \left( \frac{1}{2} \right) \left( \frac{1}{2} \right) a_{32} + \frac{1}{6} \left( \frac{1}{2} a_{42} + \frac{1}{2} \right) &= \frac{1}{8}, \\
    \left( \frac{1}{3} \right) a_{32} + \left( \frac{1}{6} \right) a_{42} &= \frac{1}{3} \left( 1 - \frac{1}{2} \right),
\end{align*}
\sphinxAtStartPar
so we have the system
\begin{align*}
    \frac{1}{12}a_{32} + \frac{1}{12}a_{42} &= \frac{1}{24}, \\
    \frac{1}{3}a_{32} + \frac{1}{6}a_{42} &= \frac{1}{6}.
\end{align*}
\sphinxAtStartPar
Subtracting 2 times the first equation from the second
\begin{align*}
    \frac{1}{6}a_{32} &= \frac{1}{12}
\end{align*}
\sphinxAtStartPar
so \(a_{32} = \frac{1}{2}\) and \(a_{42} = 0\). Substituting these into the {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:row-sum-condition}]{\sphinxcrossref{\DUrole{std,std-ref}{row sum condition}}}} we have
\begin{align*}
    \frac{1}{2} &= a_{21}, \\
    \frac{1}{2} &= a_{31} + \frac{1}{2}, \\
    1 &= a_{41} + 1,
\end{align*}
\sphinxAtStartPar
so \(a_{21} = \frac{1}{2}\), \(a_{31} = 0\) and \(a_{41} = 0\). We now have the values of all of the coefficients so this fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method is
\begin{align*}
    y_{n+1} &=y_n +\frac{h}{6}(k_1 +2 k_2 +2k_3 +k_4 ),\\
    k_1 &=f(t_n ,y_n ),\\
    k_2 &=f(t_n +\tfrac{1}{2}h,y_n +\tfrac{1}{2}h k_1 ),\\
    k_3 &=f(t_n +\tfrac{1}{2}h,y_n +\tfrac{1}{2}h k_2 ),\\
    k_4 &=f(t_n +h,y_n +hk_3 ),
\end{align*}
\sphinxAtStartPar
which has the Butcher tableau
\begin{align*}
    \begin{array}{c|cccc}
        0 &  &  &  & \\
        \frac{1}{2} & \frac{1}{2} &  &  & \\
        \frac{1}{2} & 0 & \frac{1}{2} &  & \\
        1 & 0 & 0 & 1 & \\ \hline
        & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
    \end{array}
\end{align*}\end{sphinxadmonition}

\sphinxAtStartPar
This fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method derived above is often referred to as \sphinxstyleemphasis{the} Runge\sphinxhyphen{}Kutta method or \sphinxstylestrong{RK4} for short.

\begin{sphinxadmonition}{note}{Definition: The fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method (RK4)}
\begin{equation}\label{equation:2_ERKs/2.2_RK4_Derivation:rk4-equation}
\begin{split}\begin{align*}
    y_{n+1} &= y_n + \frac{h}{6}(k_1 + 2 k_2 + 2 k_3 + k_4), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + \tfrac{1}{2} h, y_n + \tfrac{1}{2} h k_1), \\
    k_3 &= f(t_n + \tfrac{1}{2} h, y_n + \tfrac{1}{2} h k_2), \\
    k_4 &= f(t_n + h, y_n + h k_3).
\end{align*} \end{split}
\end{equation}\end{sphinxadmonition}


\subsection{Using Python to solve the order conditions}
\label{\detokenize{2_ERKs/2.2_RK4_Derivation:using-python-to-solve-the-order-conditions}}
\sphinxAtStartPar
The code below derives the fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method from the {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:rk4-derivation-example}]{\emph{example}}} above using SymPy.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Declare symbolic variables}
\PYG{n}{a21}\PYG{p}{,} \PYG{n}{a31}\PYG{p}{,} \PYG{n}{a32}\PYG{p}{,} \PYG{n}{a41}\PYG{p}{,} \PYG{n}{a42}\PYG{p}{,} \PYG{n}{a43} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a21, a31, a32, a41, a42, a43}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{,} \PYG{n}{b4} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b1, b2, b3, b4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{c2}\PYG{p}{,} \PYG{n}{c3}\PYG{p}{,} \PYG{n}{c4} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c2, c3, c4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Choose 4 values for the unkowns}
\PYG{n}{c2}\PYG{p}{,} \PYG{n}{c3}\PYG{p}{,} \PYG{n}{c4}\PYG{p}{,} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{eq4} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{eq5} \PYG{o}{=} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{*} \PYG{n}{a32} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a42} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{+} \PYG{n}{a43} \PYG{o}{*} \PYG{n}{c3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{eq6} \PYG{o}{=} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{a32} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{a42} \PYG{o}{\PYGZhy{}} \PYG{n}{b2} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{c2}\PYG{p}{)}
\PYG{n}{eq7} \PYG{o}{=} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{a43} \PYG{o}{\PYGZhy{}} \PYG{n}{b3} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{c3}\PYG{p}{)}
\PYG{n}{eq8} \PYG{o}{=} \PYG{n}{b4} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{c4}\PYG{p}{)}
\PYG{n}{eq9} \PYG{o}{=} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{a21}
\PYG{n}{eq10} \PYG{o}{=} \PYG{n}{c3} \PYG{o}{\PYGZhy{}} \PYG{n}{a31} \PYG{o}{\PYGZhy{}} \PYG{n}{a32}
\PYG{n}{eq11} \PYG{o}{=} \PYG{n}{c4} \PYG{o}{\PYGZhy{}} \PYG{n}{a41}\PYG{o}{\PYGZhy{}} \PYG{n}{a42} \PYG{o}{\PYGZhy{}} \PYG{n}{a43}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{,} \PYG{n}{eq4}\PYG{p}{,} \PYG{n}{eq5}\PYG{p}{,} \PYG{n}{eq6}\PYG{p}{,} \PYG{n}{eq7}\PYG{p}{,} \PYG{n}{eq8}\PYG{p}{,} \PYG{n}{eq9}\PYG{p}{,} \PYG{n}{eq10}\PYG{p}{,} \PYG{n}{eq11}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2.2_RK4_Derivation_2_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Solving initial value problems using explicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:solving-initial-value-problems-using-explicit-runge-kutta-methods}}\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:applying-erk-methods-to-solve-ivps-section}}\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods::doc}}
\sphinxAtStartPar
Recall that the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:general-form-of-a-rk-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{general form of an explicit Runge\sphinxhyphen{}Kutta method}}}} is
\begin{align*}
    y_{n+1} &= y_n + h(b_1k_1 + b_2k_2 + \cdots + b_sk_s), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + c_2h, y_n + ha_{21}k_1), \\
    k_3 &= f(t_n + c_3h, y_n + h(a_{31}k_1 + a_{32}k_2), \\
    &\vdots \\
    k_s &= f(t_n + c_sh, y_n + h(a_{s1}k_1 + a_{s2}k_2 + \cdots + a_{s,s-1}k_{s-1}).
\end{align*}
\sphinxAtStartPar
To apply the an explicit Runge\sphinxhyphen{}Kutta method to solve an initial value problem we calculate the stage values \(k_1, k_2, \dots, k_s\) using the known values of \(t_n\) and \(y_n\) and the step length \(h\). Then the solution over one step \(y_{n+1}\) is then calculated using \(k_1, k_2, \ldots, k_s\).

\begin{sphinxadmonition}{note}{Example 2.4}

\sphinxAtStartPar
Calculate the solution to the following initial value problem using the {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:rk4-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{RK4 method}}}} with \(h = 0.2\)
\begin{align*}
    y'=ty, \qquad t\in [0,1], \qquad y(0)=1,
\end{align*}
\sphinxAtStartPar
and compare the computed solution to the exact solution which is \(y = \exp\left(\dfrac{t^2}{2}\right)\).
\subsubsection*{Solution}

\sphinxAtStartPar
The RK4 method is
\begin{align*}
    y_{n+1} &= y_n + \frac{h}{6}(k_1 + 2k_2 + 3k_3 + k_4), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + \frac{1}{2}h, y_n + \frac{1}{2}hk_1), \\
    k_3 &= f(t_n + \frac{1}{2}h, y_n + \frac{1}{2}hk_2), \\
    k_4 &= f(t_n + h, y_n + hk_3).
\end{align*}
\sphinxAtStartPar
Since \(t\in[0,1]\) and \(h=0.2\) then the number of steps required is
\begin{equation*}
\begin{split}n = \operatorname{int}\left(\frac{1 - 0}{0.2}\right) = 5, \end{split}
\end{equation*}
\sphinxAtStartPar
and the \(t\) values are
\begin{equation*}
\begin{split}\mathbf{t} = (0, 0.2, 0.4, 0.6, 0.8, 1.0).\end{split}
\end{equation*}
\sphinxAtStartPar
The ODE function is \(f(t, y) = ty\) and the initial value is \(y_0 = 1\) so using equation \eqref{equation:2_ERKs/2.2_RK4_Derivation:rk4-equation}
\begin{align*}
    k_1 &= f(t_0, y_0) = (0.0)(1) = 0, \\
    k_2 &= f(t_0 + \frac{1}{2}h, y_0 + \frac{1}{2}hk_1) \\
    &= (0.0 + \frac{1}{2}(0.2))(1 + \frac{1}{2}(0.2)(0)) \\
    &= 0.1, \\
    k_3 &= f(t_0 + \frac{1}{2}h, y_0 + \frac{1}{2}hk_2) \\
    &= (0.0 + \frac{1}{2}(0.2))(1 + \frac{1}{2}(0.2)(0.1)) \\
    &= 0.101, \\
    k_4 &= f(t_0 + h, y_0 + hk_2) \\
    &= (0.0 + h)(1 + 0.2(0.1)) \\
    &= 0.101, \\
    y_1 &= y_0 + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) \\
    &= 1 + \frac{0.2}{6}(0 + 2(0.1) + 2(0.101) + 0.204040) \\
    &= 1.020201, \\
    \\
    k_1 &= f(t_1, y_1) = (0.2)(1.020201) = 0.204040, \\
    k_2 &= f(t_1 + \frac{1}{2}h, y_1 + \frac{1}{2}hk_1) \\
    &= (0.2 + \frac{1}{2}(0.2))(1.020201 + \frac{1}{2}(0.2)(0.204040)) \\
    &= 0.312182, \\
    k_3 &= f(t_1 + \frac{1}{2}h, y_1 + \frac{1}{2}hk_2) \\
    &= (0.2 + \frac{1}{2}(0.2))(1.020201 + \frac{1}{2}(0.2)(0.312182)) \\
    &= 0.315426, \\
    k_4 &= f(t_1 + h, y_1 + hk_2) \\
    &= (0.2 + h)(1.020201 + 0.2(0.312182)) \\
    &= 0.315426, \\
    y_2 &= y_1 + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) \\
    &= 1.020201 + \frac{0.2}{6}(0.204040 + 2(0.312182) + 2(0.315426) + 0.433315) \\
    &= 1.083287, \\
    \\
    k_1 &= f(t_2, y_2) = (0.4)(1.083287) = 0.433315, \\
    k_2 &= f(t_2 + \frac{1}{2}h, y_2 + \frac{1}{2}hk_1) \\
    &= (0.4 + \frac{1}{2}(0.2))(1.083287 + \frac{1}{2}(0.2)(0.433315)) \\
    &= 0.563309, \\
    k_3 &= f(t_2 + \frac{1}{2}h, y_2 + \frac{1}{2}hk_2) \\
    &= (0.4 + \frac{1}{2}(0.2))(1.083287 + \frac{1}{2}(0.2)(0.563309)) \\
    &= 0.569809, \\
    k_4 &= f(t_2 + h, y_2 + hk_2) \\
    &= (0.4 + h)(1.083287 + 0.2(0.563309)) \\
    &= 0.569809, \\
    y_3 &= y_2 + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) \\
    &= 1.083287 + \frac{0.2}{6}(0.433315 + 2(0.563309) + 2(0.569809) + 0.718349) \\
    &= 1.197217, \\
    \\
    k_1 &= f(t_3, y_3) = (0.6)(1.197217) = 0.718330, \\
    k_2 &= f(t_3 + \frac{1}{2}h, y_3 + \frac{1}{2}hk_1) \\
    &= (0.6 + \frac{1}{2}(0.2))(1.197217 + \frac{1}{2}(0.2)(0.718330)) \\
    &= 0.888335, \\
    k_3 &= f(t_3 + \frac{1}{2}h, y_3 + \frac{1}{2}hk_2) \\
    &= (0.6 + \frac{1}{2}(0.2))(1.197217 + \frac{1}{2}(0.2)(0.888335)) \\
    &= 0.900235, \\
    k_4 &= f(t_3 + h, y_3 + hk_2) \\
    &= (0.6 + h)(1.197217 + 0.2(0.888335)) \\
    &= 0.900235, \\
    y_4 &= y_3 + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) \\
    &= 1.197217 + \frac{0.2}{6}(0.718330 + 2(0.888335) + 2(0.900235) + 1.101811) \\
    &= 1.377126, \\
    \\
    k_1 &= f(t_4, y_4) = (0.8)(1.377126) = 1.101701, \\
    k_2 &= f(t_4 + \frac{1}{2}h, y_4 + \frac{1}{2}hk_1) \\
    &= (0.8 + \frac{1}{2}(0.2))(1.377126 + \frac{1}{2}(0.2)(1.101701)) \\
    &= 1.338567, \\
    k_3 &= f(t_4 + \frac{1}{2}h, y_4 + \frac{1}{2}hk_2) \\
    &= (0.8 + \frac{1}{2}(0.2))(1.377126 + \frac{1}{2}(0.2)(1.338567)) \\
    &= 1.359885, \\
    k_4 &= f(t_4 + h, y_4 + hk_2) \\
    &= (0.8 + h)(1.377126 + 0.2(1.338567)) \\
    &= 1.359885, \\
    y_5 &= y_4 + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) \\
    &= 1.377126 + \frac{0.2}{6}(1.101701 + 2(1.338567) + 2(1.359885) + 1.649103) \\
    &= 1.648717.
\end{align*}\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:python-code}}\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-python-code}}
\sphinxAtStartPar
The Python code below defines a function called \sphinxcode{\sphinxupquote{rk4()}} which computes the solution to an initial value problem using the RK4 method. Note that the function is very similar to the function for the {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-python-code}]{\sphinxcrossref{\DUrole{std,std-ref}{RK2 method}}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rk4}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{k3} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k2}\PYG{p}{)}
        \PYG{n}{k4} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k3}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{6} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{k2} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{k3} \PYG{o}{+} \PYG{n}{k4}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The computed solutions using the fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta are plotted in \hyperref[\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-example-figure}]{Fig.\@ \ref{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-example-figure}}} below.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2.3_Solving_IVPs_using_ERK_methods_4_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The solutions to the initial value problem \(y'=ty\), \(t\in[0,1]\), \(y(0)=1\) using the RK4 method with \(h=0.2\).}\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-example-figure}}\end{figure}

\sphinxAtStartPar
Doing a visual comparison of the solutions using the {\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{RK2}}}} (\hyperref[\detokenize{1_IVPs/1.4_RK2:rk2-example-figure}]{Fig.\@ \ref{\detokenize{1_IVPs/1.4_RK2:rk2-example-figure}}}) and {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:rk4-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{RK4}}}} (\hyperref[\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-example-figure}]{Fig.\@ \ref{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-example-figure}}}) methods it appears that the two solutions are very similar. A loglog plot of the global truncation errors for these methods and the Euler methods is shown in \hyperref[\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-gte-plot-figure}]{Fig.\@ \ref{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-gte-plot-figure}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2.3_Solving_IVPs_using_ERK_methods_6_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{A loglog plot of the global truncation errors for the solutions of \(y'=ty\), \(y(0)=1\) using the Euler, RK2 and RK4 methods solutions.}\label{\detokenize{2_ERKs/2.3_Solving_IVPs_using_ERK_methods:rk4-gte-plot-figure}}\end{figure}

\sphinxAtStartPar
Here we see that the fourth\sphinxhyphen{}order method is significantly more accurate than the second\sphinxhyphen{}order method and approximating the value of \(n\) in \(e = O(h^n)\) using the method given in equation \eqref{equation:1_IVPs/1.4_RK2:order-approximation-equation} gives \(n = 4.09\) which indicates fourth\sphinxhyphen{}order convergence as expected.

\sphinxstepscope


\section{Chapter Summary}
\label{\detokenize{2_ERKs/2.4_ERK_Summary:chapter-summary}}\label{\detokenize{2_ERKs/2.4_ERK_Summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Runge\sphinxhyphen{}Kutta methods}}}} are \sphinxstylestrong{single step methods} that use intermediate \sphinxstylestrong{stage} values to advance the solution over a small step of length \(h\) using known values of \(t_n\) and \(y_n\) to calculate \(y_{n+1} = y(t_n+h)\);

\item {} 
\sphinxAtStartPar
Runge\sphinxhyphen{}Kutta methods are commonly expressed in tabular form called a {\hyperref[\detokenize{2_ERKs/2.0_ERKs:butcher-tableau-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher tableau}}}};

\item {} 
\sphinxAtStartPar
There are two types of Runge\sphinxhyphen{}Kutta methods: explicit and implicit methods.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-rk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Explicit Runge\sphinxhyphen{}Kutta methods}}}} are more straightforward to calculate but can be inefficient for some types of ODEs;

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-rk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit Runge\sphinxhyphen{}Kutta methods}}}} are less straightforward to calculate but are more efficient for some types of ODEs;

\item {} 
\sphinxAtStartPar
The coefficients of a Runge\sphinxhyphen{}Kutta methods are chosen to satisfy the \sphinxstylestrong{order conditions} which are derived by comparing the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series expansion}}}} to the general form of the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Runge\sphinxhyphen{}Kutta method}}}} to the equivalent Taylor series expansion of the first\sphinxhyphen{}order ODE \(y' = f(t,y)\).

\end{itemize}

\sphinxstepscope


\section{Explicit Runge\sphinxhyphen{}Kutta Methods Exercises}
\label{\detokenize{2_ERKs/2.5_ERK_Exercises:explicit-runge-kutta-methods-exercises}}\label{\detokenize{2_ERKs/2.5_ERK_Exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 2.1}

\sphinxAtStartPar
Write the following Runge\sphinxhyphen{}Kutta method in a Butcher tableau.
\begin{align*}
    y_{n+1} &=y_n +\frac{h}{6}(k_1 +4k_3 +k_4 ),\\
    k_1 &=f(t_n ,y_n ),\\
    k_2 &=f(t_n +\tfrac{1}{4}h,y_n +\tfrac{1}{4}hk_1 ),\\
    k_3 &=f(t_n +\tfrac{1}{2}h,y_n +\tfrac{1}{2}hk_2 ),\\
    k_4 &=f(t_n +h,y_n +h(k_1 -2k_2 +2k_3 )).
\end{align*}\subsubsection*{Solution}
\begin{align*}
    \begin{array}{c|cccc}
        0 & 0 \\
        \frac{1}{4} & \frac{1}{4} \\
        \frac{1}{2} & 0 & \frac{1}{2} \\
        1 & 1 & -2 & 2 \\ \hline
        & \frac{1}{6} & 0 & \frac{2}{3} & \frac{1}{6}
    \end{array}
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.2}

\sphinxAtStartPar
Write out the equations for the following Runge\sphinxhyphen{}Kutta method.
\begin{align*}\begin{array}{c|cccc}
    0 &  &  &  & \\
    \frac{1}{4} & \frac{1}{4} &  &  & \\
    \frac{1}{2} & -\frac{1}{2} & 1 &  & \\
    1 & \frac{1}{4} & 0 & \frac{3}{4} & \\ \hline
    & 0 & \frac{4}{9} & \frac{1}{3} & \frac{2}{9}
\end{array}\end{align*}\subsubsection*{Solution}
\begin{align*}
    y_{n+1} &= y_n + \frac{h}{9}(4k_2 + 3k_3 + 2k_4), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + \tfrac{1}{4}h, y_n + \tfrac{1}{4} h k_1), \\
    k_3 &= f(t_n + \tfrac{1}{2}h, y_n + h ( - \tfrac{1}{2}k_1 + k_2)), \\
    k_4 &= f(t_n + h, y_n + h ( \tfrac{1}{4}k_1 + \tfrac{3}{4}k_3)).
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.3}

\sphinxAtStartPar
Using pen and paper, derive an explicit second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method where \(b_1 =\frac{1}{3}\).
\subsubsection*{Solution}

\sphinxAtStartPar
The order conditions are:
\begin{align*}
    \frac{1}{3} + b_2 &=1,\\
    c_2 b_2 &=\frac{1}{2},\\
    a_{21} b_2 &=\frac{1}{2}
\end{align*}
\sphinxAtStartPar
Solving gives \(b_2 = \frac{2}{3}\), \(c_2=\frac{3}{4}\) and \(a_{21} = \frac{3}{4}\) so the method is
\begin{align*}
    y_{n+1} &= y_n + \frac{h}{3}(k_1 + 2k_2), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + \tfrac{3}{4}h, y_n + \tfrac{3}{4}h k_1).
\end{align*}
\sphinxAtStartPar
Alternatively as a Butcher tableau
\begin{align*}
    \begin{array}{c|cc}
    0 & 0 \\
    \frac{3}{4} & \frac{3}{4} & 0 \\ \hline
    & \frac{1}{3} & \frac{2}{3}
    \end{array}
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.4}

\sphinxAtStartPar
Repeat {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-3}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.3}}}} using Python to solve the order conditions.
\subsubsection*{Solution}

\sphinxAtStartPar
Code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Declare symbolic variables}
\PYG{n}{a21}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a21, b1, b2, c2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b1} \PYG{o}{=} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{*} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:
\begin{equation}\label{equation:intro:ex2.4-glue}
\begin{split}\displaystyle \left[ \left\{ a_{21} : \frac{3}{4}, \  b_{2} : \frac{2}{3}, \  c_{2} : \frac{3}{4}\right\}\right]\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.5}

\sphinxAtStartPar
Derive an explicit fourth\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method where \(b_1 = 0\) and \(c_2 =\frac{1}{5}\).
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Declare symbolic variables}
\PYG{n}{a21}\PYG{p}{,} \PYG{n}{a31}\PYG{p}{,} \PYG{n}{a32}\PYG{p}{,} \PYG{n}{a41}\PYG{p}{,} \PYG{n}{a42}\PYG{p}{,} \PYG{n}{a43} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a21, a31, a32, a41, a42, a43}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{,} \PYG{n}{b4} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b1, b2, b3, b4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{c2}\PYG{p}{,} \PYG{n}{c3}\PYG{p}{,} \PYG{n}{c4} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c2, c3, c4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Choose values for the unkowns}
\PYG{n}{b1}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{eq4} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{eq5} \PYG{o}{=} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{c3} \PYG{o}{*} \PYG{n}{a32} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{c4} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a42} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{+} \PYG{n}{a43} \PYG{o}{*} \PYG{n}{c3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{eq6} \PYG{o}{=} \PYG{n}{b3} \PYG{o}{*} \PYG{n}{a32} \PYG{o}{+} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{a42} \PYG{o}{\PYGZhy{}} \PYG{n}{b2} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{c2}\PYG{p}{)}
\PYG{n}{eq7} \PYG{o}{=} \PYG{n}{b4} \PYG{o}{*} \PYG{n}{a43} \PYG{o}{\PYGZhy{}} \PYG{n}{b3} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{c3}\PYG{p}{)}
\PYG{n}{eq8} \PYG{o}{=} \PYG{n}{b4} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{c4}\PYG{p}{)}
\PYG{n}{eq9} \PYG{o}{=} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{a21}
\PYG{n}{eq10} \PYG{o}{=} \PYG{n}{c3} \PYG{o}{\PYGZhy{}} \PYG{n}{a31} \PYG{o}{\PYGZhy{}} \PYG{n}{a32}
\PYG{n}{eq11} \PYG{o}{=} \PYG{n}{c4} \PYG{o}{\PYGZhy{}} \PYG{n}{a41}\PYG{o}{\PYGZhy{}} \PYG{n}{a42} \PYG{o}{\PYGZhy{}} \PYG{n}{a43}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{,} \PYG{n}{eq4}\PYG{p}{,} \PYG{n}{eq5}\PYG{p}{,} \PYG{n}{eq6}\PYG{p}{,} \PYG{n}{eq7}\PYG{p}{,} \PYG{n}{eq8}\PYG{p}{,} \PYG{n}{eq9}\PYG{p}{,} \PYG{n}{eq10}\PYG{p}{,} \PYG{n}{eq11}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:
\begin{equation}\label{equation:intro:ex2.5-glue}
\begin{split}\displaystyle \left[ \left\{ a_{21} : \frac{1}{5}, \  a_{31} : - \frac{31}{32}, \  a_{32} : \frac{55}{32}, \  a_{41} : 9, \  a_{42} : - \frac{120}{11}, \  a_{43} : \frac{32}{11}, \  b_{2} : \frac{125}{264}, \  b_{3} : \frac{16}{33}, \  b_{4} : \frac{1}{24}, \  c_{3} : \frac{3}{4}, \  c_{4} : 1\right\}\right]\end{split}
\end{equation}
\sphinxAtStartPar
So the method is
\begin{align*}
    y_{n+1} &= y_n + h(\tfrac{125}{264} k_2 + \tfrac{16}{33} k_3 + \tfrac{1}{24} k_4), \\
    k_1 &= f(t_n, y_n), \\
    k_2 &= f(t_n + \tfrac{1}{5}h, y_n + \tfrac{1}{5}h k_1), \\
    k_3 &= f(t_n + \tfrac{3}{4}h, y_n + h(-\tfrac{31}{32} k_1 + \tfrac{55}{32} k_2)), \\
    k_4 &= f(t_n + h, y_n + h(9 k_1 - \tfrac{120}{11} k_2 + \tfrac{32}{11} k_3)).
\end{align*}
\sphinxAtStartPar
Alternatively as a Butcher tableau
\begin{align*}
    \begin{array}{c|cccc}
    0 & 0 \\
    \frac{1}{5} & \frac{1}{5} \\
    \frac{3}{4} & -\frac{31}{32} & \frac{55}{32} \\
    1 & 9 & -\frac{120}{11} & \frac{32}{11} \\
    \hline
    & 0 & \frac{125}{264} & \frac{16}{33} & \frac{1}{24}
    \end{array}
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.6}

\sphinxAtStartPar
Using pen and paper, apply your Runge\sphinxhyphen{}Kutta method derived in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-3}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.3}}}} to solve the following initial value problem using a step length of \(h=0.4\)
\begin{align*}
    y' =t-y, \qquad t\in [0,2],\qquad y(0)=1
\end{align*}
\sphinxAtStartPar
Write your solutions correct to 4 decimal places.
\subsubsection*{Solution}
\begin{align*}
    k_1 &= f(t_0, y_0) = (0) - (1) = -1, \\
    k_2 &= f(t_0 + \tfrac{3}{4} h, y_0 + \tfrac{3}{4} hk_1) \\
    &= (0.0 + \tfrac{3}{4}(0.4)) - (1 + \tfrac{3}{4}(0.4)(-1)) \\
    &= -0.4, \\
    y_1 &= y_0 + \frac{h}{3}(k_1 + 2 k_2) \\
    &= 1 + \frac{0.4}{3}(-1 + 2(-0.4)) \\
    &= 0.76, \\
    \\
    k_1 &= f(t_1, y_1) = (0.4) - (0.76) = -0.36, \\
    k_2 &= f(t_1 + \tfrac{3}{4} h, y_1 + \tfrac{3}{4} hk_1) \\
    &= (0.4 + \tfrac{3}{4}(0.4)) - (0.76 + \tfrac{3}{4}(0.4)(-0.36)) \\
    &= 0.0480, \\
    y_2 &= y_1 + \frac{h}{3}(k_1 + 2 k_2) \\
    &= 0.76 + \frac{0.4}{3}(-0.36 + 2(0.0480)) \\
    &= 0.7248, \\
    \\
    k_1 &= f(t_2, y_2) = (0.8) - (0.7248) = 0.0752, \\
    k_2 &= f(t_2 + \tfrac{3}{4} h, y_2 + \tfrac{3}{4} hk_1) \\
    &= (0.8 + \tfrac{3}{4}(0.4)) - (0.7248 + \tfrac{3}{4}(0.4)(0.0752)) \\
    &= 0.3526, \\
    y_3 &= y_2 + \frac{h}{3}(k_1 + 2 k_2) \\
    &= 0.7248 + \frac{0.4}{3}(0.0752 + 2(0.3526)) \\
    &= 0.8289, \\
    \\
    k_1 &= f(t_3, y_3) = (1.2) - (0.8289) = 0.3711, \\
    k_2 &= f(t_3 + \tfrac{3}{4} h, y_3 + \tfrac{3}{4} hk_1) \\
    &= (1.2 + \tfrac{3}{4}(0.4)) - (0.8289 + \tfrac{3}{4}(0.4)(0.3711)) \\
    &= 0.5598, \\
    y_4 &= y_3 + \frac{h}{3}(k_1 + 2 k_2) \\
    &= 0.8289 + \frac{0.4}{3}(0.3711 + 2(0.5598)) \\
    &= 1.0276, \\
    \\
    k_1 &= f(t_4, y_4) = (1.6) - (1.0276) = 0.5724, \\
    k_2 &= f(t_4 + \tfrac{3}{4} h, y_4 + \tfrac{3}{4} hk_1) \\
    &= (1.6 + \tfrac{3}{4}(0.4)) - (1.0276 + \tfrac{3}{4}(0.4)(0.5724)) \\
    &= 0.7007, \\
    y_5 &= y_4 + \frac{h}{3}(k_1 + 2 k_2) \\
    &= 1.0276 + \frac{0.4}{3}(0.5724 + 2(0.7007)) \\
    &= 1.2908.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.7}

\sphinxAtStartPar
Define a Python function called \sphinxcode{\sphinxupquote{myrk2()}} which uses the method from derived in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-3}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.3}}}} to solve an initial value problem. Use your function to solve the initial value problem in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-6}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.6}}}} and produce a table of the solutions.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{myrk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{k2}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{n}{y}


\PYG{c+c1}{\PYGZsh{} Define IVP}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Solve IVP}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{myrk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print table of solutions}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  t  |    y    |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{3.1f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{7.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{|}  \PYG{n}{t}  \PYG{o}{|}    \PYG{n}{y}    \PYG{o}{|}
\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.0} \PYG{o}{|}  \PYG{l+m+mf}{1.0000} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.4} \PYG{o}{|}  \PYG{l+m+mf}{0.7600} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.8} \PYG{o}{|}  \PYG{l+m+mf}{0.7248} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{1.2} \PYG{o}{|}  \PYG{l+m+mf}{0.8289} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{1.6} \PYG{o}{|}  \PYG{l+m+mf}{1.0276} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{2.0} \PYG{o}{|}  \PYG{l+m+mf}{1.2908} \PYG{o}{|}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.8}

\sphinxAtStartPar
Using pen and paper, apply your Runge\sphinxhyphen{}Kutta method derived in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-5}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.5}}}} to solve the initial value problem from {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-6}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.6}}}} using a step length of \(h=0.4\). Write your solutions correct to 4 decimal places.
\subsubsection*{Solution}
\begin{align*}
    k_1 &= f(t_0, y_0) = (0) - (1) = -1, \\
    k_2 &= f(t_0 + \tfrac{1}{5}h, y_0 + \tfrac{1}{5}hk_1) \\
    &= (0 + \tfrac{1}{5}(0.4)) - (1 + \tfrac{1}{5}(0.4)(-1)) \\
    &= -0.84, \\
    k_3 &= f(t_0 + \tfrac{3}{4}h, y_0 + h(-\tfrac{31}{32}k_1 + \tfrac{55}{32}k_2)) \\
    &= (0 + \tfrac{3}{4}(0.4)) - (1 + 0.4(-\tfrac{31}{32}(-1) + \tfrac{55}{32}-0.84)) \\
    &= -0.51, \\
    k_4 &= f(t_0 + h, y_0 + h(9k_1 - \tfrac{120}{11}k_2 + \tfrac{32}{11}k_3) \\
    &= (0 + 0.4) - (1 + 0.4(9(-1) - \tfrac{120}{11}(-0.84) + \tfrac{32}{11}-0.51)) \\
    &= -0.51, \\
    y_1 &= y_0 + h\left( \tfrac{125}{264} k_2 + \tfrac{16}{33} k_3 + \tfrac{1}{24} k_4 \right) \\
    &= 1 + 0.4 \left( \tfrac{125}{264} (-0.84) + \tfrac{16}{33} (-0.51) + \tfrac{1}{24} (-0.0720) \right) \\
    &= 0.7408, \\
    \\
    k_1 &= f(t_1, y_1) = (0.4) - (0.7408) = -0.3408, \\
    k_2 &= f(t_1 + \tfrac{1}{5}h, y_1 + \tfrac{1}{5}hk_1) \\
    &= (0.4 + \tfrac{1}{5}(0.4)) - (0.7408 + \tfrac{1}{5}(0.4)(-0.3408)) \\
    &= -0.2335, \\
    k_3 &= f(t_1 + \tfrac{3}{4}h, y_1 + h(-\tfrac{31}{32}k_1 + \tfrac{55}{32}k_2)) \\
    &= (0.4 + \tfrac{3}{4}(0.4)) - (0.7408 + 0.4(-\tfrac{31}{32}(-0.3408) + \tfrac{55}{32}-0.2335)) \\
    &= -0.0123, \\
    k_4 &= f(t_1 + h, y_1 + h(9k_1 - \tfrac{120}{11}k_2 + \tfrac{32}{11}k_3) \\
    &= (0.4 + 0.4) - (0.7408 + 0.4(9(-0.3408) - \tfrac{120}{11}(-0.2335) + \tfrac{32}{11}-0.0123)) \\
    &= -0.0123, \\
    y_2 &= y_1 + h\left( \tfrac{125}{264} k_2 + \tfrac{16}{33} k_3 + \tfrac{1}{24} k_4 \right) \\
    &= 0.7408 + 0.4 \left( \tfrac{125}{264} (-0.2335) + \tfrac{16}{33} (-0.0123) + \tfrac{1}{24} (0.2813) \right) \\
    &= 0.6989, \\
    \\
    k_1 &= f(t_2, y_2) = (0.8) - (0.6989) = 0.1011, \\
    k_2 &= f(t_2 + \tfrac{1}{5}h, y_2 + \tfrac{1}{5}hk_1) \\
    &= (0.8 + \tfrac{1}{5}(0.4)) - (0.6989 + \tfrac{1}{5}(0.4)(0.1011)) \\
    &= 0.1730, \\
    k_3 &= f(t_2 + \tfrac{3}{4}h, y_2 + h(-\tfrac{31}{32}k_1 + \tfrac{55}{32}k_2)) \\
    &= (0.8 + \tfrac{3}{4}(0.4)) - (0.6989 + 0.4(-\tfrac{31}{32}(0.1011) + \tfrac{55}{32}0.1730)) \\
    &= 0.3214, \\
    k_4 &= f(t_2 + h, y_2 + h(9k_1 - \tfrac{120}{11}k_2 + \tfrac{32}{11}k_3) \\
    &= (0.8 + 0.4) - (0.6989 + 0.4(9(0.1011) - \tfrac{120}{11}(0.1730) + \tfrac{32}{11}0.3214)) \\
    &= 0.3214, \\
    y_3 &= y_2 + h\left( \tfrac{125}{264} k_2 + \tfrac{16}{33} k_3 + \tfrac{1}{24} k_4 \right) \\
    &= 0.6989 + 0.4 \left( \tfrac{125}{264} (0.1730) + \tfrac{16}{33} (0.3214) + \tfrac{1}{24} (0.5182) \right) \\
    &= 0.8026, \\
    \\
    k_1 &= f(t_3, y_3) = (1.2) - (0.8026) = 0.3974, \\
    k_2 &= f(t_3 + \tfrac{1}{5}h, y_3 + \tfrac{1}{5}hk_1) \\
    &= (1.2 + \tfrac{1}{5}(0.4)) - (0.8026 + \tfrac{1}{5}(0.4)(0.3974)) \\
    &= 0.4456, \\
    k_3 &= f(t_3 + \tfrac{3}{4}h, y_3 + h(-\tfrac{31}{32}k_1 + \tfrac{55}{32}k_2)) \\
    &= (1.2 + \tfrac{3}{4}(0.4)) - (0.8026 + 0.4(-\tfrac{31}{32}(0.3974) + \tfrac{55}{32}0.4456)) \\
    &= 0.5450, \\
    k_4 &= f(t_3 + h, y_3 + h(9k_1 - \tfrac{120}{11}k_2 + \tfrac{32}{11}k_3) \\
    &= (1.2 + 0.4) - (0.8026 + 0.4(9(0.3974) - \tfrac{120}{11}(0.4456) + \tfrac{32}{11}0.5450)) \\
    &= 0.5450, \\
    y_4 &= y_3 + h\left( \tfrac{125}{264} k_2 + \tfrac{16}{33} k_3 + \tfrac{1}{24} k_4 \right) \\
    &= 0.8026 + 0.4 \left( \tfrac{125}{264} (0.4456) + \tfrac{16}{33} (0.5450) + \tfrac{1}{24} (0.6770) \right) \\
    &= 1.40, \\
    \\
    k_1 &= f(t_4, y_4) = (1.6) - (1.40) = 0.5960, \\
    k_2 &= f(t_4 + \tfrac{1}{5}h, y_4 + \tfrac{1}{5}hk_1) \\
    &= (1.6 + \tfrac{1}{5}(0.4)) - (1.40 + \tfrac{1}{5}(0.4)(0.5960)) \\
    &= 0.6283, \\
    k_3 &= f(t_4 + \tfrac{3}{4}h, y_4 + h(-\tfrac{31}{32}k_1 + \tfrac{55}{32}k_2)) \\
    &= (1.6 + \tfrac{3}{4}(0.4)) - (1.40 + 0.4(-\tfrac{31}{32}(0.5960) + \tfrac{55}{32}0.6283)) \\
    &= 0.6950, \\
    k_4 &= f(t_4 + h, y_4 + h(9k_1 - \tfrac{120}{11}k_2 + \tfrac{32}{11}k_3) \\
    &= (1.6 + 0.4) - (1.40 + 0.4(9(0.5960) - \tfrac{120}{11}(0.6283) + \tfrac{32}{11}0.6950)) \\
    &= 0.6950, \\
    y_5 &= y_4 + h\left( \tfrac{125}{264} k_2 + \tfrac{16}{33} k_3 + \tfrac{1}{24} k_4 \right) \\
    &= 1.40 + 0.4 \left( \tfrac{125}{264} (0.6283) + \tfrac{16}{33} (0.6950) + \tfrac{1}{24} (0.7835) \right) \\
    &= 1.2708.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.9}

\sphinxAtStartPar
Repeat {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-8}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.8}}}} using the {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:rk4-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{RK4 method}}}}. What do your answers tell you about the method derived in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-5}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.5}}}} and the RK4 method?
\subsubsection*{Solution}
\begin{align*}
    k_1 &= f(t_0, y_0) = (0) - (1) = -1, \\
    k_2 &= f(t_0 + \tfrac{1}{2}h, y_0 + \tfrac{1}{2}hk_1) \\
    &= (0 + \tfrac{1}{2}(0.4)) - (1 + \tfrac{1}{2}(0.4)(-1)) \\
    &= -0.6, \\
    k_3 &= f(t_0 + \tfrac{1}{2}h, y_0 + \tfrac{1}{2} hk_2) \\
    &= (0 + \tfrac{1}{2}(0.4)) - (1 + \tfrac{1}{2}0.4(-0.6)) \\
    &= -0.68, \\
    k_4 &= f(t_0 + h, y_0 + hk_3) \\
    &= (0 + 0.4) - (1 + 0.4(-0.68)) \\
    &= -0.68, \\
    y_1 &= y_0 + \frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\
    &= 1 + \frac{0.4}{6} (-1 + 2(-0.6) + 2(-0.68) + -0.3280) \\
    &= 0.7408, \\
    \\
    k_1 &= f(t_1, y_1) = (0.4) - (0.7408) = -0.3408, \\
    k_2 &= f(t_1 + \tfrac{1}{2}h, y_1 + \tfrac{1}{2}hk_1) \\
    &= (0.4 + \tfrac{1}{2}(0.4)) - (0.7408 + \tfrac{1}{2}(0.4)(-0.3408)) \\
    &= -0.0726, \\
    k_3 &= f(t_1 + \tfrac{1}{2}h, y_1 + \tfrac{1}{2} hk_2) \\
    &= (0.4 + \tfrac{1}{2}(0.4)) - (0.7408 + \tfrac{1}{2}0.4(-0.0726)) \\
    &= -0.1263, \\
    k_4 &= f(t_1 + h, y_1 + hk_3) \\
    &= (0.4 + 0.4) - (0.7408 + 0.4(-0.1263)) \\
    &= -0.1263, \\
    y_2 &= y_1 + \frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\
    &= 0.7408 + \frac{0.4}{6} (-0.3408 + 2(-0.0726) + 2(-0.1263) + 0.1097) \\
    &= 0.6989, \\
    \\
    k_1 &= f(t_2, y_2) = (0.8) - (0.6989) = 0.1011, \\
    k_2 &= f(t_2 + \tfrac{1}{2}h, y_2 + \tfrac{1}{2}hk_1) \\
    &= (0.8 + \tfrac{1}{2}(0.4)) - (0.6989 + \tfrac{1}{2}(0.4)(0.1011)) \\
    &= 0.2809, \\
    k_3 &= f(t_2 + \tfrac{1}{2}h, y_2 + \tfrac{1}{2} hk_2) \\
    &= (0.8 + \tfrac{1}{2}(0.4)) - (0.6989 + \tfrac{1}{2}0.4(0.2809)) \\
    &= 0.2449, \\
    k_4 &= f(t_2 + h, y_2 + hk_3) \\
    &= (0.8 + 0.4) - (0.6989 + 0.4(0.2449)) \\
    &= 0.2449, \\
    y_3 &= y_2 + \frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\
    &= 0.6989 + \frac{0.4}{6} (0.1011 + 2(0.2809) + 2(0.2449) + 0.4031) \\
    &= 0.8026, \\
    \\
    k_1 &= f(t_3, y_3) = (1.2) - (0.8026) = 0.3974, \\
    k_2 &= f(t_3 + \tfrac{1}{2}h, y_3 + \tfrac{1}{2}hk_1) \\
    &= (1.2 + \tfrac{1}{2}(0.4)) - (0.8026 + \tfrac{1}{2}(0.4)(0.3974)) \\
    &= 0.5179, \\
    k_3 &= f(t_3 + \tfrac{1}{2}h, y_3 + \tfrac{1}{2} hk_2) \\
    &= (1.2 + \tfrac{1}{2}(0.4)) - (0.8026 + \tfrac{1}{2}0.4(0.5179)) \\
    &= 0.4938, \\
    k_4 &= f(t_3 + h, y_3 + hk_3) \\
    &= (1.2 + 0.4) - (0.8026 + 0.4(0.4938)) \\
    &= 0.4938, \\
    y_4 &= y_3 + \frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\
    &= 0.8026 + \frac{0.4}{6} (0.3974 + 2(0.5179) + 2(0.4938) + 0.5999) \\
    &= 1.0040, \\
    \\
    k_1 &= f(t_4, y_4) = (1.6) - (1.0040) = 0.5960, \\
    k_2 &= f(t_4 + \tfrac{1}{2}h, y_4 + \tfrac{1}{2}hk_1) \\
    &= (1.6 + \tfrac{1}{2}(0.4)) - (1.0040 + \tfrac{1}{2}(0.4)(0.5960)) \\
    &= 0.6768, \\
    k_3 &= f(t_4 + \tfrac{1}{2}h, y_4 + \tfrac{1}{2} hk_2) \\
    &= (1.6 + \tfrac{1}{2}(0.4)) - (1.0040 + \tfrac{1}{2}0.4(0.6768)) \\
    &= 0.6607, \\
    k_4 &= f(t_4 + h, y_4 + hk_3) \\
    &= (1.6 + 0.4) - (1.0040 + 0.4(0.6607)) \\
    &= 0.6607, \\
    y_5 &= y_4 + \frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\
    &= 1.0040 + \frac{0.4}{6} (0.5960 + 2(0.6768) + 2(0.6607) + 0.7318) \\
    &= 1.2708.
\end{align*}
\sphinxAtStartPar
The solution for \(y_n\) are the same as that using the method derived in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-5}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.5}}}} function showing that it is equivalent the RK4 method.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.10}

\sphinxAtStartPar
Define a Python function called \sphinxcode{\sphinxupquote{myrk4()}} which uses the method from {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-5}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.5}}}} to solve an initial value problem. Use your function to solve the initial value problem in {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-6}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.6}}}}. The exact solution is \(y = t + 2e^{-t} - 1\), produce a plot comparing your numerical solutions using the \sphinxcode{\sphinxupquote{myrk2()}} from {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-7}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.7}}}} and \sphinxcode{\sphinxupquote{myrk4()}} functions and the exact solutions on the same set of axes.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{myrk4}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.2} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.2} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{k3} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.75} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{31}\PYG{o}{/}\PYG{l+m+mi}{32} \PYG{o}{*} \PYG{n}{k1} \PYG{o}{+} \PYG{l+m+mi}{55}\PYG{o}{/}\PYG{l+m+mi}{32} \PYG{o}{*} \PYG{n}{k2}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{k4} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{o}{*} \PYG{n}{k1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{120}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{o}{*} \PYG{n}{k2} \PYG{o}{+} \PYG{l+m+mi}{32}\PYG{o}{/}\PYG{l+m+mi}{11} \PYG{o}{*} \PYG{n}{k3}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{125}\PYG{o}{/}\PYG{l+m+mi}{264} \PYG{o}{*} \PYG{n}{k2} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{/}\PYG{l+m+mi}{33} \PYG{o}{*} \PYG{n}{k3} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{24} \PYG{o}{*} \PYG{n}{k4}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}


\PYG{c+c1}{\PYGZsh{} Define IVP}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Calculate the solution to the IVP}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{myrk4}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot solutions}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myRK4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Plot
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2.5_ERK_Exercises_17_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 2.11}

\sphinxAtStartPar
Use your functions \sphinxcode{\sphinxupquote{myrk2()}} and \sphinxcode{\sphinxupquote{myrk4()}} from {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-7}]{\sphinxcrossref{\DUrole{std,std-ref}{exercises 2.7}}}} and {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-10}]{\sphinxcrossref{\DUrole{std,std-ref}{2.10}}}} to solve the initial value problem from {\hyperref[\detokenize{2_ERKs/2.5_ERK_Exercises:ex2-6}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 2.6}}}} using a range of step lengths starting at \(h=0.4\) and halving each time until \(h=0.025\). Plot the global truncation errors for the numerical solutions for \(y(2)\) against \(h\) on a loglog scale and estimate the order of the two methods.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate solution for decreasing step lengths and plot the solution}
\PYG{n}{h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{]}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{myrk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y\PYGZus{}exact}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{myrk4}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y\PYGZus{}exact}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot errors}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{loglog}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{e}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myRK2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{loglog}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{e}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ro\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myRK4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{log(h)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{log(e\PYGZus{}n)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Output table of errors}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|   h   | myRK2 error | myRK4 error |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{h}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{5.3f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |   }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{0.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{  |   }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{0.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{  |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
    
\PYG{c+c1}{\PYGZsh{} Estimate the order of the methods}
\PYG{n}{order} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{h}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{h}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myRK2 order: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{order}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{0.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myRK4 order: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{order}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{0.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2.5_ERK_Exercises_20_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{|}   \PYG{n}{h}   \PYG{o}{|} \PYG{n}{myRK2} \PYG{n}{error} \PYG{o}{|} \PYG{n}{myRK4} \PYG{n}{error} \PYG{o}{|}
\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.400} \PYG{o}{|}   \PYG{l+m+mf}{2.01e\PYGZhy{}02}  \PYG{o}{|}   \PYG{l+m+mf}{1.61e\PYGZhy{}04}  \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.200} \PYG{o}{|}   \PYG{l+m+mf}{4.23e\PYGZhy{}03}  \PYG{o}{|}   \PYG{l+m+mf}{8.53e\PYGZhy{}06}  \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.100} \PYG{o}{|}   \PYG{l+m+mf}{9.74e\PYGZhy{}04}  \PYG{o}{|}   \PYG{l+m+mf}{4.90e\PYGZhy{}07}  \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.050} \PYG{o}{|}   \PYG{l+m+mf}{2.34e\PYGZhy{}04}  \PYG{o}{|}   \PYG{l+m+mf}{2.94e\PYGZhy{}08}  \PYG{o}{|}

\PYG{n}{myRK2} \PYG{n}{order}\PYG{p}{:} \PYG{l+m+mf}{2.14}
\PYG{n}{myRK4} \PYG{n}{order}\PYG{p}{:} \PYG{l+m+mf}{4.14}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Implicit Runge\sphinxhyphen{}Kutta Methods}
\label{\detokenize{3_IRKs/3.0_IRKs:implicit-runge-kutta-methods}}\label{\detokenize{3_IRKs/3.0_IRKs:irk-chapter}}\label{\detokenize{3_IRKs/3.0_IRKs::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
determine the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:order-of-irk-section}]{\sphinxcrossref{\DUrole{std,std-ref}{order of an implicit Runge\sphinxhyphen{}Kutta method}}}};

\item {} 
\sphinxAtStartPar
derive {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:gauss-legendre-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Legendre}}}}, {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:radau-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{Radau}}}}, {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:dirk-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{DIRK}}}} and {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:sdirk-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{SDIRK}}}} implicit Runge\sphinxhyphen{}Kutta methods;

\item {} 
\sphinxAtStartPar
apply {\hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-ivps-using-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{implicit Runge\sphinxhyphen{}Kutta methods to solve initial value problems}}}}.

\end{itemize}


\bigskip\hrule\bigskip



\section{Implicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{3_IRKs/3.0_IRKs:id1}}
\sphinxAtStartPar
Runge\sphinxhyphen{}Kutta methods can be either an explicit or implicit methods depending on the functions used to calculate the stage values. We have seen in the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:erk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{previous chapter on explicit methods}}}} that they are straightforward to apply, however they are not always suitable for solving ODEs that are {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-section}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{stiff}}}}}. This is why we need to also consider implicit methods.

\sphinxAtStartPar
Recall that the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{general form of a Runge\sphinxhyphen{}Kutta method}}}} to solve a first\sphinxhyphen{}order ODE \(y'=f(t,y)\) is
\begin{align*}
   y_{n+1} &=y_n + h \sum_{i=1}^s b_i k_i,\\
   k_i &=f(t_n +c_i h,y_n + h \sum_{j=1}^s a_{ij} k_j).
\end{align*}
\sphinxAtStartPar
Expanding out the stage value functions we have
\begin{align*}
    k_1 &= f(t_n + c_1 h, y_n + h (a_{11} k_1 + a_{12} k_2 + \cdots + a_{1s} k_s), \\
    k_2 &= f(t_n + c_2 h, y_n + h (a_{21} k_1 + a_{22} k_2 + \cdots + a_{2s} k_s), \\
    & \vdots \\
    k_s &= f(t_n + c_1 h, y_n + h (a_{s1} k_1 + a_{s2} k_2 + \cdots + a_{ss} k_s).
\end{align*}
\sphinxAtStartPar
The value of \(k_1\) appears withing the function on the right\sphinxhyphen{}hand side of \(k_1\) and similar for the other stage values. This means these functions are implicit functions hence we have an implicit Runge\sphinxhyphen{}Kutta method. The Butcher tableau for an implicit method is
\begin{align*}
   \begin{array}{c|cccc}
      c_1  & a_{11}  & a_{12}  & \cdots  & a_{1s} \\
      c_2  & a_{21}  & a_{22}  & \cdots  & a_{2s} \\
      \vdots  & \vdots  & \vdots  & \ddots  & \vdots \\
      c_s  & a_{s1}  & a_{s2}  & \cdots  & a_{ss} \\ \hline
       & b_1  & b_2  & \cdots  & b_s 
      \end{array}
\end{align*}
\sphinxAtStartPar
Note that the \(A\) matrix in the upper right\sphinxhyphen{}hand region of an implicit method can have non\sphinxhyphen{}zero elements in them main diagonal and upper triangular region whereas the \(A\) matrix for an explicit method has non\sphinxhyphen{}zero elements in the lower triangular region only.


\section{Determining the order of an implicit Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{3_IRKs/3.0_IRKs:determining-the-order-of-an-implicit-runge-kutta-method}}\label{\detokenize{3_IRKs/3.0_IRKs:order-of-irk-section}}
\sphinxAtStartPar
One of the differences between implicit and explicit methods is that an implicit method can achieve the same accuracy as an explicit method but using fewer stages. To determine the order of an implicit method we need to consider the \sphinxstylestrong{order conditions} that govern the values of \(a_{ij}\), \(b_i\) and \(c_i\).

\begin{sphinxadmonition}{note}{Definition: \protect\(B(k)\protect\), \protect\(C(k)\protect\) and \protect\(D(k)\protect\) order conditions }
\begin{align*}
  B(k): && \sum_{i=1}^s b_i c_i^{j-1} = & \frac{1}{j}, & j&=1\ldots k, \\
  C(k): && \sum_{j=1}^s a_{ij} c_j^{\ell-1} = & \frac{1}{\ell}c_i^{\ell} , & i&=1 \ldots s, & \ell &=1 \ldots k,\\
  D(k): && \sum_{i=1}^s b_i c_i^{\ell-1} a_{ij} = & \frac{1}{\ell}b_j (1-c_j^{\ell}), & j&=1 \ldots s, & \ell &=1 \ldots k.
\end{align*}\end{sphinxadmonition}

\sphinxAtStartPar
If \(G(k)\) represents the fact that a given implicit method has order \(k\) then it can be shown that
\begin{equation*}
\begin{split}B(k)\; \mathsf{and} \; C(\lfloor \frac{k}{2} \rfloor ) \; \mathsf{and} \; D(\lfloor \frac{k}{2} \rfloor ) \Longrightarrow G(k)\end{split}
\end{equation*}
\sphinxAtStartPar
So to determine the order of an IRK method we need to do the following
\begin{itemize}
\item {} 
\sphinxAtStartPar
Find the highest value of \(k\) for which \(B(k)\) is satisfied;

\item {} 
\sphinxAtStartPar
If \(C(\lfloor \frac{k}{2} \rfloor)\) and \(D(\lfloor \frac{k}{2} \rfloor)\) are satisfied
\begin{itemize}
\item {} 
\sphinxAtStartPar
the IRK has order \(k\);

\end{itemize}

\item {} 
\sphinxAtStartPar
else
\begin{itemize}
\item {} 
\sphinxAtStartPar
reduce \(k\) by 1 and check \(C(\lfloor \frac{k}{2} \rfloor)\) and \(D(\lfloor \frac{k}{2} \rfloor)\) again.

\end{itemize}

\end{itemize}

\sphinxAtStartPar
If no value of \(k>0\) satisfies \(B(k)\), \(C(\lfloor \frac{k}{2} \rfloor)\) and \(D(\lfloor \frac{k}{2} \rfloor)\) then it isnâ€™t a valid Runge\sphinxhyphen{}Kutta method.

\begin{sphinxadmonition}{note}{Example 3.1}

\sphinxAtStartPar
Determine the order of the following IRK method
\begin{align*}
    \begin{array}{c|cc}
          \frac{1}{4} & \frac{1}{4} & 0 \\
          \frac{3}{4} & \frac{1}{2} & \frac{1}{4} \\ \hline
          & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Checking the \(B(k)\) order condition:
\begin{align*}
  j &=1: & LHS &= b_1 c_1^0 + b_2 c_2^0 = \frac{1}{2}(1)+\frac{1}{2}(1)=1, \\
  && RHS &= 1,\\
  j &=2: & LHS &= b_1 c_1^1 + b_2 c_2^1 = \frac{1}{2}\left(\frac{1}{4}\right)+\frac{1}{2}\left(\frac{3}{4}\right)=\frac{1}{2}, \\
  && RHS &= \frac{1}{2},\\
  j &=3: & LHS &= b_1 c_1^2 + b_2 c_2^2 = \frac{1}{2}{\left(\frac{1}{4}\right)}^2 +\frac{1}{2}{\left(\frac{3}{4}\right)}^2 = \frac{5}{16}, \\
  && RHS &= \frac{1}{3}.
\end{align*}
\sphinxAtStartPar
So since \(LHS=RHS\) up to \(j=2\) the \(B(2)\) condition is satisfied. Now we need to check whether \(C(\lfloor \frac{2}{2} \rfloor)=C(1)\) order condition is satisfied. Note that here \(\ell=1\) so we only need to check \(i = 1\) and \(2\) but if \(k \geq 2\) then we would need to check \(i = 1, 2, \ldots, s\) for each \(\ell = 1, 2, \ldots\).
\begin{align*}
  i &= 1, & LHS&=a_{11} c_1^0 + a_{12} c_2^0 =\frac{1}{4}(1)+0(1)=\frac{1}{4}, \\
  && RHS &= \frac{1}{\ell}c_1^{\ell} =\frac{1}{4},\\
  i &= 2, & LHS&=a_{21} c_1^0 + a_{22} c_2^0 =\frac{1}{2}(1)+\frac{1}{4}(1)=\frac{3}{4}, \\
  && RHS &= \frac{1}{\ell}c_2^{\ell} =\frac{3}{4}.
\end{align*}
\sphinxAtStartPar
So the \(C(1)\) order condition is satisfied. Now we need to check whether the \(D(1)\) order condition is satisfied
\begin{align*}
  j &= 1, & LHS &= b_1 c_1^0 a_{11} +b_2 c_2^0 a_{21} =\frac{1}{2}(1)\left(\frac{1}{4}\right)+\frac{1}{2}(1)\left(\frac{1}{2}\right)=\frac{3}{8},\\
  && RHS &= \frac{1}{\ell}b_1 (1-c_1^{\ell})=\frac{1}{2}\left(1-\frac{1}{4}\right)=\frac{3}{8},\\
  j&=2, & LHS&=b_1 c_1^0 a_{12} +b_2 c_2^0 a_{22} =\frac{1}{2}(1)(0)+\frac{1}{2}(1)\left(\frac{1}{4}\right)=\frac{1}{8},\\
  && RHS&=\frac{1}{\ell }b_2 (1 - c_2^{\ell})=\frac{1}{2}\left(1-\frac{3}{4}\right)=\frac{1}{8}.
\end{align*}
\sphinxAtStartPar
So the \(D(k)\) order condition is satisfied up to \(k=2\). Therefore since \(B(2)\), \(C(1)\) and \(D(1)\) are all satisfied this IRK method is order 2.
\end{sphinxadmonition}

\sphinxstepscope


\section{Deriving implicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:deriving-implicit-runge-kutta-methods}}\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:deriving-irk-methods-section}}\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods::doc}}
\sphinxAtStartPar
There are several types of implicit Runge\sphinxhyphen{}Kutta methods which are derived using the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(B(k)\), \(C(k)\) and \(D(k)\) order conditions}}}} along with the {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:row-sum-condition}]{\sphinxcrossref{\DUrole{std,std-ref}{row sum condition}}}}.


\subsection{Gauss\sphinxhyphen{}Legendre methods}
\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:gauss-legendre-methods}}\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:gauss-legendre-derivation}}
\sphinxAtStartPar
Gauss\sphinxhyphen{}Legendre methods are a family of methods that are derived using \sphinxhref{https://en.wikipedia.org/wiki/Gauss\%E2\%80\%93Legendre\_quadrature}{Gauss\sphinxhyphen{}Legendre quadrature}. An \(s\)\sphinxhyphen{}stage Gauss\sphinxhyphen{}Legendre method has order \(k=2s\). They are derived using \sphinxhref{https://en.wikipedia.org/wiki/Legendre\_polynomials}{Legendre polynomials} which are are a system of orthogonal polynomials.

\begin{sphinxadmonition}{note}{Definition: Legendre polynomials}
\label{equation:3_IRKs/3.1_Deriving_IRK_methods:fde7546e-5b9c-4551-b0c5-d078374f13df}\begin{align}
   P_n (t)=\sum_{k=0}^n \binom{n}{k}\binom{n+k}{k}(t-1)^k,
\end{align}
\sphinxAtStartPar
where \(\displaystyle\binom{n}{k}\) is the \sphinxhref{https://en.wikipedia.org/wiki/Binomial\_coefficient}{binomial coefficient}.
\end{sphinxadmonition}

\sphinxAtStartPar
The values of the \(c_i\) coefficients in a Gauss\sphinxhyphen{}Legendre method are the roots of \(P_s(t)\), the values of the \(b_i\) coefficients are chosen to satisfy the \(B(k)\) condition and the \(a_{ij}\) coefficients are chosen to satisfy the \(C(\lfloor \frac{k}{2} \rfloor)\) condition.

\begin{sphinxadmonition}{note}{Example 3.2}

\sphinxAtStartPar
Derive a fourth\sphinxhyphen{}order Gauss\sphinxhyphen{}Legendre method.
\subsubsection*{Solution}

\sphinxAtStartPar
A fourth\sphinxhyphen{}order Gauss\sphinxhyphen{}Legendre method will have \(s = \frac{k}{2} = \frac{4}{2} = 2\) stages and the \(c_i\) coefficients are chosen to satisfy \(0=P_2(t)\)
\begin{align*}
    0&=\binom{2}{0}\binom{2}{0}(t-1)^0 +\binom{2}{1}\binom{3}{1}(t-1)^1 +\binom{2}{2}\binom{4}{2}(t-1)^2 \\
    &=1 + 6t - 6 + 6t^2 - 12t + 6\\
    &=6t^2 - 6t+1,
\end{align*}
\sphinxAtStartPar
therefore
\begin{align*} 
    c_1 &= \frac{1}{2} - \frac{\sqrt{3}}{6}, \\
    c_2 &= \frac{1}{2} + \frac{\sqrt{3}}{6}.
\end{align*}
\sphinxAtStartPar
The \(b_i\) and \(a_{ij}\) coefficients are chosen to satisfy the \(B(4)\) and \(C(2)\) order conditions respectively
\begin{align*}
    b_1 + b_2 = & 1,\\
    b_1 c_1 + b_2 c_2 = & \frac{1}{2},\\
    a_{11} + a_{12} = & c_1 ,\\
    a_{21} + a_{22} = & c_2 ,\\
    a_{11} c_1 + a_{12} c_2 = & \frac{1}{2}c_1^2 ,\\
    a_{21} c_1 + a_{22} c_2 = & \frac{1}{2}c_2^2 .
\end{align*}
\sphinxAtStartPar
Using SymPy to solve the order conditions

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define symbolic variables}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{a11}\PYG{p}{,} \PYG{n}{a12}\PYG{p}{,} \PYG{n}{a21}\PYG{p}{,} \PYG{n}{a22}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYGZbs{}
    \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t, a11, a12, a21, a22, b1, b2, c1, c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate c values}
\PYG{n}{P} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{binomial}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{binomial}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYGZbs{}
    \PYG{o}{+} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{binomial}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{binomial}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{a11} \PYG{o}{+} \PYG{n}{a12} \PYG{o}{\PYGZhy{}} \PYG{n}{c1}
\PYG{n}{eq4} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{+} \PYG{n}{a22} \PYG{o}{\PYGZhy{}} \PYG{n}{c2}
\PYG{n}{eq5} \PYG{o}{=} \PYG{n}{a11} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{+} \PYG{n}{a12} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{eq6} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{+} \PYG{n}{a22} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{,} \PYG{n}{eq4}\PYG{p}{,} \PYG{n}{eq5}\PYG{p}{,} \PYG{n}{eq6}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Gives the solution
\begin{align*}
    a_{11} &= \frac{1}{4}, &
    a_{12} &= \frac{1}{4} - \frac{\sqrt{3}}{6}, &
    a_{21} &= \frac{1}{4} + \frac{\sqrt{3}}{6}, \\
    a_{22} &= \frac{1}{4}, &
    b_1 &= \frac{1}{2}, &
    b_2 &= \frac{1}{2},
\end{align*}
\sphinxAtStartPar
so the fourth\sphinxhyphen{}order Gauss\sphinxhyphen{}Legendre method is
\begin{align*}
    \begin{array}{c|cc}
        \frac{1}{2} - \frac{\sqrt{3}}{6} & \frac{1}{4} & \frac{1}{4} - \frac{\sqrt{3}}{6} \\
        \frac{1}{2} + \frac{\sqrt{3}}{6} & \frac{1}{4} + \frac{\sqrt{3}}{6} & \frac{1}{4} \\ \hline
        & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}\end{sphinxadmonition}


\subsection{Radau methods}
\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:radau-methods}}\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:radau-derivation}}
\sphinxAtStartPar
Gauss\sphinxhyphen{}Legendre methods give us maximal order for the number of stages, however sometimes it is better the sacrifice order to gain better stability properties. An \(s\)\sphinxhyphen{}stage Radau method has order \(k=2s-1\) and is A\sphinxhyphen{}stable (see {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stability}}}}. There are two types of Radau methods: Radau IA and Radau IIA.
\begin{itemize}
\item {} 
\sphinxAtStartPar
For a \sphinxstylestrong{Radau IA} method the \(c_i\) values are the roots of \(0 = P_s(t) + P_{s-1}(t)\) and the values of \(a_{ij}\) and \(b_i\) satisfy the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(D(k)\) order condition}}}}.

\item {} 
\sphinxAtStartPar
For a \sphinxstylestrong{Radau IIA} method the \(c_i\) values are the roots of \(0 = P_s(t) - P_{s-1}(t)\) and the values of \(a_{ij}\) and \(b_i\) satisfy the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(C(k)\) order condition}}}}.

\end{itemize}

\begin{sphinxadmonition}{note}{Example 3.3}

\sphinxAtStartPar
Derive a third\sphinxhyphen{}order Radau IA method.
\subsubsection*{Solution}

\sphinxAtStartPar
An order \(k=3\) Radau IA method will have \(s=\frac{k + 1}{2} = \frac{3 + 1}{4} = 2\) stages. The values of \(c_1\) and \(c_2\) are the roots of \(0=P_2(t)+P_1(t)\)
\begin{align*}
    0 = (6t^2 -6t+1)+(2t-1) = 6t^2 -4t = 2t(3t - 2),
\end{align*}
\sphinxAtStartPar
so \(c_1 = 0\) and \(c_2 = \frac{2}{3}\). The values of \(b_i\) and \(a_{ij}\) need to satisfy the \(B(4)\) and \(D(2)\) order conditions respectively. Substituting the values of \(c_1\) and \(c_2\) give
\begin{align*}
    b_1 + b_2 &= 1, \\
    \tfrac{2}{3}b_2 &= \tfrac{1}{2}, \\
    b_1 a_{11} + b_2 a_{21} &= b_1 (1 - 0), \\
    b_1 a_{12} + b_2 a_{22} &= b_2 (1 - \tfrac{2}{3}), \\
    \tfrac{2}{3} b_2 a_{21} &= \tfrac{1}{2} b_1 (1 - 0^2), \\
    \tfrac{2}{3} b_2 a_{22} &= \tfrac{1}{2} b_2 (1 - (\tfrac{2}{3})^2).
\end{align*}
\sphinxAtStartPar
From the second equation we have \(b_2 = \frac{3}{4}\) and from the first we have \(b_1 = \frac{1}{4}\). The fifth equation is now \(\frac{1}{2} a_{21} = \frac{1}{8}\) so \(a_{21} = \frac{1}{4}\) and the sixth equation is \(\frac{1}{2} a_{22} = \frac{5}{25}\) so \(a_{22} = \frac{5}{12}\). The third equation is now \(\frac{1}{4} a_{11} + \frac{3}{4} (\frac{1}{4}) = \frac{1}{4}\) so \(a_{11} = \frac{1}{4}\) and the fourth equation is \(\frac{1}{4} a_{12} + \frac{3}{4}(\frac{5}{12}) = \frac{3}{4} (\frac{1}{3}) = -\frac{1}{4}\).

\sphinxAtStartPar
So the third\sphinxhyphen{}order Radau IA method is
\begin{align*}
    \begin{array}{c|cc}
        0 & \tfrac{1}{4} & -\tfrac{1}{4} \\
        \tfrac{2}{3} & \tfrac{1}{4} & \frac{5}{12} \\ \hline
        & \tfrac{1}{4} & \tfrac{3}{4}
    \end{array}
\end{align*}\end{sphinxadmonition}


\subsection{DIRK methods}
\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:dirk-methods}}\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:dirk-derivation}}
\sphinxAtStartPar
\sphinxstylestrong{Diagonally Implicit Runge\sphinxhyphen{}Kutta (DIRK)} methods have an \(A\) matrix that is lower triangular with non\sphinxhyphen{}zero elements on the main diagonal
\begin{align*}
   \begin{array}{c|ccccc}
      c_1 & a_{11} \\
      c_2 & a_{21} & a_{22} \\
      c_3 & a_{31} & a_{32} & a_{33} \\
      \vdots & \vdots & \vdots & \ddots & \ddots \\
      c_s & a_{s1} & a_{s2} & \cdots & a_{s,s-1} & a_{ss} \\ \hline
      & b_1 & b_2 & \cdots & b_{s-1} & b_s
   \end{array}
\end{align*}
\sphinxAtStartPar
Writing out the stage values for a DIRK method
\begin{align*}
   k_1 &= f(t_n + c_1h, y_n + a_{11}hk_1), \\
   k_2 &= f(t_n + c_2h, y_n + h(a_{21}k_1 + a_{22}k_2)), \\
   k_3 &= f(t_n + c_3h, y_n + h(a_{31}k_1 + a_{32}k_2 + a_{33}k_3)), \\
   & \vdots \\
   k_s &= f(t_n + c_sh, y_n + h(a_{s1}k_1 + a_{s2}k_2 + a_{s3}k_3 + \cdots + a_{ss}k_s)),
\end{align*}
\sphinxAtStartPar
we see that whilst these are still implicit equations, there is only one unknown in each one, i.e., the equation for \(k_i\) does not include \(k_{i+1} \dots k_s\). So the advantage of DIRK methods is that the solutions to these can be obtained sequentially and is more computationally efficient than non\sphinxhyphen{}DIRK methods.

\sphinxAtStartPar
The coefficients of a \(k\)th\sphinxhyphen{}order DIRK method are chosen to satisfy the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(B(k)\) and \(C(\lfloor \frac{k}{2} \rfloor)\) order conditions}}}} along with
\begin{equation}\label{equation:3_IRKs/3.1_Deriving_IRK_methods:dirk-order-condition}
\begin{split}\mathbf{b}^T A\mathbf{c}=\frac{1}{k!}\end{split}
\end{equation}
\begin{sphinxadmonition}{note}{Example 3.4}

\sphinxAtStartPar
Derive a 2\sphinxhyphen{}stage third\sphinxhyphen{}order DIRK method.
\subsubsection*{Solution}

\sphinxAtStartPar
Since \(k = 2\) and \(a_{11} = c_1\) and \(a_{12} = 0\) the \(B(k)\) and \(C(k)\) order conditions are
\begin{equation}\label{equation:3_IRKs/3.1_Deriving_IRK_methods:dirk-order-conditions-1}
\begin{split}b_1 + b_2  & = 1,\\
b_1 c_1 + b_2 c_2  & = \frac{1}{2},\\
b_1 c_1^2 + b_2 c_2^2  & = \frac{1}{3},\\
a_{21} + a_{22}  & = c_2.\end{split}
\end{equation}
\sphinxAtStartPar
We also have equation \eqref{equation:3_IRKs/3.1_Deriving_IRK_methods:dirk-order-condition} which is
\begin{equation}\label{equation:3_IRKs/3.1_Deriving_IRK_methods:dirk-order-conditions-2}
\begin{split}\begin{pmatrix} b_1 & b_2 \end{pmatrix}
\begin{pmatrix} a_{11} & 0 \\ a_{21} & a_{22} \end{pmatrix} 
\begin{pmatrix} c_1 \\ c_2 \end{pmatrix} &= \frac{1}{6} \\
b_1 a_{11} c_1 + b_2(a_{21} c_1 + a_{22} c_2)  &= \frac{1}{6} \\
b_1 c_1^2 + b_2(a_{21} c_1 + a_{22} c_2) &= \frac{1}{6}\end{split}
\end{equation}
\sphinxAtStartPar
Equations \eqref{equation:3_IRKs/3.1_Deriving_IRK_methods:dirk-order-conditions-1} and \eqref{equation:3_IRKs/3.1_Deriving_IRK_methods:dirk-order-conditions-2} give a system of 5 equations in 6 unknowns. If we let \(c_1 = a_{11} = \frac{1}{4}\) (this choice is arbitrary) then we can solve for the other coefficients which give
\begin{align*}
  a_{21} &= \frac{2}{3}, &
  a_{22} &= \frac{1}{6}, &
  b_1 &= \frac{4}{7}, \\
  b_2 &= \frac{3}{7}, &
  c_2 &= \frac{5}{6},
\end{align*}
\sphinxAtStartPar
so the DIRK method is
\begin{align*}
  \begin{array}{c|cc}
        \frac{1}{4} & \frac{1}{4} \\
        \frac{5}{6} & \frac{2}{3} & \frac{1}{6} \\ \hline
        & \frac{4}{7} & \frac{3}{7}
  \end{array}
\end{align*}\end{sphinxadmonition}


\subsection{SDIRK methods}
\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:sdirk-methods}}\label{\detokenize{3_IRKs/3.1_Deriving_IRK_methods:sdirk-derivation}}
\sphinxAtStartPar
\sphinxstylestrong{Singly Diagonally Implicit Runge\sphinxhyphen{}Kutta (SDIRK)} methods are a variation on DIRK method with the additional condition that the elements on the main diagonal have the same value (i.e., \(a_{ii} = c_1\))
\begin{align*}
   \begin{array}{c|ccccc}
      c_1 & c_1 \\
      c_2 & a_{21} & c_1 \\
      c_3 & a_{31} & a_{32} & c_1 \\
      \vdots & \vdots & \vdots & \ddots & \ddots \\
      c_s & a_{s1} & a_{s2} & \cdots & a_{s,s-1} & c_1 \\ \hline
      & b_1 & b_2 & \cdots & b_{s-1} & b_s
   \end{array}
\end{align*}
\sphinxAtStartPar
The advantage that SDIRK methods is that they can be {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stable}}}} for certain values of \(c_i\). The derivation of an \(k\)th\sphinxhyphen{}order SDIRK method uses the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(B(k)\), \(C(\lfloor \frac{k}{2} \rfloor)\) and \(D(\lfloor \frac{k}{2} \rfloor)\) order conditions}}}}.

\begin{sphinxadmonition}{note}{Example 3.5}

\sphinxAtStartPar
Derive a 2\sphinxhyphen{}stage third\sphinxhyphen{}order SDIRK method.
\subsubsection*{Solution}

\sphinxAtStartPar
Since \(a_{11} = a_{22} = c_1\) the order conditions are
\begin{align*}
    b_1 +b_2  & =1,\\
    b_1 c_1 +b_2 c_2  & =\frac{1}{2},\\
    b_1 c_1^2 +b_2 c_2^2  & =\frac{1}{3},\\
    a_{21} +c_1  & =c_2 ,\\
    b_1 c_1^2 +b_2 (a_{21} c_1 +c_1 c_2 ) & =\frac{1}{6}.
\end{align*}
\sphinxAtStartPar
Here we have 5 equations in 5 unknowns. Solving these give
\begin{align*}
  a_{11} &= \frac{1}{2} \mp \frac{\sqrt{3}}{6}, &
  a_{21} &= \pm \frac{\sqrt{3}}{3},  &
  b_1 &= \frac{1}{2}, \\
  b_2 &= \frac{1}{2},  &
  c_2 &= \frac{1}{2} \pm \frac{\sqrt{3}}{6}.
\end{align*}
\sphinxAtStartPar
Note that here we have two equivalent SDIRK methods alternating the sign of the \(\sqrt{3}\) term
\begin{align*}
  \begin{array}{c|cc}
     \frac{1}{2} - \frac{\sqrt{3}}{6} & \frac{1}{2} - \frac{\sqrt{3}}{6} & 0 \\
     \frac{1}{2} + \frac{\sqrt{3}}{6} & \frac{\sqrt{3}}{3} & \frac{1}{2} - \frac{\sqrt{3}}{6} \\ \hline
     & \frac{1}{2} & \frac{1}{2}
  \end{array}
\end{align*}\end{sphinxadmonition}

\sphinxstepscope


\section{Solving initial value problems using implicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-initial-value-problems-using-implicit-runge-kutta-methods}}\label{\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-ivps-using-irk-methods-section}}\label{\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods::doc}}
\sphinxAtStartPar
Recall that the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{general form of a Runge\sphinxhyphen{}Kutta method}}}} is
\begin{align*}
   y_{n+1} &= y_n + h \sum_{i=1}^s b_i k_i,\\
   k_i &= f(t_n +c_i h,y_n + h \sum_{j=1}^s a_{ij} k_j).
\end{align*}
\sphinxAtStartPar
To help simplify the calculations we let
\begin{equation}\label{equation:3_IRKs/3.2_Solving_IVPs_using_IRK_methods:Yi-equation}
\begin{split}Y_i = y_n +h \displaystyle\sum_{j=1}^s a_{ij} k_j\end{split}
\end{equation}
\sphinxAtStartPar
then we can write these equations as
\begin{align*}
   y_{n+1} &= y_n + h \sum_{i=1}^s b_i f(t_n + c_i h, Y_i),\\
   Y_i &= y_n + h \sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j).
\end{align*}
\sphinxAtStartPar
Expanding the summation in equation \eqref{equation:3_IRKs/3.2_Solving_IVPs_using_IRK_methods:Yi-equation} for each stage gives
\begin{equation}\label{equation:3_IRKs/3.2_Solving_IVPs_using_IRK_methods:irk-stage-values-equation}
\begin{split}\begin{align*}
    Y_1 &= y_n + h(a_{11} f(t_n + c_1 h, Y_1) + a_{12} f(t_n + c_2 h, Y_2) + \cdots + a_{1s} f(t_n + c_s h, Y_s)), \\
    Y_2 &= y_n + h(a_{21} f(t_n + c_1 h, Y_1) + a_{22} f(t_n + c_2 h, Y_2) + \cdots + a_{2s} f(t_n + c_s h, Y_s)), \\
    & \vdots \\
    Y_s &= y_n + h(a_{s1} f(t_n + c_1 h, Y_1) + a_{s2} f(t_n + c_2 h, Y_2) + \cdots + a_{ss} f(t_n + c_s h, Y_s)), \\
\end{align*}\end{split}
\end{equation}
\sphinxAtStartPar
The values of \(Y_1, Y_2, \ldots, Y_s\) are found by solving this system of equations. One way to do this is to estimate the values of \(Y_i\) by assigning each a value and use the equations \eqref{equation:3_IRKs/3.2_Solving_IVPs_using_IRK_methods:irk-stage-values-equation} to calculate improved estimates. If we repeat this enough times then our estimations of \(Y_i\) will be close to the actual values of \(Y_i\). We cease iterations when the largest difference between two successive estimates is small
\begin{equation*}
\begin{split}\max_i| Y_i^{(k+1)} - Y_i^{(k)}| < tol\end{split}
\end{equation*}
\sphinxAtStartPar
where \(Y_i^{(k+1)}\) and \(Y_i^{(k)}\) are the new and old estimates respectively and \(tol\) is a \sphinxstylestrong{convergence tolerance}. The value of \(tol\) is arbitrary but we need it to be small enough to give good estimates of \(Y_i\) but not so small that we are spending too much time calculating the iterations. A common default value for the tolerance is \(tol=10^{-6}\).

\begin{sphinxadmonition}{note}{Example 3.6}

\sphinxAtStartPar
The third\sphinxhyphen{}order Radau IA implicit Runge\sphinxhyphen{}Kutta method is defined by the following Butcher tableau
\begin{align*}
   \begin{array}{c|cc}
      0 & \frac{1}{4} & -\frac{1}{4} \\
      \frac{2}{3} & \frac{1}{4} & \frac{5}{12} \\ \hline
      & \frac{1}{4} & \frac{3}{4}
    \end{array}
\end{align*}
\sphinxAtStartPar
Use this method to calculate the solution of the following initial value problem using a step length of \(h=0.2\) and a convergence tolerance of \(tol=10^{-4}\).
\begin{align*}
    y' = ty, \qquad t\in [0,1], \qquad y(0)=1.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
The stage values for the implicit method are
\begin{align*}
    Y_1 &= y_n + h(\tfrac{1}{4} f(t_n, Y_1) - \tfrac{1}{4} f(t_n + \tfrac{2}{3}h, Y_2)), \\
    Y_2 &= y_n + h(\tfrac{1}{4} f(t_n, Y_1) + \tfrac{5}{12} f(t_n + \tfrac{2}{3}h, Y_2))
\end{align*}
\sphinxAtStartPar
and since \(f(t, y) = ty\) then
\begin{align*}
    Y_1 &= y_n + h(\tfrac{1}{4} t_n Y_1 - \tfrac{1}{4} (t_n + \tfrac{2}{3}h) Y_2), \\
    Y_2 &= y_n + h(\tfrac{1}{4} t_n Y_1 + \tfrac{5}{12} (t_n + \tfrac{2}{3}h) Y_2).
\end{align*}
\sphinxAtStartPar
If we use the initial estimates \(Y_1 = Y_2 = 1\) then an improved estimate is
\begin{align*}
    Y_1 &= 1 + 0.2(\tfrac{1}{4} (0)(1) - \tfrac{1}{4} (0 + \tfrac{2}{3}(0.2)(1)) = 0.993333, \\
    Y_2 &= 1 + 0.2(\tfrac{1}{4} (0)(0.993333) + \tfrac{5}{12} (0 + \tfrac{2}{3}(0.2)(1)) = 1.011111.
\end{align*}
\sphinxAtStartPar
The maximum difference between the new and old estimates are
\begin{align*}
    \max(|0.993333 - 1|, |1.011111 - 1|) = 0.011111.
\end{align*}
\sphinxAtStartPar
Our convergence tolerance is \(tol=10^{-4}\) and since \(0.011111 > 10^{-4}\) our estimates are not close enough to the actual values of \(Y_1\) and \(Y_2\) so we calculate the estimates again.
\begin{align*}
    Y_1 &= 1 + 0.2(\tfrac{1}{4} (0)(0.993333) - \tfrac{1}{4} (0 + \tfrac{2}{3}(0.2)(1.011111)) = 0.993259, \\
    Y_2 &= 1 + 0.2(\tfrac{1}{4} (0)(0.993259) + \tfrac{5}{12} (0 + \tfrac{2}{3}(0.2)(1.011111)) = 1.011235.
\end{align*}
\sphinxAtStartPar
The difference between the new and old estimates are now
\begin{align*}
    \max(|0.993333 - 0.993259|, |1.011111 - 1.011235|) = 0.000123,
\end{align*}
\sphinxAtStartPar
and since \(0.000123 > 10^{-4}\) the estimates are still not accurate enough so we calculate the estimates again.
\begin{align*}
    Y_1 &= 1 + 0.2(\tfrac{1}{4} (0)(0.993259) - \tfrac{1}{4} (0 + \tfrac{2}{3}(0.2)(1.011235)) = 0.993258, \\
    Y_2 &= 1 + 0.2(\tfrac{1}{4} (0)(0.993258) + \tfrac{5}{12} (0 + \tfrac{2}{3}(0.2)(1.011235)) = 1.011236.
\end{align*}
\sphinxAtStartPar
The difference between the new and old estimates are now
\begin{align*}
    \max(|0.993259 - 0.993258|, |1.011235 - 1.011236|) = 0.000001,
\end{align*}
\sphinxAtStartPar
and since \(0.000001 < 10^{-4}\) so we are now satisfied that \(Y_1 = 0.993258\) and \(Y_2 = 1.011236\). The solution over a single step is
\begin{align*}
    y_{n+1} &= y_n + h (\tfrac{1}{4} f(t_n, Y_1) + \tfrac{3}{4} f(t_n + \tfrac{2}{3}h, Y_2)), \\
    &= y_n + h (\tfrac{1}{4} t_n Y_1 + \tfrac{3}{4} (t_n + \tfrac{2}{3}h)Y_2),
\end{align*}
\sphinxAtStartPar
so
\begin{align*}
    y_1 &= 1 + 0.2(\tfrac{1}{4}(0)(0.993258) + \tfrac{3}{4}(\tfrac{2}{3}(0.2)(1.011236)) = 1.020225.
\end{align*}
\sphinxAtStartPar
The values of \(t_n\), \(y_n\), \(Y_1\) and \(Y_2\) for the full domain are tabulated below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(n\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t_n\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_n\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(Y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(Y_2\)
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
1.0000
&
\sphinxAtStartPar
0.9933
&
\sphinxAtStartPar
1.0112
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
1.0202
&
\sphinxAtStartPar
1.0127
&
\sphinxAtStartPar
1.0598
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
1.0833
&
\sphinxAtStartPar
1.0740
&
\sphinxAtStartPar
1.1562
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
1.1973
&
\sphinxAtStartPar
1.1847
&
\sphinxAtStartPar
1.3131
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.3773
&
\sphinxAtStartPar
1.3592
&
\sphinxAtStartPar
1.5524
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
1.6490
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
\sphinxhyphen{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:python-code}}
\sphinxAtStartPar
The code below defines the function \sphinxcode{\sphinxupquote{radauIA()}} which calculates the third\sphinxhyphen{}order Radua IA solution to an initial value problem.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{radauIA}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Y1}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{,} \PYG{n}{Y1o}\PYG{p}{,} \PYG{n}{Y2o} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{Y1} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{Y2} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{/}\PYG{l+m+mi}{12} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
            \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{amax}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Y1} \PYG{o}{\PYGZhy{}} \PYG{n}{Y1o}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{amax}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Y2} \PYG{o}{\PYGZhy{}} \PYG{n}{Y2o}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
                \PYG{k}{break}
            \PYG{n}{Y1o}\PYG{p}{,} \PYG{n}{Y2o} \PYG{o}{=} \PYG{n}{Y1}\PYG{p}{,} \PYG{n}{Y2}

        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The inputs are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{f}} \sphinxhyphen{} the name of the ODE function to be solved;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tspan}} \sphinxhyphen{} an array of two values defining the lower and upper boundaries of the \(t\) domain;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{y0}} \sphinxhyphen{} an array of values containing the solution of the ODE at the initial value \(t=a\);

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{h}} \sphinxhyphen{} the step length used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tol}} \sphinxhyphen{} the convergence tolerance (optional, default is \(tol=10^{-6}\))

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Y1}}, \sphinxcode{\sphinxupquote{Y2}}, \sphinxcode{\sphinxupquote{Y1o}} and \sphinxcode{\sphinxupquote{Y2o}} are current and old estimates of the stage values \(Y_1\) and \(Y_2\) which are calculated by iterating the stage value functions until either the maximum difference between the current and old values is less than \sphinxcode{\sphinxupquote{tol}} or 100 iterations have been calculated.

\sphinxAtStartPar
The computed solutions using the implicit method are plotted in \hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:irk-example-1-figure}]{Fig.\@ \ref{\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:irk-example-1-figure}}} below.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{3.2_Solving_IVPs_using_IRK_methods_5_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Solution of the initial value problem \(y'=ty\), \(t\in[0,1]\), \(y(0)=1\) using the implicit method from the {\hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:irk-example-1}]{\sphinxcrossref{\DUrole{std,std-ref}{example}}}} with a step length \(h=0.2\).}\label{\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:irk-example-1-figure}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The method used to calculate the stage values \(Y_i\) here is an iterative method known as the {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel method}}}}. This is not the most efficient method available to estimate the stage values and in practice \sphinxhref{https://en.wikipedia.org/wiki/Newton\%27s\_method}{Newtons method} is preferred since it is more efficient. However this requires calculation of a matrix of derivatives of \(f(t,y)\) known as a \sphinxhref{https://en.wikipedia.org/wiki/Jacobian\_matrix\_and\_determinant}{Jacobian matrix}, and whilst not a particularly difficult to calculate, it can complicate the code somewhat especially when solving a system of ODEs. Therefore, here we only use the Gauss\sphinxhyphen{}Seidel method.
\end{sphinxadmonition}

\sphinxstepscope


\section{Chapter Summary}
\label{\detokenize{3_IRKs/3.3_IRK_summary:chapter-summary}}\label{\detokenize{3_IRKs/3.3_IRK_summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The stage values in an {\hyperref[\detokenize{3_IRKs/3.0_IRKs:irk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{implicit Runge\sphinxhyphen{}Kutta method}}}} are defined using implicit functions.

\item {} 
\sphinxAtStartPar
The \(A\) matrix of an implicit method has non\sphinxhyphen{}zero elements on the main diagonal or upper triangular region.

\item {} 
\sphinxAtStartPar
Implicit methods use fewer stages to achieve the same accuracy as explicit methods.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:deriving-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{derivation of implicit methods}}}} involves choosing values of \(a_{ij}\), \(b_i\) and \(c_i\) to satisfy the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(B(k)\), \(C(k)\) and \(D(k)\) order conditions}}}}.

\item {} 
\sphinxAtStartPar
Implicit methods have better stability properties than explicit methods meaning they can be used to solve stiff ODEs with which explicit methods are unsuitable (see next chapter on {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{stability}}}});

\item {} 
\sphinxAtStartPar
Implicit methods require an {\hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-ivps-using-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{iterative method}}}} to calculate the stage values;

\item {} 
\sphinxAtStartPar
Implicit methods are more computationally expensive when applied to non\sphinxhyphen{}stiff methods than explicit methods.

\end{itemize}

\sphinxstepscope


\section{Implicit Runge\sphinxhyphen{}Kutta Methods Exercises}
\label{\detokenize{3_IRKs/3.4_IRK_exercises:implicit-runge-kutta-methods-exercises}}\label{\detokenize{3_IRKs/3.4_IRK_exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 3.1}

\sphinxAtStartPar
Show that the Radau IA below is a third\sphinxhyphen{}order method.
\begin{align*}
    \begin{array}{c|cc}
      0 & 0 & 0 \\
      \tfrac{2}{3} & \tfrac{1}{3} & \tfrac{1}{3} \\ \hline
      & \tfrac{1}{4} & \tfrac{3}{4}
    \end{array}
\end{align*}\subsubsection*{Solution (click to show)}

\sphinxAtStartPar
\(B(k)\):
\begin{align*}
    j &= 1: & LHS &= b_1 c_1^0 + b_2 c_2^0 = \tfrac{1}{4} + \tfrac{3}{4} = 1, \\
    && RHS &= 1, \\
    j &= 2: & LHS &= b_1 c_1^1 + b_2 c_2^1 = \tfrac{1}{4}(0) + \tfrac{3}{4} ( \tfrac{2}{3} ) = \tfrac{1}{2}, \\
    && RHS &= \tfrac{1}{2}, \\
    j &= 3: & LHS &= b_1 c_1^2 + b_2 c_2^2 = \tfrac{1}{4}(0) + \tfrac{3}{4} ( \tfrac{4}{9} ) = \tfrac{1}{3}, \\
    && RHS &= \tfrac{1}{3}, \\
    j &= 4: & LSH &= b_1 c_1^3 + b_2 c_3^3 = \tfrac{1}{4}(0) + \tfrac{3}{4} ( \tfrac{8}{27} ) = \tfrac{2}{9}, \\
    && RHS &= \tfrac{1}{4}.
\end{align*}
\sphinxAtStartPar
So \(B(3)\) is satisfied. Checking \(C(1)\):
\begin{align*}
    i &= 1: & LHS &= a_{11} c_1^0 + a_{12} c_2^0 = 0 + 0 = 0, \\
    && RHS &= \tfrac{1}{1} c_1^1 = 0, \\
    i &= 2: & LHS &= a_{21} c_1^0 + a_{22} c_2^0 = \tfrac{1}{3} + \tfrac{1}{3} = \tfrac{2}{3}, \\
    && RHS &= \tfrac{1}{1} c_2^1 = \tfrac{2}{3}.
\end{align*}
\sphinxAtStartPar
So \(C(1)\) is satisfied, checking \(D(1)\):
\begin{align*}
    j &= 1: & LHS &= b_1 c_1^0 a_{11} + b_2 c_2^0 a_{21} = \tfrac{1}{4} (1)(0) + \tfrac{3}{4} (1) ( \tfrac{1}{3} ) = \tfrac{1}{4}, \\
    && RHS &= \tfrac{1}{1}b_1(1 - c_1^1) = \tfrac{1}{4}(1 - 0) = \tfrac{1}{4}, \\
    j &= 2: & LHS &= b_1 c_1^0 a_{12} + b_2 c_2^0 a_{22} = \tfrac{1}{4} (1)(0) + \tfrac{3}{4} (1) ( \tfrac{1}{3} ) = \tfrac{1}{4}, \\
    && RHS &= \tfrac{1}{1} b_2 (1 - c_2^1) = \tfrac{3}{4} ( 1 - \tfrac{2}{3} ) = \tfrac{1}{4}.
\end{align*}
\sphinxAtStartPar
Since \(B(3)\), \(C(1)\) and \(D(1)\) are satisfied then this implicit method is a third\sphinxhyphen{}order method.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.2}

\sphinxAtStartPar
Determine the order of the following IRK method.
\begin{align*}
  \begin{array}{c|ccc}
     0 & 0 & 0 & 0 \\
     \frac{1}{2} & \frac{1}{4} & \frac{1}{4} & 0 \\
     1 & 0 & 1 & 0 \\ \hline
     & \frac{1}{6} & \frac{2}{3} & \frac{1}{6}
  \end{array}
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Check \(B(k)\)
\begin{align*}
    j &= 1: & LHS &= b_1 c_1^0 + b_2 c_2^0 + b_3 c_3^0 = \tfrac{1}{6} + \tfrac{2}{3} + \tfrac{1}{6} = 1, \\
    && RHS &= 1, \\
    j &= 2: & LHS &= b_1 c_1^1 + b_2 c_2^1 + b_3 c_3^1 = \tfrac{1}{6}(0) + \tfrac{2}{3}(\tfrac{1}{2}) + \tfrac{1}{6}(1) = \tfrac{1}{2}, \\
    && RHS &= \tfrac{1}{2}, \\ 
    j &= 3: & LHS &= b_1 c_1^2 + b_2 c_2^2 + b_3 c_3^2 = \tfrac{1}{6}(0) + \tfrac{2}{3}(\tfrac{1}{4}) + \tfrac{1}{6}(1) = \tfrac{1}{3}, \\
    && RHS &= \tfrac{1}{3}, \\
    j &= 4: & LHS &= b_1 c_1^3 + b_2 c_2^3 + b_3 c_3^3 = \tfrac{1}{6}(0) + \tfrac{2}{3}(\tfrac{1}{8}) + \tfrac{1}{6}(1) = \tfrac{1}{4}, \\
    && RHS &= \tfrac{1}{4}, \\
    j &= 5: & LHS &= b_1 c_1^4 + b_2 c_2^4 + b_3 c_3^4 = \tfrac{1}{6}(0) + \tfrac{2}{3}(\tfrac{1}{16}) + \tfrac{1}{6}(1) = \tfrac{5}{24}, \\
\end{align*}
\sphinxAtStartPar
So \(B(4)\) is satisfied, checking \(C(2)\):
\begin{align*}
    \ell &= 1, & i &= 1, & LHS &= a_{11} c_1^0 + a_{12} c_2^0 + a_{13} c_3^0 = 0 + 0 + 0 = 0, \\
    &&&& RHS &= \tfrac{1}{1} c_1^1 = 0, \\
    && i &= 2, & LHS &= a_{21} c_1^0 + a_{22} c_2^0 + a_{23} c_3^0 = \tfrac{1}{4} + \tfrac{1}{4} + 0 = \tfrac{1}{2} \\
    &&&& RHS &= \tfrac{1}{1} c_2^1 = \tfrac{1}{2}, \\
    && i &= 3, & LHS &= a_{31} c_1^0 + a_{32} c_2^0 + a_{33} c_3^0 = 0 + 1 + 0 = 1, \\
    &&&& RHS &= \tfrac{1}{1} c_3^1 = 1, \\
    \ell &= 2, & i &= 1 & LHS &= a_{11} c_1^1 + a_{12} c_2^1 + a_{13} c_3^1 = 0 + 0 + 0 = 0, \\
    &&&& RHS &= \tfrac{1}{2} c_1^2 = \tfrac{1}{2}(0) = 0, \\
    && i &= 2, & LHS &= a_{21} c_1^1 + a_{22} c_2^1 + a_{23} c_3^1 = \tfrac{1}{4}(0) + \tfrac{1}{4}(\tfrac{1}{2}) + 0(1) = \tfrac{1}{8}, \\
    &&&& RHS &= \tfrac{1}{2} c_2^2 = \tfrac{1}{2} (\tfrac{1}{4}) = \tfrac{1}{8}, \\
    && i &= 3, & LHS &= a_{31} c_1^1 + a_{32} c_2^1 + a_{33} c_3^1 = 0(1) + 1(\tfrac{1}{2}) + 0(1) = \tfrac{1}{2}, \\
    &&&& RHS &= \tfrac{1}{2} c_3^2 = \tfrac{1}{2}(1) = \tfrac{1}{2}.
\end{align*}
\sphinxAtStartPar
So \(C(2)\) is satisfied, checking \(D(2)\)
\begin{align*}
    \ell &= 1, & j &= 1, & LHS &= b_1 c_1^0 a_{11} + b_2 c_2^0 a_{21} + b_3 c_3^0 a_{31} 
    = \tfrac{1}{6}(1)(0) + \tfrac{2}{3}(1)(\tfrac{1}{4}) + \tfrac{1}{6}(1)(0) = \tfrac{1}{6}, \\
    &&&& RHS &= \tfrac{1}{1} b_1 (1 - c_1^1) = \tfrac{1}{6} (1 - 0) = \tfrac{1}{6}, \\
    && j &= 2, & LHS &= b_1 c_1^0 a_{12} + b_2 c_2^0 a_{22} + b_3 c_3^0 a_{32} 
    = \tfrac{1}{6}(1)(0) + \tfrac{2}{3}(1)(\tfrac{1}{4}) + \tfrac{1}{6}(1)(1) = \tfrac{1}{3}, \\
    &&&& RHS &= \tfrac{1}{1} b_2 (1 - c_2^1) = \tfrac{2}{3} (1 - \tfrac{1}{2}) = \tfrac{1}{3}, \\
    && j &= 3, & LHS &= b_1 c_1^0 a_{13} + b_2 c_2^0 a_{23} + b_3 c_3^0 a_{33} 
    = \tfrac{1}{6}(1)(0) + \tfrac{2}{3}(1)(0) + \tfrac{1}{6}(1)(0) = 0, \\
    &&&& RHS &= \tfrac{1}{1} b_3 (1 - c_3^1) = \tfrac{1}{6} (1 - 1) = 0, \\
    \ell &= 2, & j &= 1, & LHS &= b_1 c_1^1 a_{11} + b_2 c_2^1 a_{21} + b_3 c_3^1 a_{31} 
    = \tfrac{1}{6}(0)(0) + \tfrac{2}{3}(\tfrac{1}{2})(\tfrac{1}{4}) + \tfrac{1}{6}(1)(0) = \tfrac{1}{12}, \\
    &&&& RHS &= \tfrac{1}{2} b_1 (1 - c_1^2) = \tfrac{1}{2}(\tfrac{1}{6})(1 - 0) = \tfrac{1}{12}, \\
    && j &= 2, & LHS &= b_1 c_1^1 a_{12} + b_2 c_2^1 a_{22} + b_3 c_3^1 a_{32} 
    = \tfrac{1}{6}(0)(0) + \tfrac{2}{3}(\tfrac{1}{2})(\tfrac{1}{4}) + \tfrac{1}{6}(1)(1) = \tfrac{1}{4}, \\
    &&&& RHS &= \tfrac{1}{2} b_2 (1 - c_2^2) = \tfrac{1}{2} (\tfrac{2}{3})(1 - \tfrac{1}{4}) = \tfrac{1}{4}, \\
    && j &= 3, & LHS &= b_1 c_1^1 a_{13} + b_2 c_2^1 a_{23} + b_3 c_3^1 a_{33} 
    = \tfrac{1}{6}(0)(0) + \tfrac{2}{3}(\tfrac{1}{2})(0) + \tfrac{1}{6}(1)(0) = 0, \\
    &&&& RHS &= \tfrac{1}{2} b_3 (1 - c_3^2) = \tfrac{1}{2} (\tfrac{1}{6}) (1 - 1) = 0.
\end{align*}
\sphinxAtStartPar
Since \(B(4)\), \(C(2)\) and \(D(2)\) are satisfied then this is a fourth\sphinxhyphen{}order method.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.3}

\sphinxAtStartPar
Derive a third\sphinxhyphen{}order Radau IIA method.
\subsubsection*{Solution}

\sphinxAtStartPar
Since \(k=3\) then the method has \(s = \frac{k + 1}{2} = 2\) stages. The values of \(c_1\) and \(c_2\) are the roots of \(P_2(t) - P_1(t)\)
\begin{align*}
    0 &= (6t^2 - 6t + 1) - (2t - 1) = 6t^2 - 8t + 2, \\
    \therefore t &= \frac{2 \pm 1}{3},
\end{align*}
\sphinxAtStartPar
so \(c_1 = \frac{1}{3}\) and \(c_2 = 1\). The values of \(b_i\) satisfy the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(B(4)\) order conditions}}}}
\begin{align*}
    b_1 + b_2 &= 0, \\
    \tfrac{1}{3} b_1 + b_2 &= \tfrac{1}{2}, \\
    \tfrac{1}{9} b_1 + b_2 &= \tfrac{1}{3},
\end{align*}
\sphinxAtStartPar
which is solved to give \(b_1 = \frac{3}{4}\) and \(b_2 = \frac{1}{4}\). The values of \(a_{ij}\) satisfy the {\hyperref[\detokenize{3_IRKs/3.0_IRKs:bk-ck-dk-order-conditions}]{\sphinxcrossref{\DUrole{std,std-ref}{\(C(2)\) order conditions}}}}
\begin{align*}
    a_{11} + a_{12} &= \tfrac{1}{3}, \\
    a_{21} + a_{22} &= 1, \\
    \tfrac{1}{3} a_{11} + a_{12} &= \tfrac{1}{18}, \\
    \tfrac{1}{3} a_{21} + a_{22} &= \tfrac{1}{2},
\end{align*}
\sphinxAtStartPar
Subtracting the third equation from the first gives \(\frac{2}{3} a_{11} = \frac{4}{18}\) so \(a_{11} = \frac{5}{12}\) and substituting this into the first equation gives \(a_{12} = -\frac{1}{12}\). Subtracting the fourth equation from the second gives \(\frac{2}{3} a_{21} = \frac{1}{2}\) so \(a_{21} = \frac{3}{4}\) and substituting this into the second equation gives \(a_{22} = \frac{1}{4}\). So the fourth\sphinxhyphen{}order Radau II method is
\begin{align*}
    \begin{array}{c|cc}
        \frac{1}{3} & \frac{5}{12} & -\frac{1}{12} \\
        1 & \frac{3}{4} & \frac{1}{4} \\
        \hline
        & \frac{3}{4} & \frac{!}{4}
    \end{array}
\end{align*}
\sphinxAtStartPar
Python code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define Legendre polynomial}
\PYG{k}{def} \PYG{n+nf}{P}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{Symbol}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{P} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{P} \PYG{o}{+}\PYG{o}{=} \PYG{n}{binomial}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)} \PYG{o}{*} \PYG{n}{binomial}\PYG{p}{(}\PYG{n}{n} \PYG{o}{+} \PYG{n}{k}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k}

    \PYG{k}{return} \PYG{n}{P}


\PYG{c+c1}{\PYGZsh{} Define symbolic variables}
\PYG{n}{a11}\PYG{p}{,} \PYG{n}{a12}\PYG{p}{,} \PYG{n}{a21}\PYG{p}{,} \PYG{n}{a22}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a11, a12, a21, a22, b1, b2, c1, c2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate c values}
\PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{n}{solve}\PYG{p}{(}\PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{a11} \PYG{o}{+} \PYG{n}{a12} \PYG{o}{\PYGZhy{}} \PYG{n}{c1}
\PYG{n}{eq4} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{+} \PYG{n}{a22} \PYG{o}{\PYGZhy{}} \PYG{n}{c2}
\PYG{n}{eq5} \PYG{o}{=} \PYG{n}{a11} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{+} \PYG{n}{a12} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{n}{eq6} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{*} \PYG{n}{c1} \PYG{o}{+} \PYG{n}{a22} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{,} \PYG{n}{eq4}\PYG{p}{,} \PYG{n}{eq5}\PYG{p}{,} \PYG{n}{eq6}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output:
\begin{equation}\label{equation:intro:ex3.3-output-1}
\begin{split}\displaystyle \left[ \frac{1}{3}, \  1\right]\end{split}
\end{equation}\begin{equation}\label{equation:intro:ex3.3-output-2}
\begin{split}\displaystyle \left\{ a_{11} : \frac{5}{12}, \  a_{12} : - \frac{1}{12}, \  a_{21} : \frac{3}{4}, \  a_{22} : \frac{1}{4}, \  b_{1} : \frac{3}{4}, \  b_{2} : \frac{1}{4}\right\}\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.4}

\sphinxAtStartPar
Using pen and paper and working to 6 decimal places, calculate the first step of the third\sphinxhyphen{}order Radau IIA method derived in {\hyperref[\detokenize{3_IRKs/3.4_IRK_exercises:ex3-3}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 3.3}}}} to solve the following initial value problem using a step length of \(h=0.4\) and a convergence tolerance of \(tol = 10^{-4}\)
\begin{align*}
  y' =t - y, \qquad t \in [0,2], \qquad y(0) = 1.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
The Butcher tableau for the Radau IIA method is
\begin{align*}
    \begin{array}{c|cc}
        \frac{1}{3} & \frac{5}{12} & -\frac{1}{12} \\
        1 & \frac{3}{4} & \frac{1}{4} \\
        \hline
        & \frac{3}{4} & \frac{1}{4}
    \end{array}
\end{align*}
\sphinxAtStartPar
The stage values are
\begin{align*}
    Y_1 &= y_n + h (\tfrac{5}{12} f(t_n + \tfrac{1}{3} h, Y_1) - \tfrac{1}{12} f(t_n + h, Y_2)) \\
    Y_2 &= y_n + h (\tfrac{3}{4} f(t_n + \tfrac{1}{3} h, Y_1) + \tfrac{1}{4} f(t_n + h, Y_2)),
\end{align*}
\sphinxAtStartPar
and since \(f(t,y) = t - y \) then
\begin{align*}
    Y_1 &= y_n + h (\tfrac{5}{12} (t_n + \tfrac{1}{3} h - Y_1) - \tfrac{1}{12} (t_n + h - Y_2)) \\
    Y_2 &= y_n + h (\tfrac{3}{4} (t_n + \tfrac{1}{3} h - Y_1) + \tfrac{1}{4} (t_n + h - Y_2)).
\end{align*}
\sphinxAtStartPar
For this problem \(y(0) = 1\) and \(h = 0.4\). Using starting estimates of \(Y_1 = Y_2 = 1\)
\begin{align*}
    k &= 1, & Y_1 &= 1 + 0.4 (\tfrac{5}{12} (0 + \tfrac{1}{3} (0.4) - 1) - \tfrac{1}{12} (0 + 0.4 - 1)) \\
    && &= 0.875556, \\
    && Y_2 &= 1 + 0.4 (\tfrac{3}{4} (0 + \tfrac{1}{3} (0.4) - 0.875556) + \tfrac{1}{4} (0 + 0.4 - 1)) \\
    && &= 0.717333, \\
    k &= 2, & Y_1 &= 1 + 0.4 (\tfrac{5}{12}( 0 + \tfrac{1}{3} (0.4) - 0.875556) - \tfrac{1}{12} (0 + 0.4 - 0.717333)) \\
    && &= 0.886874, \\
    && Y_2 &= 1 + 0.4 (\tfrac{3}{4} (0 + \tfrac{1}{3} (0.4) - 0.886874) + \tfrac{1}{4} (0 + 0.4 - 0.717333)) \\
    && &= 0.742204, \\
    k &= 3, & Y_1 &= 1 + 0.4 (\tfrac{5}{12} (0 + \tfrac{1}{3} (0.4) - 0.886874) - \tfrac{1}{12} (0 + 0.4 - 0.742204)) \\
    && &= 0.885817, \\
    && Y_2 &= 1 + 0.4 (\frac{3}{4} (0 + \tfrac{1}{3} (0.4) - 0.885817) + \tfrac{1}{4} (0 + 0.4 - 0.742204)) \\
    && &= 0.740035, \\
    k &= 4, & Y_1 &= 1 + 0.4 (\tfrac{5}{12} (0 + \tfrac{1}{3} (0.4) - 0.885817) - \tfrac{1}{12} (0 + 0.4 - 0.740035)) \\
    && &= 0.885921, \\
    && Y_2 &= 1 + 0.4 (\tfrac{3}{4} (0 + \tfrac{1}{3} (0.4) - 0.885921) + \tfrac{1}{4} (0 + 0.4 - 0.740035)) \\
    && &= 0.740220, \\
    k &= 5, & Y_1 &= 1 + 0.4 (\tfrac{5}{12} (0 + \tfrac{1}{3} (0.4) - 0.885921) - \tfrac{1}{12} (0 + 0.4 - 0.740220)) \\
    && &= 0.885909, \\
    && Y_2 &= 1 + 0.4 (\tfrac{3}{4} (0 + \tfrac{1}{3} (0.4) - 0.885909) + \tfrac{1}{4} (0 + 0.4 - 0.740220)) \\
    && &= 0.740205.
\end{align*}
\sphinxAtStartPar
After 4 iterations \(\max(|0.885909 - 0.885921|, |0.740205 - 0.640220|) = 1.5\times 10^{-5} < 10^{-4}\) so \(Y_1 = 0.885909\) and \(Y_2 = 0.740205\) are accurate enough for our needs. The solution over the first step is
\begin{align*}
    y_1 &= y_0 + h (\tfrac{3}{4} (t_0 + \tfrac{1}{3}(0.4) - Y_1) + \tfrac{1}{4} (t_0 + 0.4 - Y_2)), \\
    &= 1 + 0.4 (\tfrac{3}{4} (0 + \frac{1}{3}(0.4) - 0.885909) + \frac{1}{4} (0 + 0.4 - 0.740205)), \\
    &= 0.740207.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.5}

\sphinxAtStartPar
The exact solution to the IVP in {\hyperref[\detokenize{3_IRKs/3.4_IRK_exercises:ex3-4}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 3.4}}}} is \(y = t + 2e^{-t} - 1\). Write a program to this initial value problem over the full domain and produce a table comparing the numerical and exact solutions. Plot the numerical solutions and exact solutions on the same set of axes.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{radauIIA}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Y1}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{,} \PYG{n}{Y1o}\PYG{p}{,} \PYG{n}{Y2o} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{Y1} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{/}\PYG{l+m+mi}{12} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{12} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{Y2} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
            \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{amax}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Y1} \PYG{o}{\PYGZhy{}} \PYG{n}{Y1o}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{amax}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Y2} \PYG{o}{\PYGZhy{}} \PYG{n}{Y2o}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
                \PYG{k}{break}
            \PYG{n}{Y1o}\PYG{p}{,} \PYG{n}{Y2o} \PYG{o}{=} \PYG{n}{Y1}\PYG{p}{,} \PYG{n}{Y2}

        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}


\PYG{c+c1}{\PYGZsh{} Define IVP}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}         \PYG{c+c1}{\PYGZsh{} step length}
\PYG{n}{tol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}4}      \PYG{c+c1}{\PYGZsh{} convergence tolerance}

\PYG{c+c1}{\PYGZsh{} Solve IVP using the Radau IIA method}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{radauIIA}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Output solution table}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  t  |    IRK    |   Exact   |   Error   |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{3.1f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot solutions}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Radua IIA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{|}  \PYG{n}{t}  \PYG{o}{|}    \PYG{n}{IRK}    \PYG{o}{|}   \PYG{n}{Exact}   \PYG{o}{|}   \PYG{n}{Error}   \PYG{o}{|}
\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{:}\PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.0} \PYG{o}{|}  \PYG{l+m+mf}{1.000000} \PYG{o}{|}  \PYG{l+m+mf}{1.000000} \PYG{o}{|}  \PYG{l+m+mf}{0.00e+00} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.4} \PYG{o}{|}  \PYG{l+m+mf}{0.740207} \PYG{o}{|}  \PYG{l+m+mf}{0.740640} \PYG{o}{|}  \PYG{l+m+mf}{4.33e\PYGZhy{}04} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{0.8} \PYG{o}{|}  \PYG{l+m+mf}{0.698075} \PYG{o}{|}  \PYG{l+m+mf}{0.698658} \PYG{o}{|}  \PYG{l+m+mf}{5.83e\PYGZhy{}04} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{1.2} \PYG{o}{|}  \PYG{l+m+mf}{0.801801} \PYG{o}{|}  \PYG{l+m+mf}{0.802388} \PYG{o}{|}  \PYG{l+m+mf}{5.87e\PYGZhy{}04} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{1.6} \PYG{o}{|}  \PYG{l+m+mf}{1.003268} \PYG{o}{|}  \PYG{l+m+mf}{1.003793} \PYG{o}{|}  \PYG{l+m+mf}{5.25e\PYGZhy{}04} \PYG{o}{|}
\PYG{o}{|} \PYG{l+m+mf}{2.0} \PYG{o}{|}  \PYG{l+m+mf}{1.270232} \PYG{o}{|}  \PYG{l+m+mf}{1.270671} \PYG{o}{|}  \PYG{l+m+mf}{4.39e\PYGZhy{}04} \PYG{o}{|}
\end{sphinxVerbatim}

\sphinxAtStartPar
Plot

\begin{figure}[H]
\centering
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{3.4_IRK_exercises_5_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\end{figure}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Stability}
\label{\detokenize{4_Stability/4.0_Stability:stability}}\label{\detokenize{4_Stability/4.0_Stability:stability-chapter}}\label{\detokenize{4_Stability/4.0_Stability::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
understand what it means for a method to be considered {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stable}}}};

\item {} 
\sphinxAtStartPar
understand what is means when a problem is {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stiff}}}} and calculate the {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-ratio-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stiffness ratio}}}};

\item {} 
\sphinxAtStartPar
determine the {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:stability-function-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stability function}}}} of {\hyperref[\detokenize{4_Stability/4.2_RK_stability_function:erk-rz-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{explicit}}}} and {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:irk-rz-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{implicit}}}} Runge\sphinxhyphen{}Kutta methods;

\item {} 
\sphinxAtStartPar
understand what it means when a method is {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:absolute-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{absolutely stable}}}};

\item {} 
\sphinxAtStartPar
plot the {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:plot-stability-region-section}]{\sphinxcrossref{\DUrole{std,std-ref}{region of absolute stability}}}} and use it to identify the {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:plot-stability-region-section}]{\sphinxcrossref{\DUrole{std,std-ref}{interval of absolute stability}}}} for a Runge\sphinxhyphen{}Kutta method;

\item {} 
\sphinxAtStartPar
understand what it means when a method is {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stable}}}} and determine whether a method is A\sphinxhyphen{}stable or not.

\end{itemize}


\bigskip\hrule\bigskip



\section{Stable and unstable solutions}
\label{\detokenize{4_Stability/4.0_Stability:stable-and-unstable-solutions}}
\sphinxAtStartPar
The Euler method has been applied to solve the following initial value problem using step lengths of \(h = 0.25\) and \(h = 0.125\)
\begin{align*}
    y' = -15y, \qquad t \in [0, 5], \qquad y(0) = 1.
\end{align*}
\sphinxAtStartPar
The exact solution is \(y = e^{-15t}\) and the numerical solutions are plotted against the exact solution in \hyperref[\detokenize{4_Stability/4.0_Stability:stiff-solution-1}]{Fig.\@ \ref{\detokenize{4_Stability/4.0_Stability:stiff-solution-1}}}. Here we can see that the solution using \(h = 0.125\) remains bounded whereas the solution using \(h = 0.25\) diverges.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.0_Stability_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Stable and unstable solutions to the initial value problem \(y' = -15y\), \(t\in [0, 5]\) and \(y(0) = 1\).}\label{\detokenize{4_Stability/4.0_Stability:stiff-solution-1}}\end{figure}

\sphinxAtStartPar
The solution using \(h = 0.125\) is an example of a \sphinxstylestrong{stable} solution and the solution using \(h = 0.25\) is an example of an \sphinxstylestrong{unstable} solution. The reason for the instability is due to the truncation of the Taylor series. We saw in the section on {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:error-analysis-section}]{\sphinxcrossref{\DUrole{std,std-ref}{error analysis}}}} that the higher order terms that are omitted due to truncation causes a {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:lte-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{local truncation error}}}}, \(\tau\), and the accumulation of these local truncation errors creates the {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:gte-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{global truncation error}}}}. If the local truncation error is too large then the global truncation error will eventually diverge as seen in \hyperref[\detokenize{4_Stability/4.0_Stability:stiff-solution-1}]{Fig.\@ \ref{\detokenize{4_Stability/4.0_Stability:stiff-solution-1}}} causing the solution to be unusable. This provides us with the definition of stability.

\begin{sphinxadmonition}{note}{Definition: stability}

\sphinxAtStartPar
If \(\tau_n\) is the local truncation error of a numerical method defined by
\begin{align*}
    \tau_n = |y_n - \bar{y}_n|,
\end{align*}
\sphinxAtStartPar
where \(y_n\) is the exact solution and \(\bar{y}_n\) the numerical approximation then the method is considered \sphinxstylestrong{stable} if
\begin{equation}\label{equation:4_Stability/4.0_Stability:stability-equation}
\begin{split}|\tau_{n+1} - \tau_n | \leq 1,\end{split}
\end{equation}
\sphinxAtStartPar
for all steps of the method. If a method is not stable then it is \sphinxstylestrong{unstable}.
\end{sphinxadmonition}


\section{Stiffness}
\label{\detokenize{4_Stability/4.0_Stability:stiffness}}\label{\detokenize{4_Stability/4.0_Stability:stiffness-section}}
\sphinxAtStartPar
Whether a numerical method used to solve an ODE is stable or unstable depends upon the ODE being solved and the step length used. A method could be stable for one ODE using a particular step length and unstable for another using the same step length. ODEs that require particularly small step length for a method to be stable are known as \sphinxstylestrong{stiff} ODEs. There is no mathematical definition of what makes an ODE stiff, however, a useful description is provided by Lambert {[}\hyperlink{cite.4_Stability/4.0_Stability:id4}{1991}{]}
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{If a numerical method with a finite region of absolute stability, applied to a system with any initial conditions, is forced to use in a certain interval of integration a step length which is excessively small in relation to the smoothness of the exact solution in that interval, then the system is said to be stiff in that interval.}
\end{quote}


\subsection{Stiffness ratio}
\label{\detokenize{4_Stability/4.0_Stability:stiffness-ratio}}
\sphinxAtStartPar
Consider a system of linear ODEs for the form
\begin{align*}
    \mathbf{y}' = A \mathbf{y},
\end{align*}
\sphinxAtStartPar
where \(\mathbf{y} = (y_1, y_2, \ldots, y_n)^T\) and \(A\) is an \(n \times n\) matrix of constants. Let \(V = (\mathbf{v}_1, \mathbf{v}_2, \ldots, \mathbf{v}_n)\) be a matrix containing the \sphinxhref{https://en.wikipedia.org/wiki/Eigenvalues\_and\_eigenvectors}{eigenvectors} of \(A\) then
\begin{equation*}
\begin{split}V = (A \mathbf{v}_1, A \mathbf{v}_2, \ldots, A \mathbf{v}_n).\end{split}
\end{equation*}
\sphinxAtStartPar
Since \(A \mathbf{v}_i = \lambda_i \mathbf{v}_1\) where \(\lambda_i\) is the eigenvalue corresponding to the eigenvector \(\mathbf{v}_i\) then
\begin{align*}
    AV = (\lambda_1 \mathbf{v}_1, \lambda_2 \mathbf{v}_2, \ldots, \lambda_n \mathbf{v}_n) = V \Lambda
\end{align*}
\sphinxAtStartPar
where \(\Lambda\) is a diagonal matrix of the eigenvalues \(\lambda_i\) (take care to make the distinction between \(\Lambda\) which is the the uppercase \(\lambda\) character and A). Multiplying both sides by \(V^{-1}\) gives
\begin{align*}
    V^{-1} A V = \Lambda,
\end{align*}
\sphinxAtStartPar
which means that \(V^{-1} A\) is a linear transformation that that \sphinxstylestrong{diagonalises} the matrix \(A\). Let \(\mathbf{u} = V^{-1} A \mathbf{y}\) then we have the transformed system \(\mathbf{u}' = \Lambda \mathbf{u}\) which is
\begin{align*}
    u_1' &= \lambda_1 u_1, \\
    u_2' &= \lambda_2 u_2, \\
    &\vdots \\
    u_n' &= \lambda_n u_n.
\end{align*}
\sphinxAtStartPar
Each equation in the transformed system has the solution \(u_i = e^{\lambda_i t}\) so the fastest growing solution will be for the equation with the largest value of \(\lambda\) and the slowest growing solution will be for the equation with the smallest value of \(\lambda\). Stiffness occurs when there is a large variation in the solutions of equations in a system so we can gauge this by calculating the ratio between the largest and smallest eigenvalues of \(A\).

\begin{sphinxadmonition}{note}{Definition: stiffness ratio}

\sphinxAtStartPar
The \sphinxstylestrong{stiffness ratio} for a system of ODEs of the form \(\mathbf{y}' = A \mathbf{y}\) is
\begin{equation*}
\begin{split}S = \frac{\max_i(|\lambda_i|)}{\min_i(|\lambda_i|)}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\lambda_i\) are the eigenvalues of \(A\).
\end{sphinxadmonition}

\sphinxAtStartPar
If the stiffness ratio of a system of ODEs is large%
\begin{footnote}[1]\sphinxAtStartFootnote
What constitutes â€œlargeâ€ is vague and subjective. As a rule of thumb if \(S\) is in the hundreds or greater we can consider the system to be stiff.
%
\end{footnote} then the system is considered to be stiff.

\begin{sphinxadmonition}{note}{Example 4.1}

\sphinxAtStartPar
Determine the stiffness ration of the following ODE
\begin{equation*}
\begin{split} y'' + 1001 y' + 1000 y = 0.\end{split}
\end{equation*}\subsubsection*{Solution}

\sphinxAtStartPar
Rewriting the second\sphinxhyphen{}order ODE as a system of two first\sphinxhyphen{}order ODEs
\begin{align*}
    y_1' &= y_2, \\
    y_2' &= -1000 y_1 - 1001 y_2.
\end{align*}
\sphinxAtStartPar
which can be written as the matrix equation
\begin{align*}
    \begin{pmatrix} y_1' \\ y_2' \end{pmatrix} =
    \begin{pmatrix} 0 & 1 \\ -1000 & -1001 \end{pmatrix}
    \begin{pmatrix} y_1 \\ y_2 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Calculating the eigenvalues of the coefficient matrix
\begin{align*}
    0 &= \begin{vmatrix} -\lambda & 1 \\ -1000 & -1001 - \lambda \end{vmatrix} 
    = \lambda^2 + 1001 \lambda + 1000 = (\lambda + 1000) (\lambda + 1),
\end{align*}
\sphinxAtStartPar
so the eigenvalues are \(\lambda_1 = -1000\) and \(\lambda_2 = -1\). The stiffness ratio is
\begin{equation*}
\begin{split}S = \frac{|-1000|}{|-1|} = 1000.\end{split}
\end{equation*}
\sphinxAtStartPar
Since \(S = 1000\) is large then this system is considered to be stiff.
\end{sphinxadmonition}


\subsection{Solving stiff systems}
\label{\detokenize{4_Stability/4.0_Stability:solving-stiff-systems}}
\sphinxAtStartPar
To solve a stiff system we need to chose a numerical method that will be stable for a practical value of the step length. For example, the implicit Euler method (also known as the backward Euler method)
\begin{align*}
    y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}),
\end{align*}
\sphinxAtStartPar
and the solutions to the initial value problem \(y' = -15y\), \(t\in [0, 5]\) and \(y(0) = 1\) using the Euler method and the implicit Euler method with \(h=0.25\) are plotted in \hyperref[\detokenize{4_Stability/4.0_Stability:stiff-solution-2}]{Fig.\@ \ref{\detokenize{4_Stability/4.0_Stability:stiff-solution-2}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.0_Stability_1_3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Solutions to the initial value problem \(y' = -15y\), \(t\in [0, 5]\) and \(y(0) = 1\) using the Euler and implicit Euler method.}\label{\detokenize{4_Stability/4.0_Stability:stiff-solution-2}}\end{figure}

\sphinxAtStartPar
So if we were constrained with using a step length of \(h=0.25\) then we could choose the implicit Euler method to solve this initial value problem.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Stability functions}
\label{\detokenize{4_Stability/4.1_Stability_functions:stability-functions}}\label{\detokenize{4_Stability/4.1_Stability_functions:stability-functions-section}}\label{\detokenize{4_Stability/4.1_Stability_functions::doc}}
\sphinxAtStartPar
To examine the behaviour of the local truncation errors we use the following test equation
\begin{equation}\label{equation:4_Stability/4.1_Stability_functions:test-equation}
\begin{split}y' = \lambda y.\end{split}
\end{equation}
\sphinxAtStartPar
This test equation is chosen as it is a simple ODE which has the solution \(y=e^{\lambda t}\). Over a single step of a Runge\sphinxhyphen{}Kutta method, the values of \(y_{n+1}\) are updated using the values of \(y_n\) so the values of \(\tau_{n+1}\) are also updated using \(\tau_n\) by the same method. This allows us to define a \sphinxstylestrong{stability function} for a method.

\begin{sphinxadmonition}{note}{Definition: stability function}

\sphinxAtStartPar
The \sphinxstylestrong{stability function} of a method, denoted by \(R(z)\), is the rate of growth over a single step of the method when applied to calculate the solution of an ODE of the form \(y'=\lambda t\) where \(z = h \lambda\) and \(h\) is the step size
\begin{align*}
    y_{n+1} &= R(z)y_n.
\end{align*}\end{sphinxadmonition}

\sphinxAtStartPar
For example, if the Euler method is used to solve the test equation then the solution will be updated over one step using
\begin{align*}
    y_{n+1} =y_n + h f(t_n ,y_n) = y_n + h \lambda y_n,
\end{align*}
\sphinxAtStartPar
Let \(z = h\lambda\) then
\begin{align*}
    y_{n+1} &= y_n + z y_n =(1+z)y_n.
\end{align*}
\sphinxAtStartPar
So the stability function of the Euler method is \(R(z) = 1 + z\).


\subsection{Absolute stability}
\label{\detokenize{4_Stability/4.1_Stability_functions:absolute-stability}}\label{\detokenize{4_Stability/4.1_Stability_functions:absolute-stability-section}}
\sphinxAtStartPar
We have seen that a necessary {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{condition for stability}}}} of a method is that the local truncation errors must not grow from one step to the next. A method satisfying this basic condition is considered to be \sphinxstylestrong{absolutely stable}. Since the stability function \(R(z)\) is expressed using \(z=h\lambda\) then a method may be stable for some value of \(h\) and unstable for others. This provides the definition for absolute stability.

\begin{sphinxadmonition}{note}{Definition: absolute stability}

\sphinxAtStartPar
A method is considered to be \sphinxstylestrong{absolutely stable} if \(|R(z)| \leq 1\) for \(z\in \mathbb{C}\).
\end{sphinxadmonition}

\sphinxAtStartPar
Of course we require our methods to be stable so it is useful to know for what values of \(h\) we have a stable method. This gives the definition of the \sphinxstylestrong{region of absolute stability}.

\begin{sphinxadmonition}{note}{Definition: region of absolute stability}

\sphinxAtStartPar
The \sphinxstylestrong{region of absolute stability} is the set of \(z\in \mathbb{C}\) for which a method is absolutely stable
\begin{align*}
    \{ z:z\in \mathbb{C},|R(z)|\leq 1 \} 
\end{align*}
\sphinxAtStartPar
In other words all of the values of \(z\) for which the method is absolutely stable.
\end{sphinxadmonition}


\subsection{Plotting stability regions}
\label{\detokenize{4_Stability/4.1_Stability_functions:plotting-stability-regions}}\label{\detokenize{4_Stability/4.1_Stability_functions:plot-stability-region-section}}
\sphinxAtStartPar
We can plot the region of absolute stability by generate a set of points for \(z\) in the complex plane and plot the contour where \(|R(z)| = 1\) which is the boundary of the stability region. The code for producing a plot of the region of absolute stability of the Euler method using Python is shown below.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Generate z values}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{X} \PYG{o}{+} \PYG{n}{Y} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}

\PYG{c+c1}{\PYGZsh{} Define stability function}
\PYG{n}{R} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{Z}

\PYG{c+c1}{\PYGZsh{} Plot stability region}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}99ccff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{equal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Re\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Im\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.1_Stability_functions_2_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{The region of absolute stability for the Euler method.}\label{\detokenize{4_Stability/4.1_Stability_functions:euler-stability-region-figure}}\end{figure}


\subsection{Interval of absolute stability}
\label{\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability}}\label{\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability-section}}
\sphinxAtStartPar
The choice of step length used in a method will depend on accuracy requirements, the computational resources available, the stability properties of the method and the ODE being solved. It is often necessary to use as large a value of the step length as possible permitted by the stability requirements to minimise the computational effort required to solve an ODE. The range values of the step length that can be chosen is governed by the stability region and provides use with the following definition.

\begin{sphinxadmonition}{note}{Definition: Interval of absolute stability}

\sphinxAtStartPar
The range of real values that the step length \(h\) of a method can take that ensures a method remains absolutely stable is known as the \sphinxstylestrong{interval of absolute stability}
\begin{align*}
    \{ z : z \in \mathbb{R}, |R(z)| \leq 1 \}
\end{align*}\end{sphinxadmonition}

\sphinxAtStartPar
The interval of absolute stability for the Euler method can be seen in \hyperref[\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability-figure}]{Fig.\@ \ref{\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability-figure}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.1_Stability_functions_4_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Interval of absolute stability for the Euler method.}\label{\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability-figure}}\end{figure}

\sphinxAtStartPar
The region of absolute stability for the Euler method shows that the interval of absolute stability for the test ODE \(y'=\lambda y\) is
\begin{align*}
    z \in [-2,0],
\end{align*}
\sphinxAtStartPar
Since \(z = h\lambda\) then
\begin{align*}
    h \in \left[ -\frac{2}{\lambda},0 \right],
\end{align*}
\sphinxAtStartPar
so we have the condition
\begin{align*}
    h \leq -\frac{2}{\lambda}.
\end{align*}
\sphinxAtStartPar
We saw in \hyperref[\detokenize{4_Stability/4.0_Stability:stiff-solution-1}]{Fig.\@ \ref{\detokenize{4_Stability/4.0_Stability:stiff-solution-1}}} that solving the ODE \(y' = -15y\) using \(h=0.25\) resulted in an unstable solution whereas using \(h=0.125\) resulted in a stable (albeit inaccurate) solution. This is because for this ODE \(\lambda = -15\) and the step length for the Euler method must satisfy
\begin{align*}
    h \leq -\frac{2}{-15} = 0.1\dot{3}.
\end{align*}
\sphinxAtStartPar
This is why the solution using \(h=0.25\) was stable since \(0.25 < 0.1\dot{3}\) and the solution using \(h=0.125\) was unstable since \(0.125 < 0.1\dot{3}\).

\sphinxstepscope


\section{Stability function of a Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{4_Stability/4.2_RK_stability_function:stability-function-of-a-runge-kutta-method}}\label{\detokenize{4_Stability/4.2_RK_stability_function::doc}}
\sphinxAtStartPar
Recall that the {\hyperref[\detokenize{2_ERKs/2.0_ERKs:rk-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{general form of a Runge\sphinxhyphen{}Kutta method}}}} is
\begin{align*}
    y_{n+1}&=y_n + h \sum_{i=1}^s b_i k_i ,\\
    k_i &=f(t_n +c_i h,y_n +h\sum_{j=1}^s a_{ij} k_j ).
\end{align*}
\sphinxAtStartPar
Let \(Y_i = y_n + h \displaystyle \sum_{j=1}^s a_{ij} k_i\) and applying the method to the test equation \(y' = \lambda y\) we have
\begin{align*}
    y_{n+1} &=y_n +h\lambda \sum_{i=1}^s b_i Y_i ,\\
    Y_i &=y_n +h\lambda \sum_{j=1}^s a_{ij} Y_j .
\end{align*}
\sphinxAtStartPar
Let \(z = h\lambda\) and expanding out the summations in the stage values
\begin{align*}
    Y_1 &=y_n +z(a_{11} Y_1 + a_{12} Y_2 + \cdots + a_{1s} Y_s),\\
    Y_2 &=y_n +z(a_{21} Y_1 + a_{22} Y_2 + \cdots + a_{2s} Y_s),\\
    &\vdots \\
    Y_s &=y_n +z(a_{s1} Y_1 + a_{s2} Y_2 + \cdots + a_{ss} Y_s).
\end{align*}
\sphinxAtStartPar
We can write these as the matrix equation
\begin{align*}
    \begin{pmatrix} Y_1 \\ Y_2 \\ \vdots \\ Y_s \end{pmatrix} = 
    \begin{pmatrix} y_n \\ y_n \\ \vdots \\ y_n \end{pmatrix}
    + z
    \begin{pmatrix}
        a_{11} & a_{12} & \cdots & a_{1s} \\
        a_{21} & a_{22} & \cdots & a_{2s} \\
        \vdots & \vdots & \ddots & \vdots \\
        a_{s1} & a_{s2} & \cdots & a_{ss}
    \end{pmatrix} 
    \begin{pmatrix} Y_1 \\ Y_2 \\ \vdots \\ Y_s \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Let \(Y=(Y_1 ,Y_2 ,\dots ,Y_s )^T\) and \(\mathbf{e}=(1,1,\dots ,1)^T\) then
\begin{equation}\label{equation:4_Stability/4.2_RK_stability_function:rk-stability-Y-equation}
\begin{split}Y = \mathbf{e} y_n + z A Y.\end{split}
\end{equation}
\sphinxAtStartPar
Expanding the summation in the equation for updating the solution over a single step and using \(z = h \lambda\) gives
\begin{align*}
    y_{n+1} = y_n + z (b_1 Y_1 + b_2 Y_2 + \cdots + b_s Y_s),
\end{align*}
\sphinxAtStartPar
which can be written as the matrix equation
\begin{align*}
    y_{n+1} = y_n + z
    \begin{pmatrix}
        b_1 & b_2 & \cdots & b_s 
    \end{pmatrix}
    \begin{pmatrix}
        Y_1 \\ Y_2 \\ \vdots \\ Y_s
    \end{pmatrix}. 
\end{align*}
\sphinxAtStartPar
Since \(\mathbf{b}\) is a column vector then the vector form of a Runge\sphinxhyphen{}Kutta method for solving the test equation \(y' = \lambda y\) is
\begin{equation}\label{equation:4_Stability/4.2_RK_stability_function:rk-stability-yn+1-equation}
\begin{split}y_{n+1} =y_n + z \mathbf{b}^T Y.\end{split}
\end{equation}
\sphinxAtStartPar
The stability functions for explicit and implicit Runge\sphinxhyphen{}Kutta methods are derived using different approaches.


\subsection{Stability function of an explicit Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{4_Stability/4.2_RK_stability_function:stability-function-of-an-explicit-runge-kutta-method}}\label{\detokenize{4_Stability/4.2_RK_stability_function:erk-rz-section}}
\sphinxAtStartPar
To derive the stability function of an explicit Runge\sphinxhyphen{}Kutta method we rearrange equation \eqref{equation:4_Stability/4.2_RK_stability_function:rk-stability-Y-equation}
\begin{align*}
    Y - zAY &= \mathbf{e}y_n \\
    (I - zA)Y &= \mathbf{e}y_n\\
    Y&= (I-zA)^{-1} \mathbf{e}y_n,
\end{align*}
\sphinxAtStartPar
and substituting into \eqref{equation:4_Stability/4.2_RK_stability_function:rk-stability-yn+1-equation} gives
\begin{align*}
    y_{n+1} &= y_n +z\mathbf{b}^T (I-zA)^{-1} \mathbf{e} y_n \\
    &= (1 + z \mathbf{b}^T (I - zA)^{-1} \mathbf{e})y_n ,
\end{align*}
\sphinxAtStartPar
so the stability function is
\begin{align*}
    R(z)=1 + z\mathbf{b}^T (I - zA)^{-1} \mathbf{e}
\end{align*}
\sphinxAtStartPar
Using the geometric series of matrices
\begin{align*}
    (I - zA)^{-1} = \sum_{k=0}^{\infty} (zA)^k 
\end{align*}
\sphinxAtStartPar
gives the following definition for the stability function of an explicit method.

\begin{sphinxadmonition}{note}{Definition: Stability function of an explicit Runge\sphinxhyphen{}Kutta method}
\begin{equation}\label{equation:4_Stability/4.2_RK_stability_function:erk-stability-rz-equation}
\begin{split}R(z)=1+\sum_{k=0}^{\infty} \mathbf{b}^T A^k \mathbf{e}\,z^{k+1} =1+\mathbf{b}^T \mathbf{e}\,z+\mathbf{b}^T A\mathbf{e}\,z^2 +\mathbf{b}^T A^2 \mathbf{e}\,z^3 + \cdots\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
Since the solution to the test equation is \(y=e^{\lambda t}\), over one step of an explicit Runge\sphinxhyphen{}Kutta method we would expect the local truncation errors to change at a rate of \(e^z\). The series expansion of \(e^z\) is
\begin{equation}\label{equation:4_Stability/4.2_RK_stability_function:erk-stability-exp(z)-equation}
\begin{split}e^z = \sum_{k=0}^{\infty} \frac{1}{k!} z^k = 1 + z + \frac{1}{2!}z^2 + \frac{1}{3!}z^3 + \frac{1}{4!}z^4 + \cdots\end{split}
\end{equation}
\sphinxAtStartPar
Comparing the coefficients of \(z^k\) in equations \eqref{equation:4_Stability/4.2_RK_stability_function:erk-stability-rz-equation} and \eqref{equation:4_Stability/4.2_RK_stability_function:erk-stability-exp(z)-equation} we have
\begin{align*}
    \frac{1}{k!}= \mathbf{b}^T A^{k-1} \mathbf{e},
\end{align*}
\sphinxAtStartPar
which must be satisfied up to the \(k\)th term for an order \(k\) explicit method to be stable. The stability functions for the explicit Runge\sphinxhyphen{}Kutta methods or order 1 â€“ 4 have been plotted in \hyperref[\detokenize{4_Stability/4.2_RK_stability_function:erk-stability-regions-figure}]{Fig.\@ \ref{\detokenize{4_Stability/4.2_RK_stability_function:erk-stability-regions-figure}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.2_RK_stability_function_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Regions of absolute stability for explicit Runge\sphinxhyphen{}Kutta methods of order 1 to 4.}\label{\detokenize{4_Stability/4.2_RK_stability_function:erk-stability-regions-figure}}\end{figure}

\begin{sphinxadmonition}{note}{Example 4.2}

\sphinxAtStartPar
An explicit Runge\sphinxhyphen{}Kutta method is defined by the following Butcher tableau
\begin{align*}\begin{array}{c|cccc}
0 &  &  &  & \\
\frac{1}{2} & \frac{1}{2} &  &  & \\
\frac{3}{4} & 0 & \frac{3}{4} &  & \\
1 & \frac{2}{9} & \frac{1}{3} & \frac{4}{9} & \\ 
\hline
& \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8}
\end{array}\end{align*}
\sphinxAtStartPar
(i) Determine the stability function for this Runge\sphinxhyphen{}Kutta method and hence find its order;
\subsubsection*{Solution}

\sphinxAtStartPar
Here we have
\begin{align*}
    A &= \begin{pmatrix}
        0 & 0 & 0 & 0 \\
        \frac{1}{2} & 0 & 0 & 0 \\
        0 & \frac{3}{4} & 0 & 0 \\
        \frac{2}{9} & \frac{1}{3} & \frac{4}{9} & 0
    \end{pmatrix}, &
    \mathbf{b} &= \begin{pmatrix} \frac{7}{24} \\ \frac{1}{4} \\ \frac{1}{3} \\ \frac{1}{8} \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Calculating \(\mathbf{b}^TA^{k - 1}\mathbf{e}\) for \(h = 1 \ldots 4\)
\begin{align*}
    k &= 1, & \mathbf{b}^TA^0 \mathbf{e} &= 
    \begin{pmatrix} \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8} \end{pmatrix}
    \begin{pmatrix} 
        1 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 1 
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \end{pmatrix} = 1, \\
    k &= 2, & \mathbf{b}^TA^1 \mathbf{e} &= 
    \begin{pmatrix} \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8} \end{pmatrix}
    \begin{pmatrix}
        0 & 0 & 0 & 0 \\
        \frac{1}{2} & 0 & 0 & 0 \\
        0 & \frac{3}{4} & 0 & 0 \\
        \frac{2}{9} & \frac{1}{3} & \frac{4}{9} & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \end{pmatrix} 
    = \frac{1}{2}, \\
    k &= 3, & \mathbf{b}^TA^2 \mathbf{e} &= 
    \begin{pmatrix} \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8} \end{pmatrix}
    \begin{pmatrix}
        0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        \frac{3}{8} & 0 & 0 & 0 \\
        \frac{1}{6} & \frac{1}{3} & 0 & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \end{pmatrix} 
    = \frac{3}{16}, \\
    k &= 4, & \mathbf{b}^TA^3 \mathbf{e} &= 
    \begin{pmatrix} \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8} \end{pmatrix}
    \begin{pmatrix}
        0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        \frac{1}{6} & 0 & 0 & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \end{pmatrix} 
    = \frac{1}{48}.
\end{align*}
\sphinxAtStartPar
So the stability function is
\begin{align*}
    R(z) = 1 + z + \frac{1}{2} z^2 + \frac{3}{16} z^3 + \frac{1}{48} z^4,
\end{align*}
\sphinxAtStartPar
which agrees to the series expansion of \(e^z\) from equation \eqref{equation:4_Stability/4.2_RK_stability_function:erk-stability-exp(z)-equation} up to and including the \(z^2\) term. Therefore this method is of order 2.

\sphinxAtStartPar
(ii) plot the region of absolute stability and that of an explicit method on the same order on the same set of axes;
\subsubsection*{Solution}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Generate z values}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{X} \PYG{o}{+} \PYG{n}{Y} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}

\PYG{c+c1}{\PYGZsh{} Define stability function}
\PYG{n}{ERK} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{Z} \PYG{o}{+} \PYG{n}{Z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{Z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{/} \PYG{l+m+mi}{16} \PYG{o}{+} \PYG{n}{Z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4} \PYG{o}{/} \PYG{l+m+mi}{48} 
\PYG{n}{RK2} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{Z} \PYG{o}{+} \PYG{n}{Z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Plot stability region}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{ERK}\PYG{p}{)}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}99ccff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{ERK}\PYG{p}{)}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{RK2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}ffcccc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{RK2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Re\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Im\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.2_RK_stability_function_3_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\sphinxAtStartPar
(iii) comment on the region of absolute stability of the two methods.
\subsubsection*{Solution}

\sphinxAtStartPar
The interval of absolute stability for this method is \([-3,0]\) whereas for the second\sphinxhyphen{}order method we have \([-2,0]\). This means that this method is stable for larger values of \(h\) so we can use fewer steps than the second\sphinxhyphen{}order method to calculate the solution to the same accuracy, although it does require the calculation of two additional stage values.
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{4_Stability/4.2_RK_stability_function:python-code}}
\sphinxAtStartPar
The code below calculates the coefficients of the stability function for the explicit Runge\sphinxhyphen{}Kutta method from {\hyperref[\detokenize{4_Stability/4.2_RK_stability_function:erk-stability-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example  4.2}}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,} \PYG{n}{Math}

\PYG{c+c1}{\PYGZsh{} Define ERK method}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
            \PYG{p}{[}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
            \PYG{p}{[}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate stability function}
\PYG{n}{string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R(z) = 1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{coefficient} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{T} \PYG{o}{*} \PYG{n}{A} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k} \PYG{o}{*} \PYG{n}{e}
    \PYG{n}{string} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{latex}\PYG{p}{(}\PYG{n}{coefficient}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ z\PYGZca{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{Math}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle R(z) = 1 + 1 z^1 + \frac{1}{2} z^2 + \frac{3}{16} z^3 + \frac{1}{48} z^4\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Stability functions of implicit methods}
\label{\detokenize{4_Stability/4.3_IRK_stability_function:stability-functions-of-implicit-methods}}\label{\detokenize{4_Stability/4.3_IRK_stability_function:implicit-rz-section}}\label{\detokenize{4_Stability/4.3_IRK_stability_function::doc}}
\sphinxAtStartPar
The simplest implicit method for solving ODEs is the implicit Euler method (also known as the backward Euler method) which is
\begin{align*}
    y_{n+1} =y_n + hf(t_{n+1}, y_{n+1}).
\end{align*}
\sphinxAtStartPar
Applying this to solve the test equation \(y' = \lambda y\) and rearranging gives
\begin{align*}
    y_{n+1} &=y_n + h \lambda y_{n+1} \\
    (1 - h\lambda ) y_{n+1} &=y_n \\
    y_{n+1} &=\left( \frac{1}{1 - h\lambda} \right) y_n.
\end{align*}
\sphinxAtStartPar
Let \(z = h\lambda\) then the stability function for the implicit Euler method is
\begin{align*}
    R(z)=\frac{1}{1-z}.
\end{align*}
\sphinxAtStartPar
So here the stability function is a ration fraction which is the case for all implicit methods so we write
\begin{align*}
    R(z) = \frac{P(z)}{Q(z)}.
\end{align*}
\sphinxAtStartPar
The region of absolute stability of the implicit Euler method has been plotted in \hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:euler-stability-region-figure}]{Fig.\@ \ref{\detokenize{4_Stability/4.3_IRK_stability_function:euler-stability-region-figure}}}. Note that the region of absolute stability includes all of the complex plane with the exception of the unshaded region which means the interval of absolute stability is \(h\lambda \in [-\infty, 0]\) so the method is stable for all values of \(h\) when solving the test equation \(y'= \lambda y\) (this is known as {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stability}}}}).

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.3_IRK_stability_function_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Region of absolute stability for the implicit Euler method.}\label{\detokenize{4_Stability/4.3_IRK_stability_function:euler-stability-region-figure}}\end{figure}


\subsection{Stability functions for an implicit Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{4_Stability/4.3_IRK_stability_function:stability-functions-for-an-implicit-runge-kutta-method}}
\sphinxAtStartPar
To determine the stability function for an implicit Runge\sphinxhyphen{}Kutta method we consider the stability function of a general Runge\sphinxhyphen{}Kutta method given in equations \eqref{equation:4_Stability/4.2_RK_stability_function:rk-stability-Y-equation} and \eqref{equation:4_Stability/4.2_RK_stability_function:rk-stability-yn+1-equation}
\begin{align*}
    y_{n+1} & = y_n + z \mathbf{b}^T Y, \\
    Y &= \mathbf{e} y_n + z A Y.
\end{align*}
\sphinxAtStartPar
Rewriting these gives
\begin{align*}
    y_{n+1} - z \mathbf{b}^T Y &= y_n \\
    (I - z A) Y &= \mathbf{e}y_n. 
\end{align*}
\sphinxAtStartPar
We can write these as a matrix equation
\begin{align*}
    \begin{pmatrix}
        1 & -z b_1  & -z b_2  & \cdots  & -z b_s \\
        0 & 1-z a_{11}  & -z a_{12}  & \cdots  & -z a_{1s} \\
        0 & -z a_{21}  & 1-z a_{22}  & \cdots  & -z a_{2s} \\
        0 & \vdots  & \vdots  & \ddots  & \vdots \\
        0 & -z a_{s1}  & -z a_{s2}  & \cdots  & 1-z a_{ss} 
    \end{pmatrix}
    \begin{pmatrix} y_{n+1} \\ Y_1 \\ Y_2 \\ \vdots \\ Y_s  \end{pmatrix}=
    \begin{pmatrix} y_n \\ y_n \\ y_n \\ \vdots \\ y_n \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Using \sphinxhref{https://en.wikipedia.org/wiki/Cramer\%27s\_rule}{Cramerâ€™s rule} to solve this system for \(y_{n+1}\) we have
\begin{align*}
    y_{n+1} = \frac{\det 
    \begin{pmatrix}
        y_n  & -zb_1  & -zb_2  & \cdots  & -zb_s \\
        y_n  & 1-za_{11}  & -za_{12}  & \cdots  & -za_{1s} \\
        y_n  & -za_{21}  & 1-za_{22}  & \cdots  & -za_{2s} \\
        y_n  & \vdots  & \vdots  & \ddots  & \vdots \\
        y_n  & -za_{s1}  & -za_{s2}  & \cdots  & 1-za_{ss} 
    \end{pmatrix}}{\det (I-zA)}.
\end{align*}
\sphinxAtStartPar
Performing a row operation of subtracting the first row of matrix from all other rows gives
\begin{align*}
    y_{n+1} =\frac{\det 
    \begin{pmatrix}
        y_n  & -zb_1  & -zb_2  & \cdots  & -zb_s \\
        0 & 1-za_{11} +zb_1  & -za_{12} +zb_2  & \cdots  & -za_{1s} +zb_s \\
        0 & -za_{21} +zb_1  & 1-za_{22} +zb_2  & \cdots  & -za_{2s} +zb_s \\
        0 & \vdots  & \vdots  & \ddots  & \vdots \\
        0 & -za_{s1} +zb_1  & -za_{s2} +zb_2  & \cdots  & 1-za_{ss} +zb_s 
    \end{pmatrix}}{\det(I-zA)}.
\end{align*}
\sphinxAtStartPar
This provides the following definition of the stability function for an implicit Runge\sphinxhyphen{}Kutta method

\begin{sphinxadmonition}{note}{Definition: Stability function of an implicit Runge\sphinxhyphen{}Kutta method}
\begin{equation}\label{equation:4_Stability/4.3_IRK_stability_function:irk-stability-rz-equation}
\begin{split}R(z) = \frac{\det (I - zA + z\mathbf{e}\mathbf{b}^T)}{\det(I - zA)}.\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
\(\mathbf{e}\mathbf{b}^T\) is a diagonal matrix with the elements of \(\mathbf{b}\) on the main diagonal
\begin{align*}
    \mathbf{e}\mathbf{b}^T = 
    \begin{pmatrix} 1 \\ 1 \\ \vdots \\ 1 \end{pmatrix}
    \begin{pmatrix} b_1 & b_2 & \cdots & b_s \end{pmatrix} 
    = \begin{pmatrix}
        b_1 & 0 & \cdots & 0 \\
        0 & b_2 & \cdots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        0 & 0 & \cdots & b_s
    \end{pmatrix}.
\end{align*}

\subsection{A\sphinxhyphen{}stability}
\label{\detokenize{4_Stability/4.3_IRK_stability_function:a-stability}}\label{\detokenize{4_Stability/4.3_IRK_stability_function:id1}}
\sphinxAtStartPar
As we saw in the plot of the {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:euler-stability-region-figure}]{\sphinxcrossref{\DUrole{std,std-ref}{region of absolute stability of the backwards Euler method}}}}, implicit methods have a much greater stability region than explicit methods and are very useful for solving stiff ODEs where the stability constraints placed on an explicit method means the step length \(h\) is too small to be of practical use. A desirable property of some implicit methods is that there is no limit placed on the value of \(h\) for which will result in an unstable method, this is known as .

\begin{sphinxadmonition}{note}{Definition: A\sphinxhyphen{}stability}

\sphinxAtStartPar
A method is said to be \sphinxstylestrong{A\sphinxhyphen{}stable} if its region of absolute stability satisfies
\begin{align*}
    \{ z : z \in {\mathbb{C}}^- ,|R(z)| \leq 1\}
\end{align*}
\sphinxAtStartPar
i.e., the method is stable for all points in the left\sphinxhyphen{}hand side of the complex plane.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Theorem: Conditions for A\sphinxhyphen{}stability}

\sphinxAtStartPar
Given an implicit Runge\sphinxhyphen{}Kutta method with a stability function of the form
\begin{align*}
    R(z) = \frac{P(z)}{Q(z)}
\end{align*}
\sphinxAtStartPar
and define a polynomial function
\begin{equation}\label{equation:4_Stability/4.3_IRK_stability_function:ey-definition}
\begin{split}E(y)=Q(iy)Q(-iy)-P(iy)P(-iy),\end{split}
\end{equation}
\sphinxAtStartPar
then the method is A\sphinxhyphen{}stable if and only if the following are satisfied
\begin{itemize}
\item {} 
\sphinxAtStartPar
All roots of \(Q(z)\) have positive real parts;

\item {} 
\sphinxAtStartPar
\(E(y)\geq 0\) for all \(y\in \mathbb{R}\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 4.3}

\sphinxAtStartPar
An implicit Runge\sphinxhyphen{}Kutta method is defined by the following Butcher tableau
\begin{align*}
    \begin{array}{c|cc}
    \frac{1}{3} & \frac{5}{12} & -\frac{1}{12} \\
    1 & \frac{3}{4} & \frac{1}{4} \\ \hline
    & \frac{3}{4} & \frac{1}{4}
    \end{array}
\end{align*}
\sphinxAtStartPar
Determine whether this method is A\sphinxhyphen{}stable and plot the region of absolute stability.
\subsubsection*{Solution}

\sphinxAtStartPar
Using equation \eqref{equation:4_Stability/4.3_IRK_stability_function:irk-stability-rz-equation}
\begin{align*}
    R(z) &= \frac{\det \left(
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} 
    - z \begin{pmatrix} \frac{5}{12} & -\frac{1}{12} \\ \frac{3}{4} & \frac{1}{4} \end{pmatrix}
    + z \begin{pmatrix} \frac{3}{4} & 0 \\ 0 & \frac{1}{4} \end{pmatrix} \right)}{\det \left(
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} - z
    \begin{pmatrix} \frac{5}{12} & -\frac{1}{12} \\ \frac{3}{4} & \frac{1}{4} \end{pmatrix} \right)} \\
    &= \frac{\det \begin{pmatrix} 1 + \frac{z}{3} & \frac{1}{12}z \\ -\frac{3}{4}z & 1 \end{pmatrix}}
    {\det \begin{pmatrix} 1 - \frac{5}{12}z & \frac{1}{12}z \\ -\frac{3}{4}z & 1 - \frac{1}{4}z \end{pmatrix}} 
    = \frac{1 + \frac{1}{3}z + \frac{1}{16}z^2}{1 - \frac{2}{3}z + \frac{1}{6}z^2}.
\end{align*}
\sphinxAtStartPar
Here \(Q(z) = 1 - \frac{2}{3}z + \frac{1}{6}z^2\) which has roots at \(z = 2 \pm \sqrt{2}\) which both have positive real parts so the {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-theorem}]{\sphinxcrossref{\DUrole{std,std-ref}{first condition}}}} for A\sphinxhyphen{}stability is satisfied. Using equation \eqref{equation:4_Stability/4.3_IRK_stability_function:ey-definition}
\begin{align*}
    E(y) &= \left( 1 - \frac{2}{3} i y - \frac{1}{6}y^2 \right) \left( 1 + \frac{2}{3} i y - \frac{1}{6}y^2 \right) \\
    & \qquad - \left( 1 + \frac{1}{3} i y - \frac{1}{16} y^2 \right) \left( 1 - \frac{1}{3}i y - \frac{1}{16}y^2 \right) \\
    &= \left( 1 + \frac{2}{3}iy - \frac{1}{6}y^2 - \frac{2}{3} i y + \frac{4}{9}y^2 + \frac{1}{9} i y^3 - \frac{1}{6}y^2 - \frac{1}{9} i y^2 + \frac{1}{36} y^4 \right) \\
    & \qquad \left( 1 - \frac{1}{3} i y - \frac{1}{16}y^2 + \frac{1}{3} i y + \frac{1}{9} y^2 - \frac{1}{48} i y^2 - \frac{1}{16} y^2 + \frac{1}{48} i y^3 + \frac{1}{256} y^4 \right) \\
    &= \left( 1 + \frac{1}{9} y^2 + \frac{1}{36} y^4 \right) - \left( 1 - \frac{1}{72} y^2 + \frac{1}{256} y^4 \right) \\
    &= \frac{1}{8} y^2 + \frac{55}{2304} y^4.
\end{align*}
\sphinxAtStartPar
Since \(y_2\) and \(y_4\) are positive for all \(y\) then \(E(y)>0\) and the {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-theorem}]{\sphinxcrossref{\DUrole{std,std-ref}{second condition}}}} for A\sphinxhyphen{}stability is satisfied. Since both conditions are satisfied then we can say that this is an A\sphinxhyphen{}stable method.

\sphinxAtStartPar
The region of absolute stability for this method has been plotted below. Note that the interval of absolute stability is \([-\infty, 0]\).

\begin{figure}[H]
\centering
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.3_IRK_stability_function_4_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\end{figure}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{4_Stability/4.3_IRK_stability_function:python-code}}
\sphinxAtStartPar
The code below uses SymPy to determine the stability function of an implicit method and checks the two conditions for A\sphinxhyphen{}stability.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{Math}

\PYG{c+c1}{\PYGZsh{} Define numerator and denominator functions}
\PYG{k}{def} \PYG{n+nf}{P}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{I} \PYG{o}{\PYGZhy{}} \PYG{n}{z} \PYG{o}{*} \PYG{n}{A} \PYG{o}{+} \PYG{n}{z} \PYG{o}{*} \PYG{n}{ebT}\PYG{p}{)}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{Q}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{I} \PYG{o}{\PYGZhy{}} \PYG{n}{z} \PYG{o}{*} \PYG{n}{A}\PYG{p}{)}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Define RK method}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ebT} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate R(z)}
\PYG{n}{z}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z, y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Rz} \PYG{o}{=} \PYG{n}{P}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Q}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R(z) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsimplify}\PYG{p}{(}\PYG{n}{Rz}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Check roots of Q have positive real parts}
\PYG{n}{roots} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Roots of Q(z) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{roots}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Check E(y) \PYGZgt{}= 0}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)} \PYG{o}{*} \PYG{n}{Q}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)} \PYG{o}{*} \PYG{n}{P}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E(y) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsimplify}\PYG{p}{(}\PYG{n}{E}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
R(z) = (z**2/16 + z/3 + 1)/(z**2/6 \PYGZhy{} 2*z/3 + 1)
Roots of Q(z) = [2 \PYGZhy{} sqrt(2)*I, 2 + sqrt(2)*I]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
E(y) = y**2*(55*y**2 + 288)/2304
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Chapter summary}
\label{\detokenize{4_Stability/4.4_Stability_summary:chapter-summary}}\label{\detokenize{4_Stability/4.4_Stability_summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A numerical method is {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stable}}}} if the local truncation errors do not increase from one step to the next.

\item {} 
\sphinxAtStartPar
A system of ODEs is {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stiff}}}} if it requires a numerical method to use a small step length in order to remain stable.

\item {} 
\sphinxAtStartPar
If the {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-ratio-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stiffness ratio}}}} which is the ratio of the largest to smallest eigenvalues of the coefficient matrix of a system of ODEs is \sphinxstyleemphasis{large} then the system is considered to be stiff.

\item {} 
\sphinxAtStartPar
The stability of a method is analysed by considering the simple test equation \(y' =\lambda y\).

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:stability-function-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stability function}}}} of a method is the amount by which the solution to the test equation changes over a single step of length.

\item {} 
\sphinxAtStartPar
A numerical method is {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:stability-function-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{absolutely stable}}}} is the absolute value of the stability function is less than 1.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:region-of-absolute-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{region of absolute stability}}}} is the set of all values in the complex plane where a numerical method is absolutely stable.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{interval of absolute stability}}}} is the range of values of \(z = h \lambda\) for which a numerical method is absolutely stable.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.2_RK_stability_function:erk-rz-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stability function of an explicit Runge\sphinxhyphen{}Kutta method}}}} is a polynomial function of \(z\) the coefficients of which are calculated using the values of \(a_{ij\) and \(b_i\).

\item {} 
\sphinxAtStartPar
The order of an explicit Runge\sphinxhyphen{}Kutta method can be found by determining the highest order term in the stability function that is the same as the series expansion of \(e^z\).

\item {} 
\sphinxAtStartPar
The stability function for {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:implicit-rz-section}]{\sphinxcrossref{\DUrole{std,std-ref}{implicit methods}}}} are a fraction of two polynomial functions of \(z\).

\item {} 
\sphinxAtStartPar
Implicit methods can be {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stable}}}} which means the region of absolute stability contains the whole left\sphinxhyphen{}hand side of the complex plane meaning that there is no limit placed on the value of the step length for a method to remain stable.

\end{itemize}

\sphinxstepscope


\section{Stability Exercises}
\label{\detokenize{4_Stability/4.5_Stability_exercises:stability-exercises}}\label{\detokenize{4_Stability/4.5_Stability_exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 4.1}

\sphinxAtStartPar
Determine the stability function of the following Runge\sphinxhyphen{}Kutta method
\begin{align*}
    \begin{array}{c|ccccc}
        0 &  &  &  &  & \\
        \frac{1}{4} & \frac{1}{4} &  &  &  & \\
        \frac{1}{2} & \frac{1}{2} & 0 &  &  & \\
        \frac{3}{4} & 0 & \frac{1}{2} & \frac{1}{4} &  &    \\
        0 & 0 & \frac{1}{6} & -\frac{1}{3} & \frac{1}{6} & \\ \hline
        & -1 & \frac{2}{3} & -\frac{1}{3} & \frac{2}{3} & 1
    \end{array}
\end{align*}\subsubsection*{Solution (click to show)}
\begin{align*}
    \mathbf{b} A^0 \mathbf{e} &= 
    \begin{pmatrix} -1 \\ \frac{2}{3} \\ -\frac{1}{3} \\ \frac{2}{3} \\ 1 \end{pmatrix}
    \begin{pmatrix} 
        1 & 0 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 0 & 1 
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{pmatrix}
    = 1, \\
    \mathbf{b} A^1 \mathbf{e} &= 
    \begin{pmatrix} -1 \\ \frac{2}{3} \\ -\frac{1}{3} \\ \frac{2}{3} \\ 1 \end{pmatrix}
    \begin{pmatrix} 
        0 & 0 & 0 & 0 & 0 \\
        \frac{1}{4} & 0 & 0 & 0 & 0 \\
        \frac{1}{2} & 0 & 0 & 0 & 0 \\
        0 & \frac{1}{2} & \frac{1}{4} & 0 & 0 \\
        0 & \frac{1}{6} & -\frac{1}{3} & \frac{1}{6} & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{pmatrix}
    = \frac{1}{2}, \\
    \mathbf{b} A^2 \mathbf{e} &= 
    \begin{pmatrix} -1 \\ \frac{2}{3} \\ -\frac{1}{3} \\ \frac{2}{3} \\ 1 \end{pmatrix}
    \begin{pmatrix} 
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        \frac{1}{4} & 0 & 0 & 0 & 0 \\
        -\frac{1}{8} & \frac{1}{12} & \frac{1}{24} & 0 & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{pmatrix}
    = \frac{1}{6}, \\
    \mathbf{b} A^3 \mathbf{e} &= 
    \begin{pmatrix} -1 \\ \frac{2}{3} \\ -\frac{1}{3} \\ \frac{2}{3} \\ 1 \end{pmatrix}
    \begin{pmatrix} 
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        \frac{1}{24} & 0 & 0 & 0 & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{pmatrix}
    = \frac{1}{24}, \\
    \mathbf{b} A^4 \mathbf{e} &= 
    \begin{pmatrix} -1 \\ \frac{2}{3} \\ -\frac{1}{3} \\ \frac{2}{3} \\ 1 \end{pmatrix}
    \begin{pmatrix} 
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{pmatrix}
    = 0, \\
\end{align*}
\sphinxAtStartPar
So the stability function is \(R(z) = 1 + z + \frac{1}{2} z^2 + \frac{1}{6} z^3 + \frac{1}{24} z^4\)
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 4.2}

\sphinxAtStartPar
Determine the stability function of the following Runge\sphinxhyphen{}Kutta method. Is this an A\sphinxhyphen{}stable method?
\begin{align*}
    \begin{array}{c|cc}
        \frac{1}{4} & \frac{7}{24} & -\frac{1}{24}\\
        \frac{3}{4} & \frac{13}{24} & \frac{5}{24}\\ \hline
        & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}\subsubsection*{Solution}
\begin{align*}
    R(z) &= \frac{\det \left( 
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} - z
    \begin{pmatrix} \frac{7}{24} & -\frac{1}{24} \\ \frac{13}{24} & \frac{5}{24} \end{pmatrix} + z
    \begin{pmatrix} \frac{1}{2} & 0 \\ 0 & \frac{1}{2} \end{pmatrix} \right)}{\det \left(
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} - z
    \begin{pmatrix} \frac{7}{24} & -\frac{1}{24} \\ \frac{13}{24} & \frac{5}{24} \end{pmatrix} \right)} \\
    &= \frac{\det 
    \begin{pmatrix} 1 + \frac{5}{24} z & \frac{1}{24} z \\ -\frac{13}{24} z & 1 + \frac{7}{24} z \end{pmatrix}}{\det
    \begin{pmatrix} 1 - \frac{7}{24} z & \frac{1}{24} z \\ -\frac{13}{34} z & 1 - \frac{5}{24} z \end{pmatrix}}
    = \frac{1 + \frac{1}{2} z + \frac{1}{12} z^2}{1 - \frac{1}{2} z + \frac{1}{12} z^2}.
\end{align*}
\sphinxAtStartPar
Check the roots of \(Q(z)\)
\begin{align*}
    0 &= 1 - \frac{1}{2} z + \frac{1}{12} z^2, \\
    \therefore z &= \frac{\frac{1}{2} \pm \sqrt{-\frac{1}{3}}}{\frac{1}{6}}
    = 3 \pm \sqrt{3}i,
\end{align*}
\sphinxAtStartPar
so the roots of \(Q(z)\) have positive real parts so the first condition for A\sphinxhyphen{}stability is satisfied.

\sphinxAtStartPar
Check that \(E(y) \geq 0\)
\begin{align*}
    E(y) &= \left( 1 - \frac{1}{2} i y - \frac{1}{12} y^2 \right)
    \left( 1 + \frac{1}{2} i y - \frac{1}{12} y^2 \right) \\
    & \qquad -
    \left( 1 - \frac{1}{2} i y - \frac{1}{12} y^2 \right)
    \left( 1 + \frac{1}{2} i y - \frac{1}{12} y^2 \right) = 0
\end{align*}
\sphinxAtStartPar
so \(E(y) \geq 0\) and the second condition for A\sphinxhyphen{}stability is satisfied. Since both conditions are satisfied then this method is A\sphinxhyphen{}stable
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 4.3}

\sphinxAtStartPar
Plot the region of absolute stability for the following Runge\sphinxhyphen{}Kutta method.
\begin{align*}
    \begin{array}{c|cc}
        \frac{1}{3} & \frac{1}{3} & 0\\
        1 & 1 & 0\\ \hline
        & \frac{3}{4} & \frac{1}{4}
    \end{array}
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Determine the stability function
\begin{align*}
    R(z) &= \frac{\left( 
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} - z
    \begin{pmatrix} \frac{1}{3} & 0 \\ 1 & 0 \end{pmatrix} - z
    \begin{pmatrix} \frac{3}{4} & 0 \\ 0 & \frac{1}{4} \end{pmatrix} \right)}{ \det \left(
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix} - z
    \begin{pmatrix} \frac{1}{3} & 0 \\ 1 & 0 \end{pmatrix} \right)} \\
    &= \frac{\det
    \begin{pmatrix} 1 - \frac{13}{12} z & 0 \\ -z & 1 - \frac{1}{4} z \end{pmatrix}}{\det
    \begin{pmatrix} 1 - \frac{1}{3} z & 0  \\ -z & 1 \end{pmatrix}}
    = \frac{1 + \frac{2}{3} z + \frac{5}{48} z^2}{1 - \frac{1}{3} z}
\end{align*}
\sphinxAtStartPar
Plot
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4.5_Stability_exercises_5_3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Generate z values}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{X} \PYG{o}{+} \PYG{n}{Y} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}

\PYG{c+c1}{\PYGZsh{} Define stability function}
\PYG{n}{R} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{Z} \PYG{o}{+} \PYG{l+m+mi}{5} \PYG{o}{/} \PYG{l+m+mi}{48} \PYG{o}{*} \PYG{n}{Z} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{Z}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot stability region}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}99ccff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{equal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Re\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Im\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 4.4}

\sphinxAtStartPar
Calculate the stiffness ratio for the following system of ODEs.
\begin{align*}
    y_1' &= -80.6 y_1 + 119.4 y_2,\\
    y_2' &= 79.6 y_1 - 120.4 y_2.
\end{align*}
\sphinxAtStartPar
What are the maximum step lengths that the Euler method is stable for solving each equation?
\subsubsection*{Solution}

\sphinxAtStartPar
Calculate the eigenvalues of the coefficient matrix
\begin{align*}
    0 &= \begin{vmatrix} -80.6 - \lambda & 119.4 \\ 79.6 & -120.4 - \lambda \end{vmatrix}
    = \lambda^2 + 201 \lambda + 200, \\
    \therefore \lambda &= \frac{-201 \pm 199}{2} = -200, -1
\end{align*}
\sphinxAtStartPar
so the stiffness ratio is \(S = 200\). The Euler method is stable for \(h\lambda \in [-2, 0]\) so the maximum step length is
\begin{equation*}
\begin{split}h = \frac{-2}{\min(-200, -1)} = \frac{-2}{-200} = 0.01.\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxstepscope


\chapter{Boundary Value Problems}
\label{\detokenize{5_BVPs/5.0_BVPs:boundary-value-problems}}\label{\detokenize{5_BVPs/5.0_BVPs:bvp-chapter}}\label{\detokenize{5_BVPs/5.0_BVPs::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
understand the definition of a {\hyperref[\detokenize{5_BVPs/5.0_BVPs:bvp-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{two\sphinxhyphen{}point boundary value problem}}}} and the existence and uniqueness of its solutions;

\item {} 
\sphinxAtStartPar
apply the {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{shooting method}}}} to solve a boundary value problem;

\item {} 
\sphinxAtStartPar
implement the {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:secant-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Secant method}}}} to calculate estimates of the initial value;

\item {} 
\sphinxAtStartPar
implement the {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference method}}}} to solve boundary value problems;

\item {} 
\sphinxAtStartPar
implement the {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:thomas-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Thomas algorithm}}}} to solve a tridiagonal system of linear equations.

\end{itemize}


\bigskip\hrule\bigskip



\section{General two\sphinxhyphen{}point boundary value problem}
\label{\detokenize{5_BVPs/5.0_BVPs:general-two-point-boundary-value-problem}}\label{\detokenize{5_BVPs/5.0_BVPs:bvp-section}}
\sphinxAtStartPar
A \sphinxstylestrong{Boundary Value Problem (BVP)} is an ODE where the solutions at the boundaries of the domain are known.

\begin{sphinxadmonition}{note}{Definition: General two\sphinxhyphen{}point boundary value problem}

\sphinxAtStartPar
A two\sphinxhyphen{}point boundary value problem is a second\sphinxhyphen{}order ODE where the solutions at the lower and upper boundaries of the domain are known
\begin{equation}\label{equation:5_BVPs/5.0_BVPs:bvp-equation}
\begin{split}y'' = f(t,y),\qquad  t\in [a, b],\qquad y(a) = \alpha ,\qquad y(b) = \beta,\end{split}
\end{equation}
\sphinxAtStartPar
for some known values \(\alpha\) and \(\beta\).
\end{sphinxadmonition}


\section{Existence and uniqueness of solutions to boundary value problems}
\label{\detokenize{5_BVPs/5.0_BVPs:existence-and-uniqueness-of-solutions-to-boundary-value-problems}}\label{\detokenize{5_BVPs/5.0_BVPs:existence-and-uniqueness-of-bvp-solutions-section}}
\sphinxAtStartPar
If an initial value problem has a solution it will be unique for a particular initial value. This is not true for boundary value problems which can have a unique solution, no solution or an infinite number of solutions. Consider the following boundary value problem
\begin{align*}
    y'' + 4y = 0, \qquad y(0) = 1, \qquad y\left(\dfrac{\pi}{4}\right) = 2.
\end{align*}
\sphinxAtStartPar
The general solution to the ODE \(y'' + 4y = 0\) is
\begin{align*}
    y = c_1 \cos(2 t) + c_2 \sin(2 t),
\end{align*}
\sphinxAtStartPar
so substituting the boundary values we have
\begin{align*}
    1 &= c_2 \cos(0) + c_2 \sin(0) = c_1, \\
    2 &= c_2 \cos\left(\frac{\pi}{2}\right) + c_2 \sin\left(\frac{\pi}{2}\right) = c_2.
\end{align*}
\sphinxAtStartPar
Here we can determine the values of \(c_1\) and \(c_2\) so this boundary value problem has the unique solution
\begin{align*}
    y = \cos(t) + 2\sin(t).
\end{align*}
\sphinxAtStartPar
Now consider the boundary value problem
\begin{align*}
    y'' + 4y = 0, \qquad y(0) = 1, \qquad y(2\pi) = 1.
\end{align*}
\sphinxAtStartPar
and substituting the boundary values we have
\begin{align*}
    1 &= c_1 \cos(0) + c_2 \sin(0) = c_1, \\
    1 &= c_1 \cos(2\pi) + c_2 \sin(2\pi) = c_1.
\end{align*}
\sphinxAtStartPar
Here we have a solution for \(c_1\) but we cannot determine the value of \(c_2\) so the solution to the boundary value problem is
\begin{align*}
    y = \cos(t) + c_2 \sin(t),
\end{align*}
\sphinxAtStartPar
where \(c_2\) can be any value. So we have infinitely many solutions. Finally consider the boundary value problem
\begin{align*}
    y'' + 4y = 0, \qquad y(0) = 1, \qquad y(2\pi) = 1.
\end{align*}
\sphinxAtStartPar
and substituting the boundary values we have
\begin{align*}
    1 &= c_1 \cos(0) + c_2 \sin(0) = c_1, \\
    2 &= c_1 \cos(2\pi) + c_2 \sin(2\pi) = c_1.
\end{align*}
\sphinxAtStartPar
Here we have \(c_1 = 1\) and \(c_2 = 2\) which is a contradiction so this boundary value problem does not have a solution.

\begin{sphinxadmonition}{note}{Theroem: Uniqueness of the solution to boundary value problems}

\sphinxAtStartPar
A linear boundary value problem of the form
\begin{equation}\label{equation:5_BVPs/5.0_BVPs:bvp-uniqueness-equation}
\begin{split}y'' = p(t)y' + q(t)y + r(t), \qquad t \in [a,b], \qquad y(a) = \alpha , \qquad y(b) = \beta ,\end{split}
\end{equation}
\sphinxAtStartPar
where \(p(t)\), \(q(t)\) and \(r(t)\) are some functions of \(t\) then it has a unique solution if the following are satisfied
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p(t)\), \(q(t)\) and \(r(t)\) are continuous on \([a, b]\);

\item {} 
\sphinxAtStartPar
\(q(t) > 0\) for all \(t\in [a,b]\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 5.1}

\sphinxAtStartPar
Show that the following boundary value problem has a unique solution
\begin{align*}
    y'' = (t^3 +5)y + \sin (t), \qquad t \in [0,1], \qquad y(0) = 0, \qquad y(1) = 1.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Comparing this boundary value problem to equation \eqref{equation:5_BVPs/5.0_BVPs:bvp-uniqueness-equation} we have
\begin{align*}
    p(t) &= 0,\\
    q(t) &= t^3 + 5,\\
    r(t) &= \sin(t),
\end{align*}
\sphinxAtStartPar
which are all continuous on \([0,1]\) and \(q(t)\geq \) for all \(t\in [0,1]\) so this boundary value problem has a unique solution.
\end{sphinxadmonition}

\sphinxstepscope


\section{The shooting method}
\label{\detokenize{5_BVPs/5.1_Shooting_method:the-shooting-method}}\label{\detokenize{5_BVPs/5.1_Shooting_method:shooting-method-section}}\label{\detokenize{5_BVPs/5.1_Shooting_method::doc}}
\sphinxAtStartPar
Consider the two\sphinxhyphen{}point boundary value problem
\begin{equation*}
\begin{split}y'' = f(t,y), \qquad t \in [a, b], \qquad y(a) = \alpha ,\qquad y(b) = \beta.\end{split}
\end{equation*}
\sphinxAtStartPar
Since the ODE solvers we use can only be applied to a first\sphinxhyphen{}order ODE we need to rewrite the second\sphinxhyphen{}order ODE as a system of two first\sphinxhyphen{}order ODEs
\begin{align*}
    y_1' &= y_2 ,\\
    y_2' &= f(t, y_1, y_2).
\end{align*}
\sphinxAtStartPar
Since we have let \(y_1 = y\) we know that \(y_1(a) = \alpha\) from the definition of the boundary value problem but we do not know the value of \(y_2(a)\). To overcome this problem we simply guess this value and compute the solutions to the initial value problem and compare the solution of \(y_1(b)\) to \(\beta\) and then adjust the guess value accordingly. This method is called the \sphinxstylestrong{shooting method} because someone shooting at a target will adjust their next shot based where their previous shot landed.

\begin{sphinxadmonition}{note}{Example 5.2}

\sphinxAtStartPar
Use the Euler method with a step length of \(h = 0.2\) and the shooting method to solve the following boundary value problem
\begin{align*}
    y'' - y' - y = 0, \qquad y(0) = 0, \qquad y(1) = 2.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Rewriting this as a system of first\sphinxhyphen{}order ODEs gives
\begin{align*}
    y_1' &= y_2, & y_1 (0) &= 1, &&\\
    y_2' &= y_1 +y_2, & y_2 (0) &= s, &&
\end{align*}
\sphinxAtStartPar
where \(s\) is a guess of \(y'(0)\).

\sphinxAtStartPar
The Euler method solutions using a guess value of \(y'(0) = 1\) is tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_2\)
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
1.0000
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
0.2000
&
\sphinxAtStartPar
1.2000
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.4400
&
\sphinxAtStartPar
1.4800
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
0.7360
&
\sphinxAtStartPar
1.8640
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.1088
&
\sphinxAtStartPar
2.3840
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
1.5856
&
\sphinxAtStartPar
3.0826
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The numerical solution at the upper boundary is \(y_1(5) = 1.5856\) which is less than the boundary value of \(y(1) = 2\). Lets try again but with an increased guess value of \(y'(0) = 2\).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_2\)
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
2.0000
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
0.4000
&
\sphinxAtStartPar
2.4000
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.8800
&
\sphinxAtStartPar
2.9600
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
1.4720
&
\sphinxAtStartPar
3.7280
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
2.2176
&
\sphinxAtStartPar
4.7680
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
3.1712
&
\sphinxAtStartPar
6.1651
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Here we have \(y_1(5) = 3.1712\) which is greater than 2. Lets try again but with a decreased guess value of \(y'(0) = 1.5\).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_2\)
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
1.5000
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
0.3000
&
\sphinxAtStartPar
1.8000
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.6600
&
\sphinxAtStartPar
2.2200
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
1.1040
&
\sphinxAtStartPar
2.7960
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.6632
&
\sphinxAtStartPar
3.5760
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
2.3784
&
\sphinxAtStartPar
4.6238
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The solutions using the three guess values of \(s=1\), \(s=2\) and \(s=1.5\) are plotted below.
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5.1_Shooting_method_1_2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\end{sphinxadmonition}


\subsection{Improving the guess value using the secant method}
\label{\detokenize{5_BVPs/5.1_Shooting_method:improving-the-guess-value-using-the-secant-method}}\label{\detokenize{5_BVPs/5.1_Shooting_method:secant-method-section}}
\sphinxAtStartPar
In the {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-example-1}]{\sphinxcrossref{\DUrole{std,std-ref}{example}}}} we saw that by adjusting the guess value of \(y'(0)\) we obtained solutions at the upper boundary that were closer to the target value at the upper boundary \(\beta\). We could continue in this way by increasing or decreasing our guess value halfway towards the previous guess value depending on whether the solution at the upper boundary was higher or lower than the target (this method is known as the \sphinxhref{https://en.wikipedia.org/wiki/Bisection\_method}{bisection method}), however a more efficient approach is to use the \sphinxhref{https://en.wikipedia.org/wiki/Secant\_method}{Secant method}. The Secant method is a root finding algorithm that calculates the value of \(s\) where \(g(s)=0\) for some function \(g\)
\begin{equation}\label{equation:5_BVPs/5.1_Shooting_method:secant-method-equation}
\begin{split}s_{i+1} = s_i - g(s_i)\frac{s_i - s_{i-1}}{g(s_i) - g(s_{i-1})}.\end{split}
\end{equation}
\sphinxAtStartPar
This expression is iterated until two successive values of \(s\) are less than some small number, i.e., \(|s_i - s_{i-1}| < tol\). Since we want the solution of \(y'(a)\) to be equal to the upper boundary value \(\beta\) we can define the function
\begin{align*}
    g(s) = y'(a) - y_n.
\end{align*}
\sphinxAtStartPar
Using the Secant method to find the root \(g(s) = 0\) will give the value of \(y'(0)\).

\begin{sphinxadmonition}{note}{Example 5.3}

\sphinxAtStartPar
Use the secant method to calculate the next guess value \(s\) for the solution of the boundary value problem {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-example-1}]{\sphinxcrossref{\DUrole{std,std-ref}{example 5.2}}}}.
\subsubsection*{Solution}

\sphinxAtStartPar
From {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-example-1}]{\sphinxcrossref{\DUrole{std,std-ref}{example 5.2}}}} we have \(s_1 = 2\) and \(s_2 = 1.5\) which resulted in solutions at the upper boundary of \(y_5(s = 1) = 1.5856\), \(y_5(s = 2) = 3.1712\) and \(y_5(s = 1.5) = 2.3784\). The values of \(g(s_1)\) and \(g(s_2)\) are
\begin{align*}
        g(s_1) &= 2 - 3.1712 = -1.1712, \\
        g(s_2) &= 2 - 2.3784 = -0.3784, 
\end{align*}
\sphinxAtStartPar
therefore using equation \eqref{equation:5_BVPs/5.1_Shooting_method:secant-method-equation} the next guess value calculated using the secant method is
\begin{align*}
    s_3 &= s_2 - g(s_2) \left( \frac{s_2 - s_1}{g(s_2) - g(s_1)} \right) \\
    &= 1.5 - (-0.3784) \left( \frac{1.5 - 2}{-0.3784 - (-1.1712)} \right) = 1.2614. 
\end{align*}
\sphinxAtStartPar
The solution using a guess value of \(s = 1.2614\) are tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_2\)
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
1.2614
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
0.2523
&
\sphinxAtStartPar
1.5136
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.5550
&
\sphinxAtStartPar
1.8668
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
0.9284
&
\sphinxAtStartPar
2.3512
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.3986
&
\sphinxAtStartPar
3.0071
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
2.0000
&
\sphinxAtStartPar
3.8882
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Here the solution at the upper boundary is \(y_5 = 2\) which is equal to \(y(5)=2\) correct to (at least) 4 decimal places.
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5.1_Shooting_method_6_2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{5_BVPs/5.1_Shooting_method:python-code}}
\sphinxAtStartPar
The code below defines a function called \sphinxcode{\sphinxupquote{shooting\_method()}} that calculates the solution to a boundary value problem using the shooting method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{shooting\PYGZus{}method}\PYG{p}{(}\PYG{n}{solver}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{bvals}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{s}\PYG{p}{,} \PYG{n}{so}\PYG{p}{,} \PYG{n}{go} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{solver}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{p}{[}\PYG{n}{bvals}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{bvals}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{s}\PYG{p}{,} \PYG{n}{so}\PYG{p}{,} \PYG{n}{go} \PYG{o}{=} \PYG{n}{s} \PYG{o}{\PYGZhy{}} \PYG{n}{g} \PYG{o}{*} \PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZhy{}} \PYG{n}{so}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{g} \PYG{o}{\PYGZhy{}} \PYG{n}{go}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{g}
        \PYG{k}{if} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZhy{}} \PYG{n}{so}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The inputs are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solver}} \sphinxhyphen{} the name of the solver function, e.g., \sphinxcode{\sphinxupquote{euler}}, \sphinxcode{\sphinxupquote{rk4}} etc.;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{f}} \sphinxhyphen{} the name of the ODE function;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tspan}} \sphinxhyphen{} an array of two values defining the boundaries of the \(t\) domain;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bvals}} \sphinxhyphen{} an array of two values defining the upper and lower boundary values;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{h}} \sphinxhyphen{} the step length used in the \sphinxcode{\sphinxupquote{solver}} function

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tol}} \sphinxhyphen{} the convergence tolerance for the Secant method (optional, default is \(tol=10^{-6}\)).

\end{itemize}

\sphinxAtStartPar
The variables \sphinxcode{\sphinxupquote{s}}, \sphinxcode{\sphinxupquote{so}}, \sphinxcode{\sphinxupquote{g}} and \sphinxcode{\sphinxupquote{go}} are the current and old values of the guess value \(s\) and function \(g(s)\) which are intialised to ensure that at least two iterations of the Secant method are performed. The function calculates the solution to the initial value problem with the initial solution \sphinxcode{\sphinxupquote{{[}bvals{[}0{]}, s{]}}} and uses the last solution for \(y_1\) to calculate the next guess value using the Secant method. The iterations cease when the difference between two successive guess values are less than \sphinxcode{\sphinxupquote{tol}}


\subsection{A note about accuracy}
\label{\detokenize{5_BVPs/5.1_Shooting_method:a-note-about-accuracy}}
\sphinxAtStartPar
In {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:secant-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 5.3}}}} we iterated the Secant method until convergence and got a very accurate solution for the value of \(y(b)\). We must be careful not to forget that this solution was obtained using the Euler method which being only first\sphinxhyphen{}order so expect it to be relatively inaccurate for the other values in the domain.

\sphinxAtStartPar
The exact solution to the boundary value problem used here is
\begin{align*}
    y = \frac{2e^{(1 - \sqrt{5})(t - 1)/2} (e^{\sqrt{5}t} - 1)}{e^{\sqrt{5}} - 1}.
\end{align*}
\sphinxAtStartPar
and the solutions using the Euler method and the second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method have been tabulated below and plotted in \hyperref[\detokenize{5_BVPs/5.1_Shooting_method:bvp-euler-rk4-figure}]{Fig.\@ \ref{\detokenize{5_BVPs/5.1_Shooting_method:bvp-euler-rk4-figure}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Euler
&\sphinxstyletheadfamily 
\sphinxAtStartPar
RK4
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Euler error
&\sphinxstyletheadfamily 
\sphinxAtStartPar
RK4 error
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
0.00e+00
&
\sphinxAtStartPar
0.00e+00
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
0.2523
&
\sphinxAtStartPar
0.2213
&
\sphinxAtStartPar
0.2213
&
\sphinxAtStartPar
3.10e\sphinxhyphen{}02
&
\sphinxAtStartPar
1.41e\sphinxhyphen{}05
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.5550
&
\sphinxAtStartPar
0.5014
&
\sphinxAtStartPar
0.5014
&
\sphinxAtStartPar
5.36e\sphinxhyphen{}02
&
\sphinxAtStartPar
2.50e\sphinxhyphen{}05
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
0.9284
&
\sphinxAtStartPar
0.8659
&
\sphinxAtStartPar
0.8658
&
\sphinxAtStartPar
6.25e\sphinxhyphen{}02
&
\sphinxAtStartPar
3.00e\sphinxhyphen{}05
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.3986
&
\sphinxAtStartPar
1.3494
&
\sphinxAtStartPar
1.3494
&
\sphinxAtStartPar
4.92e\sphinxhyphen{}02
&
\sphinxAtStartPar
2.42e\sphinxhyphen{}05
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
2.0000
&
\sphinxAtStartPar
2.0000
&
\sphinxAtStartPar
2.0000
&
\sphinxAtStartPar
0.00e+00
&
\sphinxAtStartPar
0.00e+00
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5.1_Shooting_method_8_2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Solutions to the boundary value problem \(y'' - y' - y = 0\), \(t \in [0,1]\), \(y(0) = 0\), \(y(1) = 2\) using the Euler and RK4 methods with \(h=0.2\).}\label{\detokenize{5_BVPs/5.1_Shooting_method:bvp-euler-rk4-figure}}\end{figure}

\sphinxAtStartPar
So despite the Secant method giving a guess value that gives an accurate solution at the upper boundary, the use of the Euler method does not give an accurate solution across the domain. The solution using the second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method in comparison gives much more accurate solutions over the domain.

\sphinxstepscope


\section{The finite\sphinxhyphen{}difference method}
\label{\detokenize{5_BVPs/5.2_Finite_difference_method:the-finite-difference-method}}\label{\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}}\label{\detokenize{5_BVPs/5.2_Finite_difference_method::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{finite\sphinxhyphen{}difference method} for solving a boundary value problem replaces the derivatives in the ODE with \sphinxstylestrong{finite\sphinxhyphen{}difference approximations} derived from the Taylor series. This results in linear system of algebraic equations that can be solved to give an approximation of the solution to the BVP.

\sphinxAtStartPar
The derivatives of \(y_i\) are approximated using values of neighbouring nodes \(y_{i+1}\), \(y_{i-1}\) etc. using expressions derived by truncating the {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}} and rearranging to make the derivative term the subject. Some common finite\sphinxhyphen{}difference approximations are listed in the table below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Finite\sphinxhyphen{}difference approximation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Order
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
\\
\hline
\sphinxAtStartPar
\(y' = \dfrac{y_{i+1} - y_i}{h}\)
&
\sphinxAtStartPar
first
&
\sphinxAtStartPar
forward difference
\\
\hline
\sphinxAtStartPar
\(y' = \dfrac{y_i - y_{i-1}}{h}\)
&
\sphinxAtStartPar
first
&
\sphinxAtStartPar
backward difference
\\
\hline
\sphinxAtStartPar
\(y' = \dfrac{y_{i+1} - y_{i-1}}{2h}\)
&
\sphinxAtStartPar
second
&
\sphinxAtStartPar
central difference
\\
\hline
\sphinxAtStartPar
\(y'' = \dfrac{y_{i-1} - 2 y_i + y_{i+1}}{h^2}\)
&
\sphinxAtStartPar
second
&
\sphinxAtStartPar
symmetric difference
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The solution to a boundary value problem using then finite\sphinxhyphen{}difference method is determined by approximating the derivatives in the ODE using finite\sphinxhyphen{}differences. Consider the following boundary value problem
\begin{align*}
    y'' = f(t,y), \qquad t \in [a, b], \qquad y(a) = \alpha, \qquad y(b) = \beta.
\end{align*}
\sphinxAtStartPar
Using the symmetric difference to approximate \(y''\) in the ODE we have
\begin{align*}
    y_{i-1} - 2y_i + y_{i+1} = h^2 f(t_i ,y_i).
\end{align*}
\sphinxAtStartPar
Since we know that \(y_0 = \alpha\) and \(y_n = \beta\) then the first and last equations become we have a system of \(n\) equations
\begin{align*}
    y_0 &= \alpha, \\
    y_0 - 2y_1 + y_2 &= h^2 f(t_1, y_1), \\
    y_1 - 2y_1 + y_3 &= h^2 f(t_2, y_2), \\
    & \vdots \\
    y_{n-3} - 2y_{n-2} + y_{n-1} &= h^2 f(t_{n-2}, y_{n-2}), \\
    y_{n-2} - 2y_{n-1} + y_{n} &= h^2 f(t_{n-1}, y_{n-1}), \\
    y_{n} &= \beta,
\end{align*}
\sphinxAtStartPar
which can be written as the matrix equation
\begin{align*}
    \begin{pmatrix}
        1 & 0 &  &  \\
        1 & -2 & 1 &  & & \\
        & 1 & -2 & 1 & & \\
        & & \ddots & \ddots & \ddots & \\
        & & & 1 & -2 & 1 \\
        & & & & 1 & -2 & 1 \\
        & & & & & 0 & 1
    \end{pmatrix}
    \begin{pmatrix} y_0 \\ y_1 \\ y_2 \\ \vdots \\ y_{n-2} \\ y_{n-1} \\ y_n \end{pmatrix} =
    \begin{pmatrix} \alpha \\ f(t_1, y_1) \\ f(t_2, y_2) \\ \vdots \\ f(t_{n-2},y_{n-2}) \\ f(t_{n-1}, y_{n-1}) \\ \beta \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Once the linear system is defined it can be solved using LU decomposition.


\subsection{The Thomas algorithm}
\label{\detokenize{5_BVPs/5.2_Finite_difference_method:the-thomas-algorithm}}\label{\detokenize{5_BVPs/5.2_Finite_difference_method:thomas-algorithm-section}}
\sphinxAtStartPar
The coefficient matrix for the linear system that results from the application of the second\sphinxhyphen{}order symmetric finite\sphinxhyphen{}difference approximation of \(y''\) is \sphinxhref{https://en.wikipedia.org/wiki/Tridiagonal\_matrix}{tridiagonal} (the only non\sphinxhyphen{}zero elements are on the main, lower and upper diagonals). The usual methods for solving linear systems of equations such as Gaussian elimination and LU decomposition could be applied here, however there is a more efficient method that can solve tridiagonal systems called the \sphinxhref{https://en.wikipedia.org/wiki/Tridiagonal\_matrix\_algorithm}{\sphinxstylestrong{Thomas algorithm}}.

\begin{sphinxadmonition}{note}{Definition: The Thomas algorithm}

\sphinxAtStartPar
Given a tridiagonal linear system of equations of the form
\begin{align*}
    \begin{pmatrix} 
        b_1 & c_1 \\
        a_2 & b_2 & c_2 \\
        & \ddots & \ddots & \ddots \\
        & & a_{n-1} & b_{n-1} & c_{n-1} \\
        & & & a_n & b_n
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ \vdots \\ x_{n-1} \\ x_n \end{pmatrix} =
    \begin{pmatrix} d_1 \\ d_2 \\ \vdots \\ d_{n-1} \\ d_n \end{pmatrix},
\end{align*}
\sphinxAtStartPar
the solution can be found by performing a forward sweep on the \(b_i\) and \(d_i\) coefficients
\begin{align*}
    b_i &= b_i - c_{i-1} \left( \frac{a_i}{b_{i-1}} \right), & i = 2, 3, \ldots, n, \\
    d_i &= d_i - d_{i-1} \left( \frac{a_i}{b_{i-1}} \right), & i = 2, 3, \ldots, n, 
\end{align*}
\sphinxAtStartPar
and then calculate the values of \(x_i\) using back substitution
\begin{align*}
    x_n &= \frac{d_n}{b_n}, \\
    x_i &= \frac{d_i - c_i x_{i+1}}{b_i}, \qquad i = n-1, n-2, \ldots, 1.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 5.4}

\sphinxAtStartPar
Use the finite\sphinxhyphen{}difference method to solve the boundary below using a step length of \(h = 0.2\)
\begin{align*}
    y'' - y' - y = 0, \qquad y(0) = 0, \qquad y(1) = 2.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Using a forward difference to approximate \(y'\) and a symmetric difference to approximate \(y''\) we have
\begin{align*}
    \frac{y_{i-1} -2y_i +y_{i+1} }{h^2 }-\frac{y_{i+1} -y_i }{h}-y_i = 0,
\end{align*}
\sphinxAtStartPar
which can be simplified to
\begin{align*}
    y_{i-1} +(h-h^2 -2)y_i +(1-h)y_{i+1} = 0.
\end{align*}
\sphinxAtStartPar
This gives the following system of linear equations
\begin{align*}
    y_0 &= 0, \\
    y_0 + (h - h^2 - 2) y_1 + (1 - h) y_2 &= 0, \\
    y_1 + (h - h^2 - 2) y_2 + (1 - h) y_3 &= 0, \\
    &\vdots \\
    y_{n-2} + (h - h^2 - 2) y_{n-1} + (1 - h) y_n &= 0, \\
    y_n &= 2.
\end{align*}
\sphinxAtStartPar
which we can write the linear system as the matrix equation
\begin{align*}
    \begin{pmatrix}
        1 & 0 & &  &  & \\
        1 & h-h^2 -2 & 1-h &  &  & \\
        &  \ddots  & \ddots  & \ddots  & \\
        &  & 1 & h-h^2 -2 & 1-h \\
        &  &  & 0 & 1
    \end{pmatrix} 
    \begin{pmatrix} y_0 \\ y_1 \\ \vdots \\ y_{n-1} \\ y_n \end{pmatrix}  =
    \begin{pmatrix} 0 \\ 0 \\ \vdots \\ 0 \\ 2  \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
If we use a step length of \(h=0.2\) we have
\begin{align*}
    \mathbf{t} = (0, 0.2, 0.4, 0.6, 0.8, 1),
\end{align*}
\sphinxAtStartPar
and
\begin{align*}
    \begin{pmatrix}
        1 & 0 \\
        1 & -1.84 & 0.8 \\
        & 1 & -1.84 & 0.8 \\
        & & 1 & -1.84 & 0.8 \\
        & & & 1 & -1.84 & 0.8 \\
        & & & & 0 & 1
    \end{pmatrix}
    \begin{pmatrix} y_0 \\ y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \end{pmatrix} = 
    \begin{pmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 2 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Performing the forward sweep of the Thomas algorithm
\begin{align*}
    b_1 &= 1, \\ 
    b_2 &= b_2 - c_1 \left( \frac{a_2}{b_1} \right) = -1.84 - 0.8 \left( \frac{1}{1} \right) = -2.64, \\
    b_3 &= b_3 - c_2 \left( \frac{a_3}{b_2} \right) = -1.84 - 0.8 \left( \frac{1}{-2.64} \right) = -1.405217, \\
    b_4 &= b_4 - c_3 \left( \frac{a_4}{b_3} \right) = -1.84 - 0.8 \left( \frac{1}{-1.405217} \right) = -1.270693, \\
    b_5 &= b_5 - c_4 \left( \frac{a_5}{b_4} \right) = -1.84 - 0.8 \left( \frac{1}{-1.270693} \right) = -1.210422, \\
    b_6 &= b_6 - c_5 \left( \frac{a_6}{b_5} \right) = 1 - 0.8 \left( \frac{0}{-1.210422} \right) = 1, \\
    d_1 &= 0, \\
    d_2 &= d_2 - d_1 \left( \frac{a_2}{b_1} \right) = 0 - 0 \left( \frac{1}{1} \right) = 0, \\
    d_3 &= d_3 - d_2 \left( \frac{a_3}{b_2} \right) = 0 - 0 \left( \frac{1}{-2.64} \right) = 0, \\
    d_4 &= d_4 - d_3 \left( \frac{a_4}{b_3} \right) = 0 - 0 \left( \frac{1}{-1.405217} \right) = 0, \\
    d_5 &= d_5 - d_4 \left( \frac{a_5}{b_4} \right) = 0 - 0 \left( \frac{1}{-1.270693} \right) = 0, \\
    d_6 &= d_6 - d_5 \left( \frac{a_6}{b_5} \right) = 2 - 0 \left( \frac{0}{-1.270693} \right) = 2, \\
\end{align*}
\sphinxAtStartPar
Performing the back substitution
\begin{align*}
    y_6 &= \frac{d_6}{b_6} = \frac{2}{1} = 2, \\
    y_5 &= \frac{d_5 - c_5 y_6}{b_5} = \frac{0 - 0.8(2)}{-1.210422} = 1.321853, \\
    y_4 &= \frac{d_4 - c_4 y_5}{b_4} = \frac{0 - 0.8(1.321853)}{-1.270693} = 0.832209, \\
    y_3 &= \frac{d_3 - c_3 y_4}{b_3} = \frac{0 - 0.8(0.832209)}{-1.405217} = 0.473782, \\
    y_2 &= \frac{d_2 - c_2 y_3}{b_2} = \frac{0 - 0.8(0.473782)}{-2.64} = 0.205992, \\
    y_1 &= \frac{d_1 - c_1 y_2}{b_1} = \frac{0 - 0(0.205992)}{1} = 0, \\
\end{align*}
\sphinxAtStartPar
The solutions to this boundary value problem using the finite\sphinxhyphen{}difference method are tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Error
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
0.0000
&
\sphinxAtStartPar
0.00e+00
\\
\hline
\sphinxAtStartPar
0.20
&
\sphinxAtStartPar
0.2060
&
\sphinxAtStartPar
0.2213
&
\sphinxAtStartPar
1.53e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.4738
&
\sphinxAtStartPar
0.5014
&
\sphinxAtStartPar
2.76e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.60
&
\sphinxAtStartPar
0.8322
&
\sphinxAtStartPar
0.8658
&
\sphinxAtStartPar
3.36e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.3219
&
\sphinxAtStartPar
1.3494
&
\sphinxAtStartPar
2.76e\sphinxhyphen{}02
\\
\hline
\sphinxAtStartPar
1.00
&
\sphinxAtStartPar
2.0000
&
\sphinxAtStartPar
2.0000
&
\sphinxAtStartPar
0.00e+00
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{5_BVPs/5.2_Finite_difference_method:python-code}}
\sphinxAtStartPar
The code below calculates the solution to the boundary value problem in  {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-finite-difference-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 5.4}}}}. The coefficient arrays \sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{c}} along with the constant vector \sphinxcode{\sphinxupquote{d}} are defined for this problem and the \sphinxcode{\sphinxupquote{tridiagonal\_solver()}} function is used to solve the linear system. Note that the values in \sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{b}}, \sphinxcode{\sphinxupquote{c}} and \sphinxcode{\sphinxupquote{d}} are specific to the problem being solved and will need to be changed when solving other boundary value problems.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{tridiagonal\PYGZus{}solver}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{/} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/} \PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    
    \PYG{k}{return} \PYG{n}{x}
    
    
\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{*} \PYG{n}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}
 

\PYG{c+c1}{\PYGZsh{} Define BVP parameters}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{bvals} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundary values}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.2}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{d}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{bvals}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{h} \PYG{o}{\PYGZhy{}} \PYG{n}{h} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}
    \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{h}
    \PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
        
\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{tridiagonal\PYGZus{}solver}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print table of solution values}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  t   |   y    | Exact  |  Error   |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{4.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{6.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{6.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{6.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    
\PYG{c+c1}{\PYGZsh{} Plot solution}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Finite\PYGZhy{}difference method}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|  t   |   y    | Exact  |  Error   |
|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|
| 0.00 | 0.0000 | 0.0000 | 0.00e+00 |
| 0.20 | 0.2060 | 0.2213 | 1.53e\PYGZhy{}02 |
| 0.40 | 0.4738 | 0.5014 | 2.76e\PYGZhy{}02 |
| 0.60 | 0.8322 | 0.8658 | 3.36e\PYGZhy{}02 |
| 0.80 | 1.3219 | 1.3494 | 2.76e\PYGZhy{}02 |
| 1.00 | 2.0000 | 2.0000 | 0.00e+00 |
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{5.2_Finite_difference_method_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Accuracy vs number of nodes}
\label{\detokenize{5_BVPs/5.2_Finite_difference_method:accuracy-vs-number-of-nodes}}
\sphinxAtStartPar
The solutions seen in {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-finite-difference-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 5.4}}}} seem to show that the finite\sphinxhyphen{}difference method produces reasonably accurate results for this boundary value problem. One way to improve on the accuracy of our solution is to increase the number of nodes used.

\sphinxAtStartPar
Consider the solution of the following BVP using the finite\sphinxhyphen{}difference method
\begin{align*}
    y'' + 3ty' + 7y = \cos (2t), \qquad y(0) = 1, \qquad y(3) = 0.
\end{align*}
\sphinxAtStartPar
Using forward and symmetric differences to approximate \(y'\) and \(y''\) respectively gives
\begin{align*}
    \frac{y_{i-1} - 2y_i + y_{i+1}}{h^2} + 3t_i \left( \frac{y_{i+1} - y_i}{h}\right) + 7y_i &= \cos(2t_i) \\
    y_{i-1} + (7h^2 - 3ht_i - 2)y_i + (1 + 3ht_i)y_{i+1} &= h^2 \cos(2t_i).
\end{align*}
\sphinxAtStartPar
So the linear system is
\begin{align*}
    \begin{pmatrix} 
        1 & 0 \\
        1 & 7h^2 - 3ht_1 - 2 & 1 + 3ht_1 \\
        & \ddots & \ddots & \ddots \\
        && 1 & 7h^2 - 3ht_{N-1} - 2 & 1 + 3ht_{N-1} \\
        &&& 0 & 1
    \end{pmatrix}
    \begin{pmatrix} y_0 \\ y_1 \\ \vdots \\ y_{N-1} \\ y_N \end{pmatrix} \\
    = \begin{pmatrix} 1 \\ h^2 \cos(2t_1) \\ \vdots \\ h^2 \cos(2t_{N-1}) \\ 0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The solution of this BVP is shown in \hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-fdm-accuracy-figure-1}]{Fig.\@ \ref{\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-fdm-accuracy-figure-1}}} for \(h=0.05\) and \(h = 0.005\). Since we used a first\sphinxhyphen{}order approximation for \(y'\) the error for this method is \(O(h)\) and we expect the solution using \(h=0.005\) to be more accurate.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5.2_Finite_difference_method_4_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Solutions to the boundary value problem \(y'' + 3ty' + 7y = \cos (2t)\), \(t \in [0,3]\), \(y(0) = 1\), \(y(3) = 0\) using first\sphinxhyphen{}order finite\sphinxhyphen{}difference approximations with \(h=0.05\) and \(h=0.005\).}\label{\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-fdm-accuracy-figure-1}}\end{figure}

\sphinxAtStartPar
To obtain a more accurate solution, instead of increasing the number of nodes we could use the {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{central difference approximation}}}} (which is second\sphinxhyphen{}order accurate) to approximate \(y'\)
\begin{align*}
    \frac{y_{i-1} - 2y_i + y_{i+1}}{h^2} + 3t_i\left( \frac{y_{i+1} - y_{i-1}}{2h} \right) + 7y_i &= \cos(2t_i) \\
    (2 - 3ht_i)y_{i-1} + (14h^2 - 4)y_i + (2 + 3ht_i)y_{i+1} &= 2h^2 \cos(2t_i).
\end{align*}
\sphinxAtStartPar
So the linear system for the second\sphinxhyphen{}order finite\sphinxhyphen{}difference method is
\begin{align*}
    \begin{pmatrix} 
        1 & 0 \\
        2 - 3ht_1 & 14h^2 - 4 & 2 + 3ht_1 \\
        & \ddots & \ddots & \ddots \\
        && 2 - 3ht_{N-1} & 14h^2 - 4 & 2 + 3ht_{N-1} \\
        &&& 0 & 1
    \end{pmatrix}
    \begin{pmatrix} y_0 \\ y_1 \\ \vdots \\ y_{N-1} \\ y_N \end{pmatrix} \\
    = \begin{pmatrix} 1 \\ 2h^2 \cos(2t_1) \\ \vdots \\ 2h^2 \cos(2t_{N-1}) \\ 0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The solution using the second\sphinxhyphen{}order finite difference method with \(h=0.05\) has been plotted against the first\sphinxhyphen{}order solution using \(h=0.05\) and \(h=0.005\) in \hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-fdm-accuracy-figure-2}]{Fig.\@ \ref{\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-fdm-accuracy-figure-2}}}. The second order solution gives good agreement with the first order solution using 10 times fewer nodes.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5.2_Finite_difference_method_4_3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Solutions to the boundary value problem \(y'' + 3ty' + 7y = \cos (2t)\), \(t \in [0,3]\), \(y(0) = 1\), \(y(3) = 0\) using first\sphinxhyphen{}order and second\sphinxhyphen{}order finite\sphinxhyphen{}difference approximations with \(h=0.05\) and \(h=0.005\).}\label{\detokenize{5_BVPs/5.2_Finite_difference_method:bvp-fdm-accuracy-figure-2}}\end{figure}

\sphinxstepscope


\section{Chapter summary}
\label{\detokenize{5_BVPs/5.3_BVP_summary:chapter-summary}}\label{\detokenize{5_BVPs/5.3_BVP_summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A {\hyperref[\detokenize{5_BVPs/5.0_BVPs:bvp-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{two\sphinxhyphen{}point boundary value problem}}}} is defined by a second\sphinxhyphen{}order ODE where the solutions at the lower and upper boundaries are known.

\item {} 
\sphinxAtStartPar
A boundary value problem can have a unique solution, an infinitely number of solutions or no solutions.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{shooting method}}}} uses a guess of the value for \(y'(0)\) and adjusts the guess by comparing the computed solution at the upper boundary to the known solution.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:secant-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Secant method}}}} is used to calculate improved estimates of the guess value.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference method}}}} uses finite\sphinxhyphen{}difference approximations of the derivatives in the ODE to derive a linear system of equations that approximates the solution to the boundary value problem.

\item {} 
\sphinxAtStartPar
The higher the order of the finite\sphinxhyphen{}difference approximations, the higher the value of \(h\) can be to achieve the same accuracy.

\end{itemize}

\sphinxstepscope


\section{Boundary value problems exercises}
\label{\detokenize{5_BVPs/5.4_BVP_exercises:boundary-value-problems-exercises}}\label{\detokenize{5_BVPs/5.4_BVP_exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 5.1}

\sphinxAtStartPar
Determine which of the following BVPs have a unique solution

\sphinxAtStartPar
(a)  \(y'' = - \dfrac{4}{t} y' + \dfrac{2}{t^2 } y - \dfrac{2\ln (t)}{t^3 }, \qquad y(1) = 1/2, \qquad y(2) = \ln (2)\);
\subsubsection*{Solution (click to show)}

\sphinxAtStartPar
\(p(t) = -\dfrac{4}{t}\), \(q(t) = \dfrac{2}{t^2}\) and \(r(t) = \dfrac{2\ln(t)}{t^3}\) are all continuous and \(q(t) > 0\) for \(t \in [1, 2]\) so this boundary value problem has a unique solution.

\sphinxAtStartPar
(b)  \(y'' = e^t + y\cos(t) - (t + 1) y', \qquad y(0) = 1, \qquad y(2) = \ln(3)\);
\subsubsection*{Solution}

\sphinxAtStartPar
\(p(t) = -(t + 1)\), \(q(t) = \cos(t)\) and \(r(t) = e^t\) are all continuous for \(t\in[0,2]\) but \(q(t) < 0\) for \(t \in (\pi/2, 2]\) so this boundary value problem does not have a unique solution.

\sphinxAtStartPar
(c)  \(y'' = (t^3 + 5)y + \sin(t), \qquad y(0) = 0,\qquad y(1) = 1\);
\subsubsection*{Solution}

\sphinxAtStartPar
\(p(t) = 0\), \(q(t) = t^3 + 5\) and \(r(t) = \sin(t)\) are all continuous and \(q(t) > 0\) for \(t\in[0,1]\) so this boundary value problem has a unique solution.

\sphinxAtStartPar
(d)  \(y'' = (5y + \sin(3t)) e^t, \qquad y(0) = 0,\qquad y(1) = 0\).
\subsubsection*{Solution}

\sphinxAtStartPar
\(p(t) = 0\), \(q(t) = 5e^t\) and \(r(t) = e^t\sin(3t)\) are all continuous and \(q(t) > 0\) for \(t\in[0,1]\) so this boundary value problem has a unique solution.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 5.2}

\sphinxAtStartPar
Consider the following boundary value problem
\begin{align*}
    y'' = 2t, \qquad y(0) = 1, \qquad y(2) = 3.
\end{align*}
\sphinxAtStartPar
Using a pen and calculator, calculate the Euler method solutions using a step length of \(h=0.4\) and guess values of \(y'(0) = 1\) and \(y'(0) = -1\)
\subsubsection*{Solution}

\sphinxAtStartPar
Rewriting the ODE as a system of two first\sphinxhyphen{}order ODEs
\begin{align*}
    y_1' &= y_2, \\
    y_2' &= 2t.
\end{align*}
\sphinxAtStartPar
Solving using the Euler method and \(y'(0)=1\)
\begin{align*}
    \mathbf{t} &= (0, 0.4, 0.8, 1.2, 1.6, 2.0), \\
    \mathbf{y}_0 &= \begin{pmatrix} 1 \\ 1 \end{pmatrix}, \\
    \mathbf{y}_1 &= \mathbf{y}_0 + h \mathbf{f}(t_0, \mathbf{y}_0) 
    = \begin{pmatrix} 1 \\ 1 \end{pmatrix} + 0.4 \begin{pmatrix} 1 \\ 2(0) \end{pmatrix} 
    = \begin{pmatrix} 1.4 \\ 1 \end{pmatrix}, \\
    \mathbf{y}_2 &= \mathbf{y}_1 + h \mathbf{f}(t_1, \mathbf{y}_1) 
    = \begin{pmatrix} 1.4 \\ 1 \end{pmatrix} + 0.4 \begin{pmatrix} 1 \\ 2(0.4) \end{pmatrix} 
    = \begin{pmatrix} 1.8 \\ 1.32 \end{pmatrix}, \\
    \mathbf{y}_3 &= \mathbf{y}_2 + h \mathbf{f}(t_2, \mathbf{y}_2) 
    = \begin{pmatrix} 1.8 \\ 1.32 \end{pmatrix} + 0.4 \begin{pmatrix} 1.32 \\ 2(0.8) \end{pmatrix} 
    = \begin{pmatrix} 2.328 \\ 1.96 \end{pmatrix}, \\
    \mathbf{y}_4 &= \mathbf{y}_3 + h \mathbf{f}(t_3, \mathbf{y}_3) 
    = \begin{pmatrix} 2.328 \\ 1.96 \end{pmatrix} + 0.4 \begin{pmatrix} 1.96 \\ 2(1.2) \end{pmatrix} 
    = \begin{pmatrix} 3.112 \\ 2.92 \end{pmatrix}, \\
    \mathbf{y}_5 &= \mathbf{y}_4 + h \mathbf{f}(t_4, \mathbf{y}_4) 
    = \begin{pmatrix} 3.112 \\ 2.92 \end{pmatrix} + 0.4 \begin{pmatrix} 2.92 \\ 2(1.6) \end{pmatrix} 
    = \begin{pmatrix} 4.28 \\ 4.2 \end{pmatrix}, \\
\end{align*}
\sphinxAtStartPar
Solving using \(y'(0)=-1\)
\begin{align*}
    \mathbf{y}_0 &= \begin{pmatrix} 1 \\ -1 \end{pmatrix}, \\
    \mathbf{y}_1 &= \mathbf{y}_0 + h \mathbf{f}(t_0, \mathbf{y}_0) 
    = \begin{pmatrix} 1 \\ -1 \end{pmatrix} + 0.4 \begin{pmatrix} -1 \\ 2(0) \end{pmatrix} 
    = \begin{pmatrix} 0.6 \\ -1 \end{pmatrix}, \\
    \mathbf{y}_2 &= \mathbf{y}_1 + h \mathbf{f}(t_1, \mathbf{y}_1) 
    = \begin{pmatrix} 0.6 \\ -1 \end{pmatrix} + 0.4 \begin{pmatrix} -1 \\ 2(0.4) \end{pmatrix} 
    = \begin{pmatrix} 0.2 \\ -0.68 \end{pmatrix}, \\
    \mathbf{y}_3 &= \mathbf{y}_2 + h \mathbf{f}(t_2, \mathbf{y}_2) 
    = \begin{pmatrix} 0.2 \\ -0.68 \end{pmatrix} + 0.4 \begin{pmatrix} -0.68 \\ 2(0.8) \end{pmatrix} 
    = \begin{pmatrix} -0.072 \\ -0.04 \end{pmatrix}, \\
    \mathbf{y}_4 &= \mathbf{y}_3 + h \mathbf{f}(t_3, \mathbf{y}_3) 
    = \begin{pmatrix} -0.072 \\ -0.04 \end{pmatrix} + 0.4 \begin{pmatrix} -0.04 \\ 2(1.2) \end{pmatrix} 
    = \begin{pmatrix} -0.088 \\ 0.92 \end{pmatrix}, \\
    \mathbf{y}_5 &= \mathbf{y}_4 + h \mathbf{f}(t_4, \mathbf{y}_4) 
    = \begin{pmatrix} -0.088 \\ 0.92 \end{pmatrix} + 0.4 \begin{pmatrix} 0.92 \\ 2(1.6) \end{pmatrix} 
    = \begin{pmatrix} 0.28 \\ 2.2 \end{pmatrix}, \\
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 5.3}

\sphinxAtStartPar
Use the Secant method to calculate the next value of \(s\) for your solutions to the boundary value problem in {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-2}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 5.2}}}} and hence calculate the Euler method using this new guess value.
\subsubsection*{Solution}

\sphinxAtStartPar
Calculate the improved guess value
\begin{align*}
    s_2 &= s_1 + g(s_1) \frac{s_1 - s_0}{g(s_1) - g(s_0)} \\
    &= -1 + (3 - 4.28) \frac{-1 - 1}{(3 - 4.28) - (3 - 0.28)} \\
    &= 0.36
\end{align*}
\sphinxAtStartPar
Solving using the Euler method with \(y'(0) = 0.36\)
\begin{align*}
    \mathbf{y}_0 &= \begin{pmatrix} 1 \\ -1 \end{pmatrix}, \\
    \mathbf{y}_1 &= \mathbf{y}_0 + h \mathbf{f}(t_0, \mathbf{y}_0) 
    = \begin{pmatrix} 1 \\ 0.36 \end{pmatrix} + 0.4 \begin{pmatrix} 0.36 \\ 2(0) \end{pmatrix} 
    = \begin{pmatrix} 1.144 \\ 0.36 \end{pmatrix}, \\
    \mathbf{y}_2 &= \mathbf{y}_1 + h \mathbf{f}(t_1, \mathbf{y}_1) 
    = \begin{pmatrix} 1.144 \\ 0.36 \end{pmatrix} + 0.4 \begin{pmatrix} 0.36 \\ 2(0.4) \end{pmatrix} 
    = \begin{pmatrix} 1.288 \\ 0.68 \end{pmatrix}, \\
    \mathbf{y}_3 &= \mathbf{y}_2 + h \mathbf{f}(t_2, \mathbf{y}_2) 
    = \begin{pmatrix} 1.288 \\ 0.68 \end{pmatrix} + 0.4 \begin{pmatrix} 0.68 \\ 2(0.8) \end{pmatrix} 
    = \begin{pmatrix} 1.56 \\ 1.32 \end{pmatrix}, \\
    \mathbf{y}_4 &= \mathbf{y}_3 + h \mathbf{f}(t_3, \mathbf{y}_3) 
    = \begin{pmatrix} 1.56 \\ 1.32 \end{pmatrix} + 0.4 \begin{pmatrix} 1.32 \\ 2(1.2) \end{pmatrix} 
    = \begin{pmatrix} 2.088 \\ 2.28 \end{pmatrix}, \\
    \mathbf{y}_5 &= \mathbf{y}_4 + h \mathbf{f}(t_4, \mathbf{y}_4) 
    = \begin{pmatrix} 2.088 \\ 2.28 \end{pmatrix} + 0.4 \begin{pmatrix} 2.28 \\ 2(1.6) \end{pmatrix} 
    = \begin{pmatrix} 3 \\ 3.56 \end{pmatrix}, \\
\end{align*}
\sphinxAtStartPar
The solutions to this boundary value problem using the Euler method with the shooting method are tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y_2\)
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
1.0000
&
\sphinxAtStartPar
0.3600
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
1.1440
&
\sphinxAtStartPar
0.3600
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
1.2880
&
\sphinxAtStartPar
0.6800
\\
\hline
\sphinxAtStartPar
1.20
&
\sphinxAtStartPar
1.5600
&
\sphinxAtStartPar
1.3200
\\
\hline
\sphinxAtStartPar
1.60
&
\sphinxAtStartPar
2.0880
&
\sphinxAtStartPar
2.2800
\\
\hline
\sphinxAtStartPar
2.00
&
\sphinxAtStartPar
3.0000
&
\sphinxAtStartPar
3.5600
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 5.4}

\sphinxAtStartPar
Calculate the solution of the boundary value problem in {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-4}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 5.4}}}} using the finite\sphinxhyphen{}difference method with a step length \(h=0.4\).
\subsubsection*{Solution}
\begin{align*}
    y'' &= 2t, \\
    \frac{y_{i-1} - 2 y_i + y_{i+1}}{h^2} &= 2 t_i \\
    y_{i-1} - 2y_i + y_{i+1} &= 2 h^2 t_i
\end{align*}
\sphinxAtStartPar
which can be written as the matrix equation
\begin{align*}
    \begin{pmatrix} 
        1 & 0 \\
        1 & -2 & 1 \\
        & \ddots & \ddots & \ddots \\
        & & 1 & -2 & 1 \\
        & & & 0 & 1
    \end{pmatrix}
    \begin{pmatrix} y_0 \\ y_1 \\ \vdots \\ y_{n-1} \\ y_{n} \end{pmatrix} =
    \begin{pmatrix} 1 \\ 2 h^2 t_1 \\ \vdots \\ 2 h^2 t_{n-1} \\ 3 \end{pmatrix}
\end{align*}
\sphinxAtStartPar
Since \(h=0.4\) then \(\mathbf{t} = (0, 0.4, 0.8, 1.2, 1.6, 2)\) and
\begin{align*}
    \begin{pmatrix} 
        1 & 0 \\
        1 & -2 & 1 \\
        & 1 & -2 & 1 \\
        & & 1 & -2 & 1 \\
        & & & 1 & -2 & 1 \\
        & & & & 0 & 1
    \end{pmatrix}
    \begin{pmatrix} y_0 \\ y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \end{pmatrix} =
    \begin{pmatrix} 1 \\ 0.128 \\ 0.256 \\ 0.384 \\ 0.512 \\ 3 \end{pmatrix}
\end{align*}
\sphinxAtStartPar
Performing the forward sweep of the Thomas algorithm
\begin{align*}
    b_1 &= 1, \\ 
    b_2 &= b_2 - c_1 \left( \frac{a_2}{b_1} \right) = -2 - 0\left( \frac{1}{1} \right) = -2, \\
    b_3 &= b_3 - c_2 \left( \frac{a_3}{b_2} \right) = -2 - \left( \frac{1}{-2} \right) = -1.5, \\
    b_4 &= b_4 - c_3 \left( \frac{a_4}{b_3} \right) = -2 - \left( \frac{1}{-1.5} \right) = -1.333333, \\
    b_5 &= b_5 - c_4 \left( \frac{a_5}{b_4} \right) = -2 - \left( \frac{1}{-1.333333} \right) = -1.25, \\
    b_6 &= b_6 - c_5 \left( \frac{a_6}{b_5} \right) = 1 - \left( \frac{0}{-1.25} \right) = 1, \\
    d_1 &= 1, \\
    d_2 &= d_2 - d_1 \left( \frac{a_2}{b_1} \right) = 0.128 - 1 \left( \frac{1}{1} \right) = -0.872, \\
    d_3 &= d_3 - d_2 \left( \frac{a_3}{b_2} \right) = 0.256 - (-0.872) \left( \frac{1}{-2} \right) = -0.18, \\
    d_4 &= d_4 - d_3 \left( \frac{a_4}{b_3} \right) = 0.384 - (-0.18) \left( \frac{1}{-1.5} \right) = 0.264, \\
    d_5 &= d_5 - d_4 \left( \frac{a_5}{b_4} \right) = 0.512 - (0.264) \left( \frac{1}{-1.333333} \right) = 0.71, \\
    d_6 &= d_6 - d_5 \left( \frac{a_6}{b_5} \right) = 3 - (0.71) \left( \frac{0}{-1.25} \right) = 3, \\
\end{align*}
\sphinxAtStartPar
Performing the back substitution step
\begin{align*}
    y_6 &= \frac{d_6}{b_6} = \frac{3}{1} = 3, \\
    y_5 &= \frac{d_5 - c_5 y_6}{b_5} = \frac{0.71 - 3}{-1.25} = 1.832, \\
    y_4 &= \frac{d_4 - c_4 y_5}{b_4} = \frac{0.264 - 1.832}{-1.333333} = 1.176, \\
    y_3 &= \frac{d_3 - c_3 y_4}{b_3} = \frac{-0.18 - 1.176}{-1.5} = 0.904, \\
    y_2 &= \frac{d_2 - c_2 y_3}{b_2} = \frac{0.872 - 0.904}{-2} = 0.888, \\
    y_1 &= \frac{d_1 - c_1 y_2}{b_1} = \frac{1 - 0(0.205992)}{1} = 1, \\
\end{align*}
\sphinxAtStartPar
The solutions to this boundary value problem using the finite\sphinxhyphen{}difference method are tabulated below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(t\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(y\)
\\
\hline
\sphinxAtStartPar
0.00
&
\sphinxAtStartPar
0.0000
\\
\hline
\sphinxAtStartPar
0.40
&
\sphinxAtStartPar
0.8880
\\
\hline
\sphinxAtStartPar
0.80
&
\sphinxAtStartPar
0.9040
\\
\hline
\sphinxAtStartPar
1.20
&
\sphinxAtStartPar
0.1760
\\
\hline
\sphinxAtStartPar
1.60
&
\sphinxAtStartPar
1.8320
\\
\hline
\sphinxAtStartPar
2.00
&
\sphinxAtStartPar
3.0000
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 5.5}

\sphinxAtStartPar
The exact solution to the boundary value problem in {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-2}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 5.2}}}} is \(y = \frac{1}{3} t^3 - \frac{1}{3} t + 1\). Write a Python program to perform the numerical calculations for exercises {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-3}]{\sphinxcrossref{\DUrole{std,std-ref}{5.3}}}} and {\hyperref[\detokenize{5_BVPs/5.4_BVP_exercises:ex5-4}]{\sphinxcrossref{\DUrole{std,std-ref}{5.4}}}} and produce a plot of the numerical solutions and the exact solutions on the same set of axes. Comment on your plot.
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 


\PYG{k}{def} \PYG{n+nf}{shooting\PYGZus{}method}\PYG{p}{(}\PYG{n}{solver}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{bvals}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}4}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{s}\PYG{p}{,} \PYG{n}{so}\PYG{p}{,} \PYG{n}{go} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{solver}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{p}{[}\PYG{n}{bvals}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{bvals}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{s}\PYG{p}{,} \PYG{n}{so}\PYG{p}{,} \PYG{n}{go} \PYG{o}{=} \PYG{n}{s} \PYG{o}{\PYGZhy{}} \PYG{n}{g} \PYG{o}{*} \PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZhy{}} \PYG{n}{so}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{g} \PYG{o}{\PYGZhy{}} \PYG{n}{go}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{g}
        \PYG{k}{if} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{s} \PYG{o}{\PYGZhy{}} \PYG{n}{so}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}


\PYG{k}{def} \PYG{n+nf}{tridiagonal\PYGZus{}solver}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{/} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/} \PYG{n}{b}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{x}


\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{t}\PYG{p}{]}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{t} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{t} \PYG{o}{+} \PYG{l+m+mi}{1}

    
\PYG{c+c1}{\PYGZsh{} Define BVP parameters}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{bvals} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundary values}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.4}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Solve BVP using the shooting method}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}euler} \PYG{o}{=} \PYG{n}{shooting\PYGZus{}method}\PYG{p}{(}\PYG{n}{euler}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{bvals}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
    
\PYG{c+c1}{\PYGZsh{} Solve BVP using the finite\PYGZhy{}difference method}
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{b}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{d}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{bvals}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
    \PYG{n}{c}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{d}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{t}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        
\PYG{n}{y\PYGZus{}fdm} \PYG{o}{=} \PYG{n}{tridiagonal\PYGZus{}solver}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
    
 \PYG{c+c1}{\PYGZsh{} Calculate exact solution}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot solutions}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}euler}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Euler method}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y\PYGZus{}fdm}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ro\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Finite\PYGZhy{}difference method}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{myst\PYGZus{}nb} \PYG{k+kn}{import} \PYG{n}{glue}
\PYG{n}{glue}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ex5.5\PYGZus{}plot}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fig}\PYG{p}{,} \PYG{n}{display}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Plot
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5.4_BVP_exercises_5_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\sphinxAtStartPar
The finite\sphinxhyphen{}difference method gives significantly more accurate solutions than the Euler method. This is because the finite\sphinxhyphen{}difference used a second\sphinxhyphen{}order approximation whereas the Euler method is only first\sphinxhyphen{}order. We would expect a more accurate method such as the RK2 method to give similar solutions to the finite\sphinxhyphen{}difference method.
\end{sphinxadmonition}

\sphinxstepscope


\part{Solving Linear Systems of Equations}

\sphinxstepscope


\chapter{Direct Methods}
\label{\detokenize{6_Direct_methods/6.0_Direct_methods:direct-methods}}\label{\detokenize{6_Direct_methods/6.0_Direct_methods:direct-methods-chapter}}\label{\detokenize{6_Direct_methods/6.0_Direct_methods::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
apply {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}} to factorise a square matrix into a product of a lower triangular and upper triangular matrices.

\item {} 
\sphinxAtStartPar
apply {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:crouts-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Croutâ€™s method}}}} for solving a system of linear equations using LU decomposition;

\item {} 
\sphinxAtStartPar
solve a system of linear equations using {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:partial-pivoting-section}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition with partial pivoting}}}};

\item {} 
\sphinxAtStartPar
apply {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky decomposition}}}} to factorise a positive definite matrix into a product of a lower triangular matrix and its transpose;

\item {} 
\sphinxAtStartPar
solve a system of linear equations using the {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-crout-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky\sphinxhyphen{}Crout method}}}};

\item {} 
\sphinxAtStartPar
apply {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}]{\sphinxcrossref{\DUrole{std,std-ref}{QR decomposition}}}} to factorise an \(m\times n\) matrix into the product of an orthogonal matrix and an upper triangular matrix using the {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gramschmidt-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Gram\sphinxhyphen{}Schmidt process}}}} and {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Householder transformations}}}};

\item {} 
\sphinxAtStartPar
Solve a {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-crout-section}]{\sphinxcrossref{\DUrole{std,std-ref}{system of linear equations using QR decomposition}}}}.

\end{itemize}


\bigskip\hrule\bigskip



\section{Systems of linear equations}
\label{\detokenize{6_Direct_methods/6.0_Direct_methods:systems-of-linear-equations}}\label{\detokenize{6_Direct_methods/6.0_Direct_methods:systems-of-linear-equations-section}}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/System\_of\_linear\_equations}{Systems of linear equations} appear often in the topics of numerical analysis and numerical solutions to differential equations. Examples include the solution of the {\hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-ivps-using-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stage values of an implicit Runge\sphinxhyphen{}Kutta method}}}} and the solution to a boundary value problem using the {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference method}}}}. The methods that are applied to solve systems of linear equations fall into one of two categories: \sphinxstylestrong{direct methods} that use an algebraic approach and {\hyperref[\detokenize{7_Indirect_methods/7.0_Indirect_methods:indirect-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{indirect methods}}}}} that use an iterative approach. On this chapter we will look at some common direct methods.

\sphinxAtStartPar
A system of linear equations with \(m\) equations and \(n\) unknowns is expressed as
\begin{align*}
    a_{11} x_1 +a_{12} x_2 +\cdots +a_{1n} x_n &=b_1 ,\\
    a_{21} x_1 +a_{22} x_2 +\cdots +a_{2n} x_n &=b_2 ,\\
    &\vdots \\
    a_{m1} x_1 +a_{m2} x_2 +\cdots +a_{mn} x_n &=b_n ,
\end{align*}
\sphinxAtStartPar
where \(x_i\) are the unknown variables, \(a_{ij}\) are coefficients and \(b_i\) are constant terms. It is often more convenient to express a system of linear equations as a matrix equation
\begin{align*}
    A \mathbf{x} = \mathbf{b},
\end{align*}
\sphinxAtStartPar
where \(A\) is the \sphinxstylestrong{coefficient matrix}, \(\mathbf{x}\) is the \sphinxstylestrong{variable vector} and \(b\) is the \sphinxstylestrong{constant vector}
\begin{align*}
    A &= \begin{pmatrix}
        a_{11}  & a_{12}  & \cdots  & a_{1n} \\
        a_{21}  & a_{22}  & \cdots  & a_{2n} \\
        \vdots  & \vdots  & \ddots  & \vdots \\
        a_{m1}  & a_{m2}  & \cdots  & a_{mn} 
    \end{pmatrix},& 
    \mathbf{x} &= \begin{pmatrix} x_1 \\ x_2 \\ \vdots \\ x_m \end{pmatrix}, &
    \mathbf{b} &= \begin{pmatrix} b_1 \\ b_2 \\ \vdots \\ b_m \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The solution (if it exists) is the vector \(\mathbf{x}\) for which the equation \(A\mathbf{x} = \mathbf{b}\) is satisfied. The solution to a linear system may be one of the following
\begin{itemize}
\item {} 
\sphinxAtStartPar
The system has infinitely many solutions. This usually occurs when the number of unknown variables exceeds the number of equations in the system.

\item {} 
\sphinxAtStartPar
The system has a single unique solution.

\item {} 
\sphinxAtStartPar
The system has no solution. This usually occurs where one equation in the system contradicts another such that not value of the variables could satisfy both.

\end{itemize}

\sphinxstepscope


\section{LU decomposition}
\label{\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-decomposition}}\label{\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-section}}\label{\detokenize{6_Direct_methods/6.1_LU_decomposition::doc}}
\sphinxAtStartPar
\sphinxstylestrong{LU decomposition} (also known as \sphinxstylestrong{LU factorisation}) is a procedure for decomposing a square matrix \(A\) into the product of a lower triangular matrix \(L\) and an upper triangular matrix \(U\) such that
\begin{align*}
    A = LU.
\end{align*}
\sphinxAtStartPar
The advantage of writing a matrix as a product of \(L\) and \(U\) is that the solution to a triangular set of equations is easy to calculate using forward or back substitution. Consider the LU decomposition of a \(3\times 3\) matrix
\begin{align*}
    \begin{pmatrix}
        a_{11}  & a_{12}  & a_{13} \\
        a_{21}  & a_{22}  & a_{32} \\
        a_{31}  & a_{32}  & a_{33} 
    \end{pmatrix}=
    \begin{pmatrix}
        \ell_{11}  & 0 & 0\\
        \ell_{21}  & \ell_{22}  & 0\\
        \ell_{31}  & \ell_{32}  & \ell_{33} 
    \end{pmatrix}\begin{pmatrix}
        u_{11}  & u_{12}  & u_{13} \\
        0 & u_{22}  & u_{23} \\
        0 & 0 & u_{33} 
    \end{pmatrix},
\end{align*}
\sphinxAtStartPar
which gives a system of 9 equations (one for each element in \(A\)) in 12 unknowns which has an infinite number of solutions. If we use the condition \(\ell_{ii} = 1\) then%
\begin{footnote}[1]\sphinxAtStartFootnote
Here we use \(\ell\) instead of the lowercase character \(l\) to avoid confusion with the uppercase character \(I\) or the number 1.
%
\end{footnote}
\begin{align*}
    \begin{pmatrix}
        a_{11}  & a_{12}  & a_{13} \\
        a_{21}  & a_{22}  & a_{23} \\
        a_{31}  & a_{32}  & a_{33} 
    \end{pmatrix}=
    \begin{pmatrix}
        u_{11}  & u_{12}  & u_{13} \\
        \ell_{21} u_{11}  & \ell_{21} u_{12} + \ell_{22} u_{22}  & \ell_{21} u_{13} + \ell_{22} u_{23} \\
        \ell_{31} u_{11}  & \ell_{31} u_{12} + \ell_{32} u_{22}  & \ell_{31} u_{13} +\ell_{32} u_{23} +\ell_{33} u_{33} 
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The elements in the lower triangular region, where \(i>j\), are
\begin{align*}
    \ell_{ij} =\sum_{k=1}^j \ell_{ik} u_{kj} =\ell_{ij} u_{jj} +\sum_{k=1}^{j-1} \ell_{ik} u_{kj}, 
\end{align*}
\sphinxAtStartPar
which is rearranged to
\begin{align*}
    \ell_{ij} =\frac{1}{u_{jj} }\left(a_{ij} -\sum_{k=1}^{j-1} \ell_{ik} u_{kj} \right).
\end{align*}
\sphinxAtStartPar
For the elements in the upper triangular region where \(i\le j\) we have
\begin{align*}
    u_{ij} =u_{ij} +\sum_{k=1}^{i-1} \ell_{ik} u_{kj},
\end{align*}
\sphinxAtStartPar
which is rearranged to
\begin{align*}
    u_{ij} = a_{ij} -\sum_{k=1}^{i-1} \ell_{ik} u_{kj}.
\end{align*}
\sphinxAtStartPar
So to calculate an LU decomposition we loop through each column of \(A\) and calculate the elements of \(\ell_{ij}\) and \(u_{ij}\) for that column.

\begin{sphinxadmonition}{note}{Definition: LU decomposition}

\sphinxAtStartPar
The LU decomposition of an \(n \times n\) square matrix \(A\) results in two \(n \times n\) matrices \(L\) and \(U\) such that \(A = LU\). The elements of \(L\) and \(U\) are calculated using
\begin{equation}\label{equation:6_Direct_methods/6.1_LU_decomposition:lu-equation}
\begin{split}\begin{align}
u_{ij} &= a_{ij} - \sum_{k=1}^{i-1} \ell_{ik}u_{kj}, & i &= 1, \ldots, j, \\
\ell_{ij} &= \dfrac{1}{u_{jj}} \left(a_{ij} - \displaystyle \sum_{k=1}^{j-1} \ell_{ik}u_{kj}\right), & i &= j+1, \ldots, n.
\end{align}\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 6.1}

\sphinxAtStartPar
Determine the LU decomposition of the following matrix
\begin{align*}
    A=\begin{pmatrix}
        1 & 3 & 0\\
        2 & -4 & -1\\
        -3 & 1 & 2
    \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Stepping through the columns of \(A\)
\begin{align*}
    j&=1: & u_{11} &=a_{11} =1,\\
    && \ell_{21} &=\frac{1}{u_{11} }(a_{21} )=\frac{1}{1}(2)=2,\\
    && \ell_{31} &=\frac{1}{u_{11} }(a_{31} )=\frac{1}{1}(-3)=-3,\\
    \\
    j&=2: & u_{12} &=a_{12} =3,\\
    && u_{22} &=a_{22} -\ell_{21} u_{12} =-4-2(3)=-10,\\
    && \ell_{32} &=\frac{1}{u_{22} }(a_{32} -\ell_{31} u_{12} ) = \frac{1}{-10}(1+3(3))=1,\\
    \\
    j&=3: & u_{13} &=a_{13} =0,\\
    && u_{23} &=a_{23} -\ell_{21} u_{13} =-1-2(0)=-1,\\
    && u_{33} &=a_{33} -\ell_{31} u_{13} -\ell_{32} u_{23} =2+-3(0)-1(-1)=3.
\end{align*}
\sphinxAtStartPar
Therefore
\begin{align*}
    L &= \begin{pmatrix}
        1 & 0 & 0\\
        2 & 1 & 0\\
        -3 & -1 & 1
    \end{pmatrix},&
    U &= \begin{pmatrix}
        1 & 3 & 0 \\
        0 & -10 & -1 \\
        0 & 0 & 1
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Checking that \(LU=A\)
\begin{align*}
    \begin{pmatrix}
        1 & 0 & 0\\
        2 & 1 & 0\\
        -3 & -1 & 1
    \end{pmatrix}
    \begin{pmatrix}
        1 & 3 & 0\\
        0 & -10 & -1\\
        0 & 0 & 1
    \end{pmatrix}=
    \begin{pmatrix}
        1 & 3 & 0\\
        2 & -4 & -1\\
        -3 & 1 & 2
    \end{pmatrix}.
\end{align*}\end{sphinxadmonition}


\subsection{Python Code}
\label{\detokenize{6_Direct_methods/6.1_LU_decomposition:python-code}}
\sphinxAtStartPar
The code below defines a function called \sphinxcode{\sphinxupquote{lu()}} which calculates the LU decomposition of a square matrix \sphinxcode{\sphinxupquote{A}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]} \PYG{o}{*} \PYG{n}{U}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
                
            \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}   
            
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]} \PYG{o}{*} \PYG{n}{U}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
                
            \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{U}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{L}\PYG{p}{,} \PYG{n}{U}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below applies the function \sphinxcode{\sphinxupquote{lu()}} to calculate the LU decomposition of the matrix from {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.1}}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define matrix}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate LU decomposition}
\PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{U}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
L = 
[[ 1.  0.  0.]
 [ 2.  1.  0.]
 [\PYGZhy{}3. \PYGZhy{}1.  1.]]

U = 
[[  1.   3.   0.]
 [  0. \PYGZhy{}10.  \PYGZhy{}1.]
 [  0.   0.   1.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Croutâ€™s method}
\label{\detokenize{6_Direct_methods/6.1_LU_decomposition:crout-s-method}}\label{\detokenize{6_Direct_methods/6.1_LU_decomposition:crouts-method-section}}
\sphinxAtStartPar
Given a system of linear equations of the form \(A \mathbf{x} = \mathbf{b}\) then the solution can be calculated using the LU decomposition of \(A\) using \sphinxstylestrong{Croutâ€™s method}. Since \(A = LU\) then
\begin{align*}
    U\mathbf{x} = \mathbf{b},
\end{align*}
\sphinxAtStartPar
let \(\mathbf{y} = U \mathbf{x}\) then
\begin{align*}
    \mathbf{y} = \mathbf{b}.
\end{align*}
\sphinxAtStartPar
\(L\) is a lower triangular matrix so the solution of \(L \mathbf{y} = \mathbf{b}\) is easily calculated using forward substitution. Once \(\mathbf{y}\) has been calculated the solution to \(U\mathbf{x} = \mathbf{y}\) is calculated using back substitution.

\sphinxAtStartPar
The advantage of using Croutâ€™s method is that once the LU decomposition of the coefficient matrix has been calculated the can be used for any values of the constant vector \(\mathbf{b}\). This is unlike Gaussian elimination where row reduction will need to be repeated for difference values of \(\mathbf{b}\).

\begin{sphinxadmonition}{note}{Example 6.2}

\sphinxAtStartPar
Use Croutâ€™s method to solve the following system of linear equations
\begin{align*}
    \begin{pmatrix}
        1 & 3 & 0 \\
        2 & -4 & -1 \\
        -3 & 1 & 2
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix}=
    \begin{pmatrix} -7 \\ 11 \\ 1 \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
We saw in the {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.1}}}} above that the LU decomposition of the coefficient matrix is
\begin{align*}
    L & =\begin{pmatrix}
        1 & 0 & 0 \\
        2 & 1 & 0 \\
        -3 & -1 & 1
    \end{pmatrix}, &
    U &= \begin{pmatrix}
        1 & 3 & 0 \\
        0 & -10 & -1 \\
        0 & 0 & 1
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Solving \(L \mathbf{y} = \mathbf{b}\) using forward substitution
\begin{align*}
    \begin{pmatrix}
        1 & 0 & 0 \\
        2 & 1 & 0 \\
        -3 & -1 & 1
    \end{pmatrix}
    \begin{pmatrix} y_1 \\ y_2 \\ y_3 \end{pmatrix} =
    \begin{pmatrix} -7\\ 11\\ 1
    \end{pmatrix},
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    y_1 &=-7,\\
    y_2 &=11-2y_1 =-2(-7)=25,\\
    y_3 &=-1+3y_1 +y_2 =-1+3(-7)+1(25)=5.
\end{align*}
\sphinxAtStartPar
Solving \(U \mathbf{x} = \mathbf{y}\) using back substitution
\begin{align*}
    \begin{pmatrix}
        1 & 3 & 0\\
        0 & -10 & -1\\
        0 & 0 & 1
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} =
    \begin{pmatrix} -7 \\ 25 \\ 5 \end{pmatrix},
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_3 &= 5,\\
    x_2 &= \frac{1}{-10}(25 + x_3) = -\frac{1}{10}(25 + 5) = -3,\\
    x_1 &= -7 - 0x_3 - 3x_2 = -7 + 9 = 2.
\end{align*}
\sphinxAtStartPar
So the solution is \(\mathbf{x}=(2,-3,5)\).
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.1_LU_decomposition:id2}}
\sphinxAtStartPar
The Python code below defines two functions called \sphinxcode{\sphinxupquote{forward\_substitution()}} and \sphinxcode{\sphinxupquote{back\_substitution()}} that perform forward and back substitution.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{forward\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{L}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
            
        \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{x}


\PYG{k}{def} \PYG{n+nf}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
            
        \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below uses the function \sphinxcode{\sphinxupquote{forward\_substitution()}} and \sphinxcode{\sphinxupquote{back\_substitution()}} to calculate the solution to the linear system from {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:crout-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.2}}}} using Croutâ€™s method with LU decomposition.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate LU decomposition}
\PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{U = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{U}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{forward\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
L = 
[[ 1.  0.  0.]
 [ 2.  1.  0.]
 [\PYGZhy{}3. \PYGZhy{}1.  1.]]

U = 
[[  1.   3.   0.]
 [  0. \PYGZhy{}10.  \PYGZhy{}1.]
 [  0.   0.   1.]]

x1 = 2.0
x2 = \PYGZhy{}3.0
x3 = 5.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxstepscope


\section{LUP decomposition}
\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-decomposition}}\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-section}}\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition::doc}}

\subsection{Partial pivoting}
\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:partial-pivoting}}\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:partial-pivoting-section}}
\sphinxAtStartPar
A problem that can be encountered with {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}} is that if the value of \(u_{jj}\) in the expression for {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{\(\ell_{ij}\)}}}} is zero or some small number it will mean that it is undefined or prone to computational rounding errors due to the value of \(\ell_{ij}\) being very large, this is known as an \sphinxhref{https://en.wikipedia.org/wiki/Condition\_number}{\sphinxstylestrong{ill\sphinxhyphen{}conditioned system}}.

\sphinxAtStartPar
This problem can be overcome by using \sphinxstylestrong{partial pivoting} where rows of the coefficient matrix are permuted (swapped) so that the pivot element \(a_{jj}\) has a larger absolute value than the elements in the column beneath it. Note that swapping two rows of the coefficient matrix does not change the solution to the system as long as the same swap is applied to the constant vector. The permutations applied to the coefficient matrix are recorded in a matrix \(P\) which is determined by applying the same permutations to the identity matrix.

\begin{sphinxadmonition}{note}{Example 6.3}

\sphinxAtStartPar
Apply partial pivoting the following matrix and determine the permutation matrix \(P\)
\begin{align*}
    A =\begin{pmatrix}
        0 & 1 & -2\\
        1 & 0 & 2\\
        3 & -2 & 2
    \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Using elementary row operations
\begin{align*}
    &\begin{pmatrix}
        0 & 1 & -2\\
        1 & 0 & 2\\
        3 & -2 & 2
    \end{pmatrix}
    \begin{array}{l} R_1 \leftrightarrow R_3 \\ \phantom{x} \\ \phantom{x} \end{array}
    \longrightarrow 
    \begin{pmatrix}
        3 & -2 & 2\\
        1 & 0 & 2\\
        0 & 1 & -2
    \end{pmatrix}
    \begin{array}{l} \phantom{x} \\ R_2 \leftrightarrow R_3 \\ \phantom{x} \end{array} \\ \\
    \longrightarrow
    &\begin{pmatrix}
        3 & -2 & 2\\
        0 & 1 & -2\\
        1 & 0 & 2
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Apply the same row operations to the identity matrix
\begin{align*}
    &\begin{pmatrix}
        1 & 0 & 0 \\
        0 & 1 & 0 \\
        0 & 0 & 1
    \end{pmatrix}
    \begin{array}{l} R_1 \leftrightarrow R_3 \\ \phantom{x} \\ \phantom{x} \end{array}
    \longrightarrow 
    \begin{pmatrix}
        0 & 0 & 1 \\
        0 & 1 & 0 \\
        1 & 0 & 0
    \end{pmatrix}
    \begin{array}{l} \phantom{x} \\ R_2 \leftrightarrow R_3 \\ \phantom{x} \end{array} \\ \\
    \longrightarrow
    &\begin{pmatrix}
        0 & 0 & 1 \\
        1 & 0 & 0 \\
        0 & 1 & 0
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
So
\(P=\begin{pmatrix}
    0 & 0 & 1\\
    1 & 0 & 0\\
    0 & 1 & 0
\end{pmatrix}\). Note that pre\sphinxhyphen{}multiplying \(A\) by \(P\) gives the matrix \(A\) after partial pivoting has been applied
\begin{align*}
    \begin{pmatrix}
        0 & 0 & 1\\
        1 & 0 & 0\\
        0 & 1 & 0
    \end{pmatrix}
    \begin{pmatrix}
        0 & 1 & -2\\
        1 & 0 & 2\\
        3 & -2 & 2
    \end{pmatrix} =
    \begin{pmatrix}
        3 & -2 & 2\\
        0 & 1 & -2\\
        1 & 0 & 2
    \end{pmatrix}.
\end{align*}\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:python-code}}
\sphinxAtStartPar
The code below defines a function called \sphinxcode{\sphinxupquote{partial\_pivot()}} which performs partial pivoting on the matrix \sphinxcode{\sphinxupquote{A}} and returns the pivoted matrix \sphinxcode{\sphinxupquote{A}} and the permutation matrix \sphinxcode{\sphinxupquote{P}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{partial\PYGZus{}pivot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{P} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{maxpivot}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{j}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{maxpivot}\PYG{p}{:}
                \PYG{n}{maxpivot}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i}
                
        \PYG{n}{A}\PYG{p}{[}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{]}
        \PYG{n}{P}\PYG{p}{[}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{P}\PYG{p}{[}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{]}
        
    \PYG{k}{return} \PYG{n}{A}\PYG{p}{,} \PYG{n}{P}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below applies the function \sphinxcode{\sphinxupquote{partial\_pivot()}} to calculate the permutation matrix for the matrix from {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:pivoting-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.3}}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Apply partial pivoting to the coefficent matrix}
\PYG{n}{A}\PYG{p}{,} \PYG{n}{P} \PYG{o}{=} \PYG{n}{partial\PYGZus{}pivot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{P = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{P}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A = 
[[ 3 \PYGZhy{}2  2]
 [ 0  1 \PYGZhy{}2]
 [ 1  0  2]]

P = 
[[0. 0. 1.]
 [1. 0. 0.]
 [0. 1. 0.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{LU decomposition with partial pivoting}
\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:lu-decomposition-with-partial-pivoting}}\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-decomposition-section}}
\sphinxAtStartPar
To calculate \sphinxstylestrong{LU decomposition with partial pivoting} (also known as \sphinxstylestrong{LUP decomposition}) we use the same process as in {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}} with the exception that the coefficient matrix has partial pivoting applied prior to the calculation of \(L\) and \(U\), i.e.,
\begin{align*}
    LU = PA.
\end{align*}
\sphinxAtStartPar
So to solve the system \(A \mathbf{x} = \mathbf{b}\) using LUP decomposition we have
\begin{align*}
    PA \mathbf{x} &= P \mathbf{b} \\ 
    \therefore LU \mathbf{x} &= P \mathbf{b}.
\end{align*}
\sphinxAtStartPar
So applying Croutâ€™s method to solve \(A \mathbf{x} = \mathbf{b}\) we solve the following for \(\mathbf{y}\) and \(\mathbf{x}\)
\begin{align*}
    L \mathbf{y} &= P \mathbf{b}, \\
    U \mathbf{x} &= \mathbf{y}.
\end{align*}
\begin{sphinxadmonition}{note}{Example 6.4}

\sphinxAtStartPar
Solve the following system of linear equations using Croutâ€™s method with LUP decomposition
\begin{align*}
    \begin{pmatrix}
        0 & 1 & -2\\
        1 & 0 & 2\\
        3 & -2 & 2
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} =
    \begin{pmatrix} 10 \\ -4 \\ -8 \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
We have seen from the {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:pivoting-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.3}}}} above that applying partial pivoting to the coefficient matrix results in
\begin{align*}
    PA &= \begin{pmatrix}
        3 & -2 & 2\\
        0 & 1 & -2\\
        1 & 0 & 2
    \end{pmatrix}, &
    P &= \begin{pmatrix}
        0 & 0 & 1\\
        1 & 0 & 0\\
        0 & 1 & 0
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Calculating the LU decomposition of \(PA\) using \eqref{equation:6_Direct_methods/6.1_LU_decomposition:lu-equation}
\begin{align*}
    j &= 1: & u_{11} &=a_{11} =3, \\
    & & \ell_{21} &= \frac{1}{u_{11} }a_{21} = \frac{1}{3}(0)=0, \\
    & & \ell_{31} &= \frac{1}{u_{11} }a_{31} = \frac{1}{3}(1)=\frac{1}{3}, \\
    \\
    j &= 2: & u_{12} &= a_{12} =-2, \\
    & & u_{22} &= a_{22} - \ell_{21} u_{12} = 1 - 0(-2) = 1, \\
    & & \ell_{32} &= \frac{1}{u_{22}}(a_{32} -\ell_{31} u_{12}) = \frac{1}{1} \left( 0 - \frac{1}{3}(-2) \right) = \frac{2}{3}, \\
    \\
    j &= 3: & u_{13} &= a_{13} = 2, \\
    & & u_{23} &= a_{23} -\ell_{21} u_{13} = -2 - 0(-2) = -2, \\
    & & u_{33} &= a_{33} -\ell_{31} u_{13} -\ell_{32} u_{23} = 2 - \frac{1}{3}(2)- \frac{2}{3}(-2) = \frac{8}{3}.
\end{align*}
\sphinxAtStartPar
Therefore
\begin{align*}
    L &= \begin{pmatrix}
        1 & 0 & 0\\
        0 & 1 & 0\\
        \frac{1}{3} & \frac{2}{3} & 1
    \end{pmatrix}, &
    U &= \begin{pmatrix}
        3 & -2 & 2\\
        0 & 1 & -2\\
        0 & 0 & \frac{8}{3}
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Solving \(L \mathbf{y} = P \mathbf{b}\) using forward substitution
\begin{align*}
    \begin{pmatrix}
        1 & 0 & 0\\
        0 & 1 & 0\\
        \frac{1}{3} & \frac{2}{3} & 1
    \end{pmatrix}
    \begin{pmatrix} y_1 \\ y_2 \\ y_3 \end{pmatrix} =
    \begin{pmatrix}
        0 & 0 & 1\\
        1 & 0 & 0\\
        0 & 1 & 0
    \end{pmatrix}
    \begin{pmatrix} 10 \\ -4 \\ -8 \end{pmatrix} =
    \begin{pmatrix} -8 \\ 10 \\ -4 \end{pmatrix},
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    y_1 &= -8, \\
    y_2 &= 10 - 0(8)=10, \\
    y_3 &= -4 - \frac{1}{3}(8) + \frac{2}{3}(10) = -8.
\end{align*}
\sphinxAtStartPar
Solving \(U \mathbf{x} = \mathbf{y}\) using back substitution
\begin{align*}
    \begin{pmatrix}
        3 & -2 & 2\\
        0 & 1 & -2\\
        0 & 0 & \frac{8}{3}
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} = 
    \begin{pmatrix} -8 \\ 10 \\ -8 \end{pmatrix},
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_3 &= \frac{3}{8}(-8) = -3, \\
    x_2 &= \frac{1}{1}(10+2(-3)) = 4, \\
    x_1 &= \frac{1}{3}(-8+2(4)-2(-3)) = 2.
\end{align*}
\sphinxAtStartPar
So the solution is \(\mathbf{x}=(2,4,-3)\).
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.2_LUP_decomposition:id1}}
\sphinxAtStartPar
The code below calculates the solution to the system of linear equations from {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.4}}}} using Croutâ€™s method with LUP decomposition. The \sphinxcode{\sphinxupquote{np.dot(A, B)}} command calculates the matrix multiplication \(AB\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Apply partial pivoting to the coefficent matrix}
\PYG{n}{A}\PYG{p}{,} \PYG{n}{P} \PYG{o}{=} \PYG{n}{partial\PYGZus{}pivot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{P = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{P}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate LU decomposition}
\PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{U = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{U}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{forward\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
P = 
[[0. 0. 1.]
 [1. 0. 0.]
 [0. 1. 0.]]

L = 
[[1.         0.         0.        ]
 [0.         1.         0.        ]
 [0.33333333 0.66666667 1.        ]]

U = 
[[ 3.         \PYGZhy{}2.          2.        ]
 [ 0.          1.         \PYGZhy{}2.        ]
 [ 0.          0.          2.66666667]]

x1 = 2.0
x2 = 4.0
x3 = \PYGZhy{}3.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Cholesky decomposition}
\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-decomposition}}\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-section}}\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Cholesky decomposition} is an efficient matrix decomposition method that can be used when a square matrix is \sphinxstylestrong{positive definite}.

\begin{sphinxadmonition}{note}{Definition: Positive definite matrix}

\sphinxAtStartPar
A square matrix \(A\) is said to be positive definite if
\begin{align*}
    \mathbf{x}^T A \mathbf{x} > 0 \text{ for all } \mathbf{x} \in \mathbb{R}^n \backslash \{\mathbf{0}\}.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Theorem: Determinant test for a positive definite matrix}

\sphinxAtStartPar
A square matrix \(A\) is positive definite if it is symmetric and the determinants of all \(k \times k\) upper\sphinxhyphen{}left sub\sphinxhyphen{}matrices are all positive.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 6.5}

\sphinxAtStartPar
Use the determinant test to show that the following matrix is positive definite
\begin{align*}
    A = \begin{pmatrix}
        2 & -1 & 0 \\
        -1 & 2 & -1 \\
        0 & -1 & 2
    \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Matrix \(A\) is symmetric since \(A=A^T\). Checking the determinants of the upper\sphinxhyphen{}left sub\sphinxhyphen{}matrices
\begin{align*}
    \det(2) &= 2 > 0, \\
    \det\begin{pmatrix} 2 & -1 \\ -1 & 2 \end{pmatrix} &= 4 - 1 = 3 > 0, \\
    \det\begin{pmatrix}
        2 & -1 & 0 \\
        -1 & 2 & -1 \\
        0 & -1 & 2
    \end{pmatrix}
    &= 6 - 2 + 0 = 4 > 0 .
\end{align*}
\sphinxAtStartPar
Since \(A\) is a symmetric matrix and all the determinants of the upper\sphinxhyphen{}left sub\sphinxhyphen{}matrices are positive then \(A\) is a positive definite matrix.
\end{sphinxadmonition}

\sphinxAtStartPar
Given a positive definite matrix \(A\) then Cholesky decomposition factorises \(A\) into the product of a lower triangular matrix \(L\) and its transpose, i.e.,
\begin{align*}
    A = LL^T.
\end{align*}
\sphinxAtStartPar
Consider the Cholesky decomposition of a \(3\times 3\) matrix
\begin{align*}
    \begin{pmatrix}
        a_{11}  & a_{12}  & a_{13} \\
        a_{21}  & a_{22}  & a_{23} \\
        a_{31}  & a_{32}  & a_{33} 
    \end{pmatrix} &= 
    \begin{pmatrix}
        \ell_{11}  & 0 & 0 \\
        \ell_{21}  & \ell_{22}  & 0 \\
        \ell_{31}  & \ell_{32}  & \ell_{33} 
    \end{pmatrix}
    \begin{pmatrix}
        \ell_{11}  & \ell_{21}  & \ell_{31} \\
        0 & \ell_{22}  & \ell_{32} \\
        0 & 0 & \ell_{33} 
    \end{pmatrix}\\
    &= 
    \begin{pmatrix}
        \ell_{11}^2  & \ell_{11} \ell_{21}  & \ell_{11} \ell_{31} \\
        \ell_{11} \ell_{21}  & \ell_{21}^2 +\ell_{22}^2  & \ell_{21} \ell_{31} +\ell_{22} \ell_{33} \\
        \ell_{11} \ell_{31}  & \ell_{21} \ell_{31} +\ell_{22} \ell_{33}  & \ell_{31}^2 +\ell_{32}^2 +\ell_{33}^2 
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The elements on the main diagonal are
\begin{align*}
    a_{jj} =\ell_{jj}^2 +\sum_{k=1}^{j-1} \ell_{jk}^2 ,
\end{align*}
\sphinxAtStartPar
and the other elements are
\begin{align*}
    a_{ij} =\sum_{k=1}^j \ell_{ik} \ell_{jk} = \ell_{jj} \ell_{ij} +\sum_{k=1}^{j-1} \ell_{ik} \ell_{jk}.
\end{align*}
\sphinxAtStartPar
Rearranging these expressions gives the following definition

\begin{sphinxadmonition}{note}{Definition: Cholesky decomposition}

\sphinxAtStartPar
The Cholesky decomposition of an \(n \times n\) positive\sphinxhyphen{}definite matrix \(A\) results in an \(n \times n\) matrix \(L\) such that \(A = LL^T\). The elements of \(L\) are calculated using
\begin{equation}\label{equation:6_Direct_methods/6.3_Cholesky_decomposition:cholesky-equation}
\begin{split}\begin{align}
    \ell_{jj} &= \sqrt{a_{jj} - \sum_{k=1}^{j-1} \ell_{jk}^2 }, & j &= 1, \ldots, n,\\
    \ell_{ij} &= \dfrac{1}{\ell_{jj} }\left(a_{ij} -\displaystyle \sum_{k=1}^{i-1} \ell_{ik} \ell_{jk} \right), & i &= j + 1,\ldots ,n.
\end{align}\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 6.6}

\sphinxAtStartPar
Calculate the Cholesky decomposition of the following matrix
\begin{align*}
    A = \begin{pmatrix}
        4 & -2 & -4\\
        -2 & 10 & 5\\
        -4 & 5 & 14
    \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Stepping through the columns of \(A\) and using equation \eqref{equation:6_Direct_methods/6.3_Cholesky_decomposition:cholesky-equation}
\begin{align*}
    j &= 1: & \ell_{11} &= \sqrt{a_{11}} = \sqrt{4} = 2,\\
    && \ell_{21} &= \frac{1}{\ell_{11}}(a_{21}) = \frac{1}{2}(-2) = -1,\\
    && \ell_{31} &= \frac{1}{\ell_{11}}(a_{31}) = \frac{1}{2}(-4) = -2,\\
    \\
    j &= 2: & \ell_{22} &= \sqrt{a_{22} - \ell_{21}^2} = \sqrt{10 - (-1)^2} = \sqrt{9} = 3,\\
    && \ell_{32} &= \frac{1}{\ell_{22}}(a_{32} - \ell_{31} \ell_{21}) = \frac{1}{3}(5 - (-2)(-1)) = 1,\\
    \\
    j &= 3: & \ell_{33} &= \sqrt{a_{33} - \ell_{31}^2 - \ell_{32}^2} = \sqrt{14 - (-2)^2 - 1^2} = \sqrt{9} = 3,
\end{align*}
\sphinxAtStartPar
therefore

\sphinxAtStartPar
\(L=\begin{pmatrix} 2 & 0 & 0 \\ -1 & 3 & 0 \\ -2 & 1 & 3 \end{pmatrix}\). Checking that \(A = LL^T\)
\begin{align*}
    \begin{pmatrix}
        2 & 0 & 0\\
        -1 & 3 & 0\\
        -2 & 1 & 3
    \end{pmatrix}
    \begin{pmatrix}
        2 & -1 & -2\\
        0 & 3 & 1\\
        0 & 0 & 3
    \end{pmatrix} =
    \begin{pmatrix}
        4 & -2 & -4\\
        -2 & 10 & 5\\
        -4 & 5 & 14
    \end{pmatrix}.
\end{align*}\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:python-code}}
\sphinxAtStartPar
The code below defines the function called \sphinxcode{\sphinxupquote{cholesky()}} which calculates the Cholesky decomposition of a square matrix \sphinxcode{\sphinxupquote{A}}. If \sphinxcode{\sphinxupquote{A}} is not positive\sphinxhyphen{}definite then it returns and error message.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cholesky}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error! A is not a positive definite matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return}
        
    \PYG{n}{L} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}   
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]} \PYG{o}{*} \PYG{n}{L}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]}
                
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{j}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{L}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}   
    
    \PYG{k}{return} \PYG{n}{L}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below calculates the Cholesky decomposition of the matrix from {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.6}}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define matrix}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate Cholesky decomposition}
\PYG{n}{L} \PYG{o}{=} \PYG{n}{cholesky}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
L = 
[[ 2.  0.  0.]
 [\PYGZhy{}1.  3.  0.]
 [\PYGZhy{}2.  1.  3.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{The Cholesky\sphinxhyphen{}Crout method}
\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:the-cholesky-crout-method}}\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-crout-method-section}}
\sphinxAtStartPar
The \sphinxstylestrong{Cholesky\sphinxhyphen{}Crout method} is used to solve a system of linear equations of the form \(A\mathbf{x}=\mathbf{b}\) where \(A\) is a positive definite matrix. Let \(\mathbf{y} = L^T \mathbf{x}\) then since \(A=LL^T\)
\begin{align*}
    L \mathbf{y} &= \mathbf{b}, \\
    L^T \mathbf{x} &= \mathbf{y}.
\end{align*}
\begin{sphinxadmonition}{note}{Example 6.7}

\sphinxAtStartPar
Solve the following system of linear equations using the Cholesky\sphinxhyphen{}Crout method.
\begin{align*}
    \begin{pmatrix}
        4 & -2 & -4\\
        -2 & 10 & 5\\
        -4 & 5 & 14
    \end{pmatrix}
    \begin{pmatrix}
        x_1 \\ x_2 \\ x_3 \end{pmatrix} =
    \begin{pmatrix} -2 \\ 49 \\ 27 \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
We saw in {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.6}}}} that the Cholesky decomposition of the matrix \(A\) is

\sphinxAtStartPar
\(L=\begin{pmatrix} 2 & 0 & 0 \\ -1 & 3 & 0 \\ -2 & 1 & 3 \end{pmatrix}\). Solving \(L\mathbf{y}=\mathbf{b}\) using forward substitution
\begin{align*}
    \begin{pmatrix}
        2 & 0 & 0\\
        -1 & 3 & 0\\
        -2 & 1 & 3
    \end{pmatrix}
    \begin{pmatrix} y_1 \\ y_2 \\ y_3 \end{pmatrix} =
    \begin{pmatrix} -2 \\ 49 \\ 27 \end{pmatrix},
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    y_1 &=\frac{-2}{2}=-1,\\
    y_2 &=\frac{1}{3}(49+y_1 )=\frac{1}{3}(49-1)=16,\\
    y_3 &=\frac{1}{3}(27+2y_1 -y_2 )=\frac{1}{3}(27+2(-1)-16)=3.
\end{align*}
\sphinxAtStartPar
Solving \(L^T \mathbf{x}=\mathbf{y}\) using back substitution
\begin{align*}
    \begin{pmatrix}
        2 & -1 & -2\\
        0 & 3 & 1\\
        0 & 0 & 3
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} =
    \begin{pmatrix} -1 \\ 16 \\ 3 \end{pmatrix},
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_3 &=\frac{3}{3}=1,\\
    x_2 &=\frac{1}{3}(16-x_3 )=\frac{1}{3}(16-1)=5,\\
    x_1 &=\frac{1}{2}(-1+x_2 +2x_3 )=\frac{1}{2}(-1+5+2(1))=3.
\end{align*}
\sphinxAtStartPar
So the solution is \(\mathbf{x}=(3,5,1)\).
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:id1}}
\sphinxAtStartPar
The code below solves the system of linear equations from {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-crout-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.7}}}} using the Cholesky\sphinxhyphen{}Crout method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate Cholesky decomposition}
\PYG{n}{L} \PYG{o}{=} \PYG{n}{cholesky}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{forward\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
L = 
[[ 2.  0.  0.]
 [\PYGZhy{}1.  3.  0.]
 [\PYGZhy{}2.  1.  3.]]

y = [\PYGZhy{}1. 16.  3.]
x = [3. 5. 1.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{QR decomposition}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-decomposition}}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition::doc}}
\sphinxAtStartPar
The methods of LU and Cholesky decomposition can be used to solve a system of linear equations where the number of equations is the same as the number of unknowns so it has a single unique solution. QR factorisation can be used to solve an \sphinxhref{https://en.wikipedia.org/wiki/Overdetermined\_system}{\sphinxstylestrong{overdetermined system}} where the number of equations is greater than the number of unknowns. Overdetermined systems rarely have a unique solution but we can calculate an approximation that most closely satisfies all equations in the system.

\sphinxAtStartPar
The \(m\times n\) matrix \(A\) is factorised into the product of two matrices such that
\begin{align*}
    A = QR,
\end{align*}
\sphinxAtStartPar
where \(Q\) is an orthogonal matrix and \(R\) is an upper triangular matrix.

\begin{sphinxadmonition}{note}{Definition: Orthogonal vectors}

\sphinxAtStartPar
A set of vectors \(\lbrace \mathbf{v}_1 ,\mathbf{v}_2 ,\mathbf{v}_3 ,\dots \rbrace\) is said to be \sphinxstylestrong{orthogonal} if \(\mathbf{v}_i \cdot \mathbf{v}_j =0\) for \(i\not= j\). Furthermore the set is said to be \sphinxstylestrong{orthonormal} if \(\mathbf{v}_i\) are all unit vectors.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Definition: Orthogonal matrix}

\sphinxAtStartPar
An \sphinxstylestrong{orthogonal matrix} is a matrix where the columns are a set of orthonormal vectors. If \(A\) is an orthogonal matrix if
\begin{align*}
    A^T A=I.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 6.8}

\sphinxAtStartPar
Show that the following matrix is an orthogonal matrix
\begin{align*}
    A= \begin{pmatrix}
        0.8 & -0.6\\
        0.6 & 0.8
    \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Checking \(A^T A=I\)
\begin{align*}
    A^T A=\begin{pmatrix}
        0.8 & 0.6\\
        -0.6 & 0.8
    \end{pmatrix}
    \begin{pmatrix}
        0.8 & -0.6\\
        0.6 & 0.8
    \end{pmatrix} = 
    \begin{pmatrix}
        1 & 0\\
        0 & 1
    \end{pmatrix}=I.
\end{align*}
\sphinxAtStartPar
So \(A\) is an orthogonal matrix.
\end{sphinxadmonition}


\subsection{QR decomposition using the Gram\sphinxhyphen{}Schmidt process}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-decomposition-using-the-gram-schmidt-process}}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gram-schmidt-section}}
\sphinxAtStartPar
The calculation of the orthogonal matrix \(Q\) can be achieved by using the \sphinxstylestrong{Gram\sphinxhyphen{}Schmidt process}. Given a ordered set of \(n\) linearly independent column vectors \((\mathbf{a}_1 ,\mathbf{a}_2 ,\dots ,\mathbf{a}_n)\) we wish to find a set that consists of \(n\) orthogonal vectors \((\mathbf{u}_1 ,\mathbf{u}_2 ,\dots ,\mathbf{u}_n)\) where the span of \((\mathbf{a}_1 ,\mathbf{a}_2 ,\dots ,\mathbf{a}_n)\) is that same as the span of \((\mathbf{u}_1 ,\mathbf{u}_2 ,\dots ,\mathbf{u}_n)\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gram_schmidt}.png}
\caption{The Gram\sphinxhyphen{}Schmidt process}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:gram-schmidt-figure}}\end{figure}

\sphinxAtStartPar
Consider the diagram in \hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:gram-schmidt-figure}]{Fig.\@ \ref{\detokenize{6_Direct_methods/6.4_QR_decomposition:gram-schmidt-figure}}} where we have vectors \(\mathbf{a}_1\) and \(\mathbf{a}_2\). Let \(\mathbf{u}_1 = \mathbf{a}_1\) then the vector that is orthogonal to \(\mathbf{u}_1\), \(\mathbf{u}_2\), can be found by subtracting the \sphinxhref{https://en.wikipedia.org/wiki/Vector\_projection}{\sphinxstylestrong{vector projection}} of \(\mathbf{a}_2\) onto \(\mathbf{u}_1\),
\begin{align*}
    \mathbf{u}_2 =\mathbf{a}_2 - \operatorname{proj}_{\mathbf{u}_1 } (\mathbf{a}_2).
\end{align*}
\sphinxAtStartPar
For the next vector \(\mathbf{u}_3\) we want this to be orthogonal to both \(\mathbf{u}_1\) and \(\mathbf{u}_2\). To find \(\mathbf{u}_3\) we subtract the projection of \(\mathbf{a}_3\) onto \(\mathbf{u}_1\) and \(\mathbf{u}_2\) from \(\mathbf{a}_3\). Doing similar for all vectors in \(A\) we have
\begin{align*}
    \mathbf{u}_1 &=\mathbf{a}_1 , & 
    \mathbf{q}_1 &=\frac{\mathbf{u}_1 }{\|\mathbf{u}_1 \|},\\
    \mathbf{u}_2 &=\mathbf{a}_2 -{\textrm{proj}}_{\mathbf{u}_1 } (\mathbf{a}_2 ), & 
    \mathbf{q}_2 &=\frac{\mathbf{u}_2 }{\|\mathbf{u}_2 \|},\\
    \mathbf{u}_3 &=\mathbf{a}_3 -{\textrm{proj}}_{\mathbf{u}_1 } (\mathbf{a}_3 )-{\textrm{proj}}_{\mathbf{u}_2 } (\mathbf{a}_3 ), & 
    \mathbf{q}_3 &=\frac{\mathbf{u}_3 }{\|\mathbf{u}_3 \|},\\
    \vdots  & & \vdots \\
    \mathbf{u}_n &=\mathbf{a}_n -\sum_{i=1}^{n-1} {\textrm{proj}}_{\mathbf{u}_i } (\mathbf{a}_n ), & 
    \mathbf{q}_n &=\frac{\mathbf{u}_n }{\|\mathbf{u}_n \|},
\end{align*}
\sphinxAtStartPar
where \(\mathbf{q}_i\) are orthonormal basis vectors. The vectors in \(A\) can be expressed using the orthornomal basis \(Q=(\mathbf{q}_1 ,\mathbf{q}_2 ,\dots ,\mathbf{q}_n)\)
\begin{align*}
    \mathbf{a}_1 &=(\mathbf{q}_1 \cdot \mathbf{a}_1 )\mathbf{q}_1, \\
    \mathbf{a}_2 &=(\mathbf{q}_1 \cdot \mathbf{a}_2 )\mathbf{q}_1 +(\mathbf{q}_2 \cdot \mathbf{a}_2 )\mathbf{q}_2 , \\
    \mathbf{a}_3 &=(\mathbf{q}_1 \cdot \mathbf{a}_3 )\mathbf{q}_1 +(\mathbf{q}_2 \cdot \mathbf{a}_3 )\mathbf{q}_2 +(\mathbf{q}_3 \cdot \mathbf{a}_3 )\mathbf{q}_3, \\
    &\vdots \\
    \mathbf{a}_n &=\sum_{i=1}^n (\mathbf{q}_i \cdot \mathbf{a}_n )\mathbf{q}_i .
\end{align*}
\sphinxAtStartPar
If \(A=QR\) then
\begin{align*}
    Q = \begin{pmatrix} \mathbf{q}_1  & \mathbf{q}_2  & \mathbf{q}_3  & \dots  & \mathbf{q}_5 \end{pmatrix}
    \begin{pmatrix}
        \mathbf{q}_1 \cdot \mathbf{a}_1  & \mathbf{q}_1 \cdot \mathbf{a}_2  & \mathbf{q}_1 \cdot \mathbf{a}_3  & \cdots  & \mathbf{q}_1 \cdot \mathbf{a}_n \\
        0 & \mathbf{q}_2 \cdot \mathbf{a}_2  & \mathbf{q}_2 \cdot \mathbf{a}_3  & \cdots  & \mathbf{q}_2 \cdot \mathbf{a}_n \\
        0 & 0 & \mathbf{q}_3 \cdot \mathbf{a}_3  & \cdots  & \mathbf{q}_3 \cdot \mathbf{a}_n \\
        \vdots  & \vdots  & \vdots  & \ddots  & \vdots \\
        0 & 0 & 0 & \cdots  & \mathbf{q}_n \cdot \mathbf{a}_n 
    \end{pmatrix}.
\end{align*}
\begin{sphinxadmonition}{note}{Definition: QR decomposition}

\sphinxAtStartPar
The QR decomposition of an \(m\times n\) matrix \(A\) results in an \(m\times n\) orthogonal matrix \(Q\) and an \(n\times n\) upper\sphinxhyphen{}triangular matrix \(R\) such that \(A =QR\). The elements of \(Q\) and \(R\) can be calculated using the Gram\sphinxhyphen{}Schmidt process which is:

\sphinxAtStartPar
For \(j = 1, \ldots, n\)
\begin{align*}
    r_{ij} &=\mathbf{q}_i \cdot \mathbf{a}_j , \qquad i = 1,\dots ,j-1,\\
    \mathbf{u}_j &= \mathbf{a}_j - \sum_{i=1}^{j-1} r_{ij} \mathbf{q}_i ,\\
    r_{jj} &= \| \mathbf{u}_j \|,\\
    \mathbf{q}_j &=\frac{\mathbf{u}_j }{r_{jj}}.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 6.9}

\sphinxAtStartPar
Calculate the QR decomposition of the following matrix using the Gram\sphinxhyphen{}Schmidt process
\begin{align*}
    A  = \begin{pmatrix}
        -1 & -1 & 1 \\
        1 & 3 & 3 \\
        -1 & -1 & 5 \\
        1 & 3 & 7
    \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Column \(j=1\):
\begin{align*}
    r_{11} &=\|\mathbf{a}_1 \|=2,\\
    \mathbf{q}_1 &=\frac{\mathbf{a}_1 }{r_{11}} = \frac{(-1, 1, -1, 1)^T}{2} = (-\tfrac{1}{2}, \tfrac{1}{2}, -\tfrac{1}{2}, \tfrac{1}{2})^T.
\end{align*}
\sphinxAtStartPar
Column \(j=2\):
\begin{align*}
    r_{12} &=\mathbf{q}_1 \cdot \mathbf{a}_2 =
    ( -\tfrac{1}{2}, \tfrac{1}{2}, -\tfrac{1}{2}, \tfrac{1}{2})^T \cdot 
    (-1, 3, -1, 3)^T = 4, \\
    \mathbf{u}_2 &=\mathbf{a}_2 -r_{12} \mathbf{q}_1 = (-1, 3, -1, 3)^T - 4
    (-\tfrac{1}{2}, \tfrac{1}{2}, -\tfrac{1}{2}, \tfrac{1}{2})^T = 
    (1, 1, 1, 1)^T,\\
    r_{22} &=\|\mathbf{u}_2 \| = 2,\\
    \mathbf{q}_2 &=\frac{\mathbf{u}_2 }{r_{22}} = \frac{(1, 1, 1, 1)^T}{2} = 
    (\tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2})^T.
\end{align*}
\sphinxAtStartPar
Column \(j=3\):
\begin{align*}
    r_{13} &=\mathbf{q}_1 \cdot \mathbf{a}_3 =
    (-\tfrac{1}{2}, \tfrac{1}{2}, -\tfrac{1}{2}, \tfrac{1}{2})^T \cdot 
    (1, 3, 5, 7)^T = 2,\\
    r_{23} &=\mathbf{q}_2 \cdot \mathbf{a}_3 =
    (\tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2})^T \cdot
    (1, 3, 5, 7)^T = 8,\\
    \mathbf{u}_3 &= \mathbf{a}_3 - r_{13} \mathbf{q}_1 - r_{23} \mathbf{q}_2 =
    (1, 3, 5, 7)^T - 2 (-\tfrac{1}{2}, \tfrac{1}{2}, -\tfrac{1}{2}, \tfrac{1}{2})^T - 8
    (\tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2})^T \\
    &= (-2, -2, 2, 2)^T,\\
    r_{33} &= \|\mathbf{u}_3 \| = 4,\\
    \mathbf{q}_3 &= \frac{\mathbf{u}_3 }{r_{33}} = \frac{(-2, -2, 2, 2)^T}{4} = 
    (-\tfrac{1}{2}, -\tfrac{1}{2}, \tfrac{1}{2}, \tfrac{1}{2})^T.
\end{align*}
\sphinxAtStartPar
Therefore the QR decomposition of \(A\) is
\begin{align*}
    Q &= \begin{pmatrix}
        -\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
        \frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
        -\frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\
        \frac{1}{2} & \frac{1}{2} & \frac{1}{2}
    \end{pmatrix}, &
    R &= \begin{pmatrix}
        2 & 4 & 2\\
        0 & 2 & 8\\
        0 & 0 & 4
    \end{pmatrix}.
\end{align*}\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:python-code}}
\sphinxAtStartPar
The code below defines a function called \sphinxcode{\sphinxupquote{qr\_gramschmidt()}} which calculates the QR decomposition of a matrix \sphinxcode{\sphinxupquote{A}} using the Gram\sphinxhyphen{}Schmidt process.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{qr\PYGZus{}gramschmidt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nrows}\PYG{p}{,} \PYG{n}{ncols} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ncols}\PYG{p}{,} \PYG{n}{ncols}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ncols}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{R}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{n}{R}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
        \PYG{n}{R}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{/} \PYG{n}{R}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
    
    \PYG{k}{return} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below calculates the QR decomposition of the matrix from {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gramschmidt-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.9}}}} using the \sphinxcode{\sphinxupquote{qr\sphinxhyphen{}gramschmidt()}} function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define matrix}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate QR decomposition}
\PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{qr\PYGZus{}gramschmidt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{Q}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{R = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{R}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Q = 
[[\PYGZhy{}0.5  0.5 \PYGZhy{}0.5]
 [ 0.5  0.5 \PYGZhy{}0.5]
 [\PYGZhy{}0.5  0.5  0.5]
 [ 0.5  0.5  0.5]]

R = 
[[2. 4. 2.]
 [0. 2. 8.]
 [0. 0. 4.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Solving systems of linear equations using QR decomposition}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:solving-systems-of-linear-equations-using-qr-decomposition}}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-crout-section}}
\sphinxAtStartPar
Given a system of linear equations of the form \(A\mathbf{x}=\mathbf{b}\) then the solution can be calculated using the QR decomposition of \(A\). Since \(A=QR\) then
\begin{align*}
    QR\mathbf{x} &= \mathbf{b}\\
    R\mathbf{x} &= Q^{-1} \mathbf{b},
\end{align*}
\sphinxAtStartPar
and because \(Q\) is orthogonal then \(Q^{-1}=Q^T\) so
\begin{align*}
    R\mathbf{x} = Q^T \mathbf{b}.
\end{align*}
\sphinxAtStartPar
\(R\) is upper triangular so the solution of \(\mathbf{x}\) can be obtained through back substitution.

\begin{sphinxadmonition}{note}{Example 6.10}

\sphinxAtStartPar
Solve the following system of linear equations using QR decomposition
\begin{align*}
    \begin{pmatrix}
        -1 & -1 & 1\\
        1 & 3 & 3\\
        -1 & -1 & 5\\
        1 & 3 & 7
    \end{pmatrix}.
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} =
    \begin{pmatrix} 1 \\ 19 \\ 13 \\ 31 \end{pmatrix}.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
We saw in {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gramschmidt-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.9}}}} that the QR decomposition of the coefficient matrix is
\begin{align*}
    Q &= \begin{pmatrix}
        -\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
        \frac{1}{2} & \frac{1}{2} & -\frac{1}{2}\\
        -\frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\
        \frac{1}{2} & \frac{1}{2} & \frac{1}{2}
    \end{pmatrix}, &
    R &= \begin{pmatrix}
        2 & 4 & 2\\
        0 & 2 & 8\\
        0 & 0 & 4
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Solving \(R\mathbf{x}=Q^T \mathbf{b}\)
\begin{align*}
    \begin{pmatrix}
        2 & 4 & 2\\
        0 & 2 & 8\\
        0 & 0 & 4
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} =
    \begin{pmatrix}
        -\frac{1}{2} & \frac{1}{2} & -\frac{1}{2} & \frac{1}{2}\\
        \frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\
        -\frac{1}{2} & -\frac{1}{2} & \frac{1}{2} & \frac{1}{2}
    \end{pmatrix}
    \begin{pmatrix} 1 \\ 19 \\ 13 \\ 31 \end{pmatrix} = 
    \begin{pmatrix} 18 \\ 32 \\ 12 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_3 &=\frac{12}{4}=3,\\
    x_2 &=\frac{1}{2}(32-8(3))=4,\\
    x_1 &=\frac{1}{2}(18-4(4)-2(3))=-2.
\end{align*}
\sphinxAtStartPar
So the solution is \(\mathbf{x}=(-2,4,3)\).
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:id1}}
\sphinxAtStartPar
The code below calculates the solution to the system of linear equations from {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-crout-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.10}}}} using QR decomposition.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate QR decomposition}
\PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{qr\PYGZus{}gramschmidt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x1 = \PYGZhy{}2.0
x2 = 4.0
x3 = 3.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{QR decomposition using Householder transformations}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-decomposition-using-householder-transformations}}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-section}}
\sphinxAtStartPar
Another method we can use to calculate the QR decomposition of a matrix is by the use of Householder transformations. Consider the diagram in \hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:householder-1-figure}]{Fig.\@ \ref{\detokenize{6_Direct_methods/6.4_QR_decomposition:householder-1-figure}}} where the vector \(\mathbf{x}\) is reflected about the hyperplane represented by the dashed line so that it is parallel to the basis vector\(\mathbf{e}_1\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{householder_1}.png}
\caption{Householder transformation: the vector \(\mathbf{x}\) is reflected about the dashed line so that it is parallel to the basis vector \(\mathbf{e}_1\).}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:householder-1-figure}}\end{figure}

\sphinxAtStartPar
The Householder matrix is an orthogonal matrix that performs the Householder transformation reflection

\begin{sphinxadmonition}{note}{Definition: Householder matrix}
\begin{equation}\label{equation:6_Direct_methods/6.4_QR_decomposition:householder-equation}
\begin{split}H = I - 2 \mathbf{v} \mathbf{v}^T,\end{split}
\end{equation}
\sphinxAtStartPar
where
\begin{align*}
    \mathbf{u} &= \mathbf{x} - \|\mathbf{x}\| \mathbf{e}_1, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|}.
\end{align*}\end{sphinxadmonition}

\sphinxAtStartPar
If \(\mathbf{x}\) is nearly parallel to \(\mathbf{e}_1\) then the denominator in equation \eqref{equation:6_Direct_methods/6.4_QR_decomposition:householder-equation} is close to zero and computational rounding errors can occur. However, we can choose to reflect \(\mathbf{x}\) so that it is parallel to \(-\mathbf{e}_1\) instead.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{householder_2}.png}
\caption{Householder transformation: the vector \(\mathbf{x}\) is reflected about the dashed line so that it is parallel to the basis vector \(-\mathbf{e}_1\) to avoid computational rounding errors.}\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:householder-2-figure}}\end{figure}

\sphinxAtStartPar
In \hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:householder-2-figure}]{Fig.\@ \ref{\detokenize{6_Direct_methods/6.4_QR_decomposition:householder-2-figure}}} above, \(\mathbf{x}\) is to be transformed to \(-\|\mathbf{x}\|\mathbf{e}_1\) then
\begin{align*}
    \mathbf{u} = \mathbf{x} + \|\mathbf{x}\| \mathbf{e}_1,
\end{align*}
\sphinxAtStartPar
so in order to always reflect in the direction that gives the largest value of \(\|\mathbf{u}\|\) we use
\begin{align*}
    \mathbf{u} = \mathbf{x} + \operatorname{sign}(x)\|\mathbf{x}\|\mathbf{e}_1 
\end{align*}
\sphinxAtStartPar
where
\begin{align*}
    \operatorname{sign}(x) = \begin{cases}
        1, & x \geq 0,\\
        -1, & x < 0.
    \end{cases}
\end{align*}
\sphinxAtStartPar
To calculate the QR decomposition of an \(m\times n\) matrix \(A\) we let \(Q=I_m\) and \(R=A=(\mathbf{r}_1, \mathbf{r}_2, \ldots, \mathbf{r}_n)\) and use Householder transformations to transform each of the column vectors in \(R\) so that they are parallel to the basis vector \(\mathbf{e}_i\). To do this we first calculate \(\mathbf{v}\) using
\begin{align*}
    \mathbf{u} &= \mathbf{r}_1 + \operatorname{sign}(r_{11})\| \mathbf{r}_1 \|\mathbf{e}_1 , \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|},
\end{align*}
\sphinxAtStartPar
and then we calculate the Householder matrix \(H\) using equation \eqref{equation:6_Direct_methods/6.4_QR_decomposition:householder-equation}
\begin{align*}
    H_1 &= I_m - 2 \mathbf{v} \mathbf{v}^T,
\end{align*}
\sphinxAtStartPar
and apply the Householder transformation to \(R\) and \(Q\)
\begin{align*}
    R &= H R =
    \begin{pmatrix}
        r_{11} & \star  & \cdots  & \star \\
        0 \\
        \vdots  & & R' \\
        0
    \end{pmatrix},\\
    Q &= QH.
\end{align*}
\sphinxAtStartPar
The first column of \(R\) is now parallel to \(\mathbf{e}_1\). We now need to transform the second column of \(R\) without changing the first row and column so that it is parallel to the second basis vector \(\mathbf{e}_2\). Therefore we calculate the Householder matrix by omitting the first row and column of \(R\) and then padding out the first row and column of \(H\) with the first row and column of the identity matrix, so for the \(j\)th column we have
\begin{align*}
    H &= \begin{pmatrix} 
        I_{j-1} & 0 \\
        0 & I_{m+j-1} - 2 \mathbf{v} \mathbf{v}^T
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
We repeat this process for the columns in \(R\) at which point \(R\) is an upper triangular matrix. The \(Q\) matrix is the product of all of the individual Householder transformations so by definition it is an orthonormal matrix.

\begin{sphinxadmonition}{note}{Definition: QR decomposution using Householder transformations}

\sphinxAtStartPar
The QR decomposition of an \(m\times n\) matrix \(A\) results in an \(m\times n\) orthogonal matrix \(Q\) and an \(m\times n\) upper\sphinxhyphen{}triangular matrix \(R\) such that \(A = QR\). . The elements of \(Q\) and \(R\) can be calculated using Householder transformations using:

\sphinxAtStartPar
For \(j = 1, \ldots, n\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\mathbf{e} = (1, \underbrace{0, \ldots, 0}_{m-j})^T\);

\item {} 
\sphinxAtStartPar
\(\mathbf{u} = (r_{jj}, r_{j+1,j}, \ldots, r_{m,j})^T\);

\item {} 
\sphinxAtStartPar
\(\mathbf{u} = \mathbf{u} + \operatorname{sign}(r_{jj})\|\mathbf{u}\|\mathbf{e}\);

\item {} 
\sphinxAtStartPar
\(\mathbf{v} = \dfrac{\mathbf{u}}{\| \mathbf{u} \|}\);

\item {} 
\sphinxAtStartPar
\(H = \begin{pmatrix}
      I_{j-1} & 0 \\
      0 & I_{m-j+1} - 2 \mathbf{v}\mathbf{v}^T
  \end{pmatrix}\);

\item {} 
\sphinxAtStartPar
\(R = H R\);

\item {} 
\sphinxAtStartPar
\(Q = Q H\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 6.11}

\sphinxAtStartPar
Calculate the QR decomposition of the following matrix using the Householder transformations
\begin{align*}
    A=\begin{pmatrix}
        -1 & -1 & 1\\
        1 & 3 & 3\\
        -1 & -1 & 5\\
        1 & 3 & 7
        \end{pmatrix}
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Let \(Q=I_4\) and \(R=A\) and calculate Householder matrix for the first column of \(R\)

\sphinxAtStartPar
Column \(j = 1\):
\begin{align*}
    \mathbf{u} &= \mathbf{r}_{1} + \operatorname{sign}(r_{11}) \| \mathbf{r}_{1} \| \mathbf{e} = \left(\begin{matrix}-1 & 1 & -1 & 1\end{matrix}\right)^T - 2 \left(\begin{matrix}1 & 0 & 0 & 0\end{matrix}\right)^T \\
    &= \left(\begin{matrix}-3 & 1 & -1 & 1\end{matrix}\right)^T, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|} = \frac{\left(\begin{matrix}-3 & 1 & -1 & 1\end{matrix}\right)^T}{2 \sqrt{3}}, \\
    H &= I_4 - 2\mathbf{vv}^T = I_4 - \frac{2}{12}\left(\begin{matrix}- \frac{\sqrt{3}}{2}\\\frac{\sqrt{3}}{6}\\- \frac{\sqrt{3}}{6}\\\frac{\sqrt{3}}{6}\end{matrix}\right)\left(\begin{matrix}- \frac{\sqrt{3}}{2} & \frac{\sqrt{3}}{6} & - \frac{\sqrt{3}}{6} & \frac{\sqrt{3}}{6}\end{matrix}\right) \\
      &= I_4 - \frac{1}{6}\left(\begin{matrix}\frac{3}{4} & - \frac{1}{4} & \frac{1}{4} & - \frac{1}{4}\\- \frac{1}{4} & \frac{1}{12} & - \frac{1}{12} & \frac{1}{12}\\\frac{1}{4} & - \frac{1}{12} & \frac{1}{12} & - \frac{1}{12}\\- \frac{1}{4} & \frac{1}{12} & - \frac{1}{12} & \frac{1}{12}\end{matrix}\right) = \left(\begin{matrix}- \frac{1}{2} & \frac{1}{2} & - \frac{1}{2} & \frac{1}{2}\\\frac{1}{2} & \frac{5}{6} & \frac{1}{6} & - \frac{1}{6}\\- \frac{1}{2} & \frac{1}{6} & \frac{5}{6} & \frac{1}{6}\\\frac{1}{2} & - \frac{1}{6} & \frac{1}{6} & \frac{5}{6}\end{matrix}\right),
\end{align*}
\sphinxAtStartPar
Updating \(R\) and \(Q\)
\begin{align*}
    R = H R &= \left(\begin{matrix}- \frac{1}{2} & \frac{1}{2} & - \frac{1}{2} & \frac{1}{2}\\\frac{1}{2} & \frac{5}{6} & \frac{1}{6} & - \frac{1}{6}\\- \frac{1}{2} & \frac{1}{6} & \frac{5}{6} & \frac{1}{6}\\\frac{1}{2} & - \frac{1}{6} & \frac{1}{6} & \frac{5}{6}\end{matrix}\right)\left(\begin{matrix}-1 & -1 & 1\\1 & 3 & 3\\-1 & -1 & 5\\1 & 3 & 7\end{matrix}\right) = \left(\begin{matrix}2 & 4 & 2\\0 & \frac{4}{3} & \frac{8}{3}\\0 & \frac{2}{3} & \frac{16}{3}\\0 & \frac{4}{3} & \frac{20}{3}\end{matrix}\right), \\
    Q = Q H &= \left(\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}\right)\left(\begin{matrix}- \frac{1}{2} & \frac{1}{2} & - \frac{1}{2} & \frac{1}{2}\\\frac{1}{2} & \frac{5}{6} & \frac{1}{6} & - \frac{1}{6}\\- \frac{1}{2} & \frac{1}{6} & \frac{5}{6} & \frac{1}{6}\\\frac{1}{2} & - \frac{1}{6} & \frac{1}{6} & \frac{5}{6}\end{matrix}\right) \\
    & = \left(\begin{matrix}- \frac{1}{2} & \frac{1}{2} & - \frac{1}{2} & \frac{1}{2}\\\frac{1}{2} & \frac{5}{6} & \frac{1}{6} & - \frac{1}{6}\\- \frac{1}{2} & \frac{1}{6} & \frac{5}{6} & \frac{1}{6}\\\frac{1}{2} & - \frac{1}{6} & \frac{1}{6} & \frac{5}{6}\end{matrix}\right).
\end{align*}
\sphinxAtStartPar
Column \(j = 2\):
\begin{align*}
    \mathbf{u} &= \mathbf{r}_{2} + \operatorname{sign}(r_{22}) \| \mathbf{r}_{2} \| \mathbf{e} = \left(\begin{matrix}\frac{4}{3} & \frac{2}{3} & \frac{4}{3}\end{matrix}\right)^T + 2 \left(\begin{matrix}1 & 0 & 0\end{matrix}\right)^T = \left(\begin{matrix}\frac{10}{3} & \frac{2}{3} & \frac{4}{3}\end{matrix}\right)^T, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|} = \frac{\left(\begin{matrix}\frac{10}{3} & \frac{2}{3} & \frac{4}{3}\end{matrix}\right)^T}{\frac{2 \sqrt{30}}{3}}, \\
    H &= I_3 - 2\mathbf{vv}^T = I_3 - \frac{2}{\frac{40}{3}}\left(\begin{matrix}\frac{\sqrt{30}}{6}\\\frac{\sqrt{30}}{30}\\\frac{\sqrt{30}}{15}\end{matrix}\right)\left(\begin{matrix}\frac{\sqrt{30}}{6} & \frac{\sqrt{30}}{30} & \frac{\sqrt{30}}{15}\end{matrix}\right) \\
      &= I_3 - \frac{3}{20}\left(\begin{matrix}\frac{5}{6} & \frac{1}{6} & \frac{1}{3}\\\frac{1}{6} & \frac{1}{30} & \frac{1}{15}\\\frac{1}{3} & \frac{1}{15} & \frac{2}{15}\end{matrix}\right) = \left(\begin{matrix}- \frac{2}{3} & - \frac{1}{3} & - \frac{2}{3}\\- \frac{1}{3} & \frac{14}{15} & - \frac{2}{15}\\- \frac{2}{3} & - \frac{2}{15} & \frac{11}{15}\end{matrix}\right),
\end{align*}
\sphinxAtStartPar
Adding the first 1 rows and columns of the identity matrix to \(H\)
\begin{align*}
    H &= \left(\begin{matrix}1 & 0 & 0 & 0\\0 & - \frac{2}{3} & - \frac{1}{3} & - \frac{2}{3}\\0 & - \frac{1}{3} & \frac{14}{15} & - \frac{2}{15}\\0 & - \frac{2}{3} & - \frac{2}{15} & \frac{11}{15}\end{matrix}\right).
\end{align*}
\sphinxAtStartPar
Updating \(R\) and \(Q\)
\begin{align*}
    R = H R & = \left(\begin{matrix}1 & 0 & 0 & 0\\0 & - \frac{2}{3} & - \frac{1}{3} & - \frac{2}{3}\\0 & - \frac{1}{3} & \frac{14}{15} & - \frac{2}{15}\\0 & - \frac{2}{3} & - \frac{2}{15} & \frac{11}{15}\end{matrix}\right)\left(\begin{matrix}2 & 4 & 2\\0 & \frac{4}{3} & \frac{8}{3}\\0 & \frac{2}{3} & \frac{16}{3}\\0 & \frac{4}{3} & \frac{20}{3}\end{matrix}\right) = \left(\begin{matrix}2 & 4 & 2\\0 & -2 & -8\\0 & 0 & \frac{16}{5}\\0 & 0 & \frac{12}{5}\end{matrix}\right), \\
    Q = Q H &= \left(\begin{matrix}- \frac{1}{2} & \frac{1}{2} & - \frac{1}{2} & \frac{1}{2}\\\frac{1}{2} & \frac{5}{6} & \frac{1}{6} & - \frac{1}{6}\\- \frac{1}{2} & \frac{1}{6} & \frac{5}{6} & \frac{1}{6}\\\frac{1}{2} & - \frac{1}{6} & \frac{1}{6} & \frac{5}{6}\end{matrix}\right)\left(\begin{matrix}1 & 0 & 0 & 0\\0 & - \frac{2}{3} & - \frac{1}{3} & - \frac{2}{3}\\0 & - \frac{1}{3} & \frac{14}{15} & - \frac{2}{15}\\0 & - \frac{2}{3} & - \frac{2}{15} & \frac{11}{15}\end{matrix}\right) \\
    &= \left(\begin{matrix}- \frac{1}{2} & - \frac{1}{2} & - \frac{7}{10} & \frac{1}{10}\\\frac{1}{2} & - \frac{1}{2} & - \frac{1}{10} & - \frac{7}{10}\\- \frac{1}{2} & - \frac{1}{2} & \frac{7}{10} & - \frac{1}{10}\\\frac{1}{2} & - \frac{1}{2} & \frac{1}{10} & \frac{7}{10}\end{matrix}\right).
\end{align*}
\sphinxAtStartPar
Column \(j = 3\):
\begin{align*}
    \mathbf{u} &= \mathbf{r}_{3} + \operatorname{sign}(r_{33}) \| \mathbf{r}_{3} \| \mathbf{e} = \left(\begin{matrix}\frac{16}{5} & \frac{12}{5}\end{matrix}\right)^T + 4 \left(\begin{matrix}1 & 0\end{matrix}\right)^T = \left(\begin{matrix}\frac{36}{5} & \frac{12}{5}\end{matrix}\right)^T, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|} = \frac{\left(\begin{matrix}\frac{36}{5} & \frac{12}{5}\end{matrix}\right)^T}{\frac{12 \sqrt{10}}{5}}, \\
    H &= I_2 - 2\mathbf{vv}^T = I_2 - \frac{2}{\frac{288}{5}}\left(\begin{matrix}\frac{3 \sqrt{10}}{10}\\\frac{\sqrt{10}}{10}\end{matrix}\right)\left(\begin{matrix}\frac{3 \sqrt{10}}{10} & \frac{\sqrt{10}}{10}\end{matrix}\right) \\
      &= I_2 - \frac{5}{144}\left(\begin{matrix}\frac{9}{10} & \frac{3}{10}\\\frac{3}{10} & \frac{1}{10}\end{matrix}\right) = \left(\begin{matrix}- \frac{4}{5} & - \frac{3}{5}\\- \frac{3}{5} & \frac{4}{5}\end{matrix}\right),
\end{align*}
\sphinxAtStartPar
Adding the first 2 rows and columns of the identity matrix to \(H\)
\begin{align*}
    H &= \left(\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & - \frac{4}{5} & - \frac{3}{5}\\0 & 0 & - \frac{3}{5} & \frac{4}{5}\end{matrix}\right).
\end{align*}
\sphinxAtStartPar
Updating \(R\) and \(Q\)
\begin{align*}
    R = H R &= \left(\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & - \frac{4}{5} & - \frac{3}{5}\\0 & 0 & - \frac{3}{5} & \frac{4}{5}\end{matrix}\right)\left(\begin{matrix}2 & 4 & 2\\0 & -2 & -8\\0 & 0 & \frac{16}{5}\\0 & 0 & \frac{12}{5}\end{matrix}\right) = \left(\begin{matrix}2 & 4 & 2\\0 & -2 & -8\\0 & 0 & -4\\0 & 0 & 0\end{matrix}\right), \\
    Q = Q H &= \left(\begin{matrix}- \frac{1}{2} & - \frac{1}{2} & - \frac{7}{10} & \frac{1}{10}\\\frac{1}{2} & - \frac{1}{2} & - \frac{1}{10} & - \frac{7}{10}\\- \frac{1}{2} & - \frac{1}{2} & \frac{7}{10} & - \frac{1}{10}\\\frac{1}{2} & - \frac{1}{2} & \frac{1}{10} & \frac{7}{10}\end{matrix}\right)\left(\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & - \frac{4}{5} & - \frac{3}{5}\\0 & 0 & - \frac{3}{5} & \frac{4}{5}\end{matrix}\right) \\
    &= \left(\begin{matrix}- \frac{1}{2} & - \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\\frac{1}{2} & - \frac{1}{2} & \frac{1}{2} & - \frac{1}{2}\\- \frac{1}{2} & - \frac{1}{2} & - \frac{1}{2} & - \frac{1}{2}\\\frac{1}{2} & - \frac{1}{2} & - \frac{1}{2} & \frac{1}{2}\end{matrix}\right).
\end{align*}\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:id2}}
\sphinxAtStartPar
The code below defines a function called \sphinxcode{\sphinxupquote{qr\_householder()}} that calculates the QR decomposition of an \(m\times n\) matrix \(A\) using Householder transformations.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{qr\PYGZus{}householder}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{e} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{R}\PYG{p}{[}\PYG{n}{j}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{u} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sign}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{e}
        \PYG{n}{v} \PYG{o}{=} \PYG{n}{u} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
        \PYG{n}{H} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
        \PYG{n}{H}\PYG{p}{[}\PYG{n}{j}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{v}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}
        \PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{R}\PYG{p}{)}
        \PYG{n}{Q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code below calculates the QR decomposition of the matrix from {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 6.11}}}} using the \sphinxcode{\sphinxupquote{qr\_householder()}} function. Note that the \sphinxcode{\sphinxupquote{R}} matrix that is returned can have very small values instead of zeros due to computational rounding errors. Any element with an absolute value of less than \(10^{-10}\) are set to zero for the sake of printing the output.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define A matrix}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate QR decomposition}
\PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{qr\PYGZus{}householder}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n}{R}\PYG{p}{[}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} set small values to zero}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{Q}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{R = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{R}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Q = 
[[\PYGZhy{}0.5 \PYGZhy{}0.5  0.5  0.5]
 [ 0.5 \PYGZhy{}0.5  0.5 \PYGZhy{}0.5]
 [\PYGZhy{}0.5 \PYGZhy{}0.5 \PYGZhy{}0.5 \PYGZhy{}0.5]
 [ 0.5 \PYGZhy{}0.5 \PYGZhy{}0.5  0.5]]

R = 
[[ 2.  4.  2.]
 [ 0. \PYGZhy{}2. \PYGZhy{}8.]
 [ 0.  0. \PYGZhy{}4.]
 [ 0.  0.  0.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Orthogonality errors}
\label{\detokenize{6_Direct_methods/6.4_QR_decomposition:orthogonality-errors}}
\sphinxAtStartPar
As with all numerical techniques, the two QR decomposition methods shown here are prone to computational rounding errors, especially since they both use square root calculations. The matrix \(Q\) is orthogonal so the dot product of each column of \(Q\) with all other columns should be equal to zero. We can use this to check the \sphinxstylestrong{loss of orthogonality} in our results.

\sphinxAtStartPar
Defining an orthogonality error \(E_j\) for a column vector \(\mathbf{q}_j\) from \(Q\) such that
\begin{align*}
    E_j =\max_{1 \leq i < j} |\mathbf{q}_j \cdot \mathbf{q}_i |, \qquad j = 1 \ldots n,
\end{align*}
\sphinxAtStartPar
then non\sphinxhyphen{}zero values of \(E_j\) indicates that we have lost some orthogonality due to computational rounding errors. The code below calculates orthogonality errors for the QR decomposition of a random \(100 \times 100\) matrix using the Gram\sphinxhyphen{}Schmidt process and Householder transformations and plots them.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k}{def} \PYG{n+nf}{orthogonality\PYGZus{}error}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{Q}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{E} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{E}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{E}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{E}


\PYG{c+c1}{\PYGZsh{} Generate 100 x 100 random matrix}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate QR decomposition}
\PYG{n}{Q\PYGZus{}gramschmidt}\PYG{p}{,} \PYG{n}{R\PYGZus{}gramschmidt} \PYG{o}{=} \PYG{n}{qr\PYGZus{}gramschmidt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{Q\PYGZus{}householder}\PYG{p}{,} \PYG{n}{R\PYGZus{}householder} \PYG{o}{=} \PYG{n}{qr\PYGZus{}householder}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate orthogonality errors}
\PYG{n}{E\PYGZus{}gramschmidt} \PYG{o}{=} \PYG{n}{orthogonality\PYGZus{}error}\PYG{p}{(}\PYG{n}{Q\PYGZus{}gramschmidt}\PYG{p}{)}
\PYG{n}{E\PYGZus{}householder} \PYG{o}{=} \PYG{n}{orthogonality\PYGZus{}error}\PYG{p}{(}\PYG{n}{Q\PYGZus{}householder}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot orthogonality errors}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{E\PYGZus{}gramschmidt}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gram\PYGZhy{}Schmdit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{E\PYGZus{}householder}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Householder}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{yscale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{log}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}j\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{log(E\PYGZus{}j)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{6.4_QR_decomposition_16_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can clearly see that as the column number increases the orthogonality errors for the Gram\sphinxhyphen{}Schmidt process increases whereas thr Householder remain relatively constant.

\sphinxstepscope


\section{Chapter summary}
\label{\detokenize{6_Direct_methods/6.5_Direct_methods_summary:chapter-summary}}\label{\detokenize{6_Direct_methods/6.5_Direct_methods_summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}} factorises a square matrix in the product of a lower triangular matrix \(L\) and an upper triangular matrix \(U\).

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:crouts-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Croutâ€™s method}}}} is used to solve a system of linear equations using LU decomposition by apply forward and back substitution.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:partial-pivoting-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Partial pivoting}}}} ensures that the pivot element has a larger absolute value than the elements in the column below the pivot. This eliminates the problems caused when the pivot element is small resulting in computational rounding errors;

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky decomposition}}}} can be applied to factorise a {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:positive-definite-example}]{\sphinxcrossref{\DUrole{std,std-ref}{positive definite matrix}}}} into the product of a lower triangular matrix \(L\) and its transpose. Cholesky decomposition of a matrix requires fewer operations than the equivalent LU decomposition.

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}]{\sphinxcrossref{\DUrole{std,std-ref}{QR decomposition}}}} can be applied to factorise an \(m\times n\) matrix into the product of an {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:orthogonal-matrix-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{orthogonal matrix}}}} \(Q\) and an upper triangular matrix \(R\).

\item {} 
\sphinxAtStartPar
QR decomposition can be calculated using the {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gramschmidt-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Gram\sphinxhyphen{}Schmidt process}}}} where an orthonormal basis is determined by recursively subtracting the vector projection of non\sphinxhyphen{}orthogonal vectors onto known basis vectors.

\item {} 
\sphinxAtStartPar
QR decomposition can also be calculated using {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Householder transformations}}}} which recursively applies a linear transformation to the columns of \(A\) to reflect them onto the basis vectors \(\mathbf{e}\).

\item {} 
\sphinxAtStartPar
QR decomposition can be used to calculate a solution to an overdetermined system when the number of equations is bigger than the number of unknowns.

\item {} 
\sphinxAtStartPar
The advantage of using decomposition methods for solving systems of linear equations is that a change in the constant values do not require a recalculation of the decomposition as opposed to Gaussian elimination.

\end{itemize}

\sphinxstepscope


\section{Direct methods exercises}
\label{\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:direct-methods-exercises}}\label{\detokenize{6_Direct_methods/6.6_Direct_methods_exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 6.1}

\sphinxAtStartPar
Using pen and paper, solve the following systems of linear equations using {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}}.

\sphinxAtStartPar
(a)
\begin{align*}
    2 x_1 + 3 x_2 -   x_3   &=  4,\\
    4 x_1 + 9 x_2 -   x_3   &= 18,\\
            3 x_2 + 2 x_3 &= 11.
\end{align*}\subsubsection*{Solution (click to show)}

\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 2 = 2, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{2}\left(4\right) = 2, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{2}\left(0\right) = 0, \\
    \\
    u_{12} &= a_{12} = 3 = 3, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = 9 - 2\left(3\right) = 3, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{3}\left(3 - \left(0\right)\left(3\right)\right) = 1, \\
    \\
    u_{13} &= a_{13} = -1 = -1, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = -1 - 2\left(-1\right) = 1, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = 2 - \left(0\right)\left(-1\right) - 1\left(1\right) = 1, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0\\2 & 1 & 0\\0 & 1 & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}2 & 3 & -1\\0 & 3 & 1\\0 & 0 & 1\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{{y}} = \mathbf{{b}}\)
\begin{align*}
    y_{1} &= 4, \\
    y_{2} &= 18 - 2\left(4\right) = 10, \\
    y_{3} &= 11 - \left(0\right)\left(4\right) - 1\left(10\right) = 1.
\end{align*}
\sphinxAtStartPar
Solve \(U \mathbf{{x}} = \mathbf{{y}}\)
\begin{align*}
    x_{3} &= 1, \\
    x_{2} &= \frac{1}{3}\left(10 - 1\left(1\right)\right) = 3, \\
    x_{1} &= \frac{1}{2}\left(4 - 3\left(3\right) - \left(-1\right)\left(1\right)\right) = -2.
\end{align*}
\sphinxAtStartPar
(b)
\begin{align*}
    3 x_1 + 9 x_2 + 5 x_3 &= 20,\\
      x_1 + 2 x_2 + 2 x_3 &=  3,\\
    2 x_1 + 4 x_2 + 5 x_3 &=  4.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 3 = 3, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{3}\left(1\right) = \frac{1}{3}, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{3}\left(2\right) = \frac{2}{3}, \\
    \\
    u_{12} &= a_{12} = 9 = 9, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = 2 - \frac{1}{3}\left(9\right) = -1, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{-1}\left(4 - \frac{2}{3}\left(9\right)\right) = 2, \\
    \\
    u_{13} &= a_{13} = 5 = 5, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = 2 - \frac{1}{3}\left(5\right) = \frac{1}{3}, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = 5 - \frac{2}{3}\left(5\right) - 2\left(\frac{1}{3}\right) = 1, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0\\\frac{1}{3} & 1 & 0\\\frac{2}{3} & 2 & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}3 & 9 & 5\\0 & -1 & \frac{1}{3}\\0 & 0 & 1\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{{y}} = \mathbf{{b}}\)
\begin{align*}
    y_{1} &= 20, \\
    y_{2} &= 3 - \frac{1}{3}\left(20\right) = - \frac{11}{3}, \\
    y_{3} &= 4 - \frac{2}{3}\left(20\right) - 2\left(- \frac{11}{3}\right) = -2.
\end{align*}
\sphinxAtStartPar
Solve \(U \mathbf{{x}} = \mathbf{{y}}\)
\begin{align*}
    x_{3} &= -2 = -2, \\
    x_{2} &= -\left(- \frac{11}{3} - \frac{1}{3}\left(-2\right)\right) = 3, \\
    x_{1} &= \frac{1}{3}\left(20 - 9\left(3\right) - 5\left(-2\right)\right) = 1.
\end{align*}
\sphinxAtStartPar
(c)
\begin{align*}
      x_1         + 3 x_3 + 2 x_4 &=  21,\\
    3 x_1 - 2 x_2 + 5 x_3 +   x_4 &=  28,\\
    4 x_1 -   x_2 - 2 x_3 - 3 x_4 &= -12,\\
            2 x_2         + 3 x_4 &=  13.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 1 = 1, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{1}\left(3\right) = 3, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{1}\left(4\right) = 4, \\
    \ell_{41} &= \frac{1}{u_{11}}\left(a_{41}\right) = \frac{1}{1}\left(0\right) = 0, \\
    \\
    u_{12} &= a_{12} = 0 = 0, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = -2 - 3\left(0\right) = -2, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{-2}\left(-1 - 4\left(0\right)\right) = \frac{1}{2}, \\
    \ell_{42} &= \frac{1}{u_{22}}\left(a_{42} - \ell_{41} u_{12}\right) = \frac{1}{-2}\left(2 - \left(0\right)\left(0\right)\right) = -1, \\
    \\
    u_{13} &= a_{13} = 3 = 3, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = 5 - 3\left(3\right) = -4, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = -2 - 4\left(3\right) - \frac{1}{2}\left(-4\right) = -12, \\
    \ell_{43} &= \frac{1}{u_{33}}\left(a_{43} - \ell_{41} u_{13} - \ell_{42} u_{23}\right) = \frac{1}{-12}\left(0 - \left(0\right)\left(3\right) - \left(-1\right)\left(-4\right)\right) = \frac{1}{3}, \\
    \\
    u_{14} &= a_{14} = 2 = 2, \\
    u_{24} &= a_{24} - \ell_{21} u_{14} = 1 - 3\left(2\right) = -5, \\
    u_{34} &= a_{34} - \ell_{31} u_{14} - \ell_{32} u_{24} = -3 - 4\left(2\right) - \frac{1}{2}\left(-5\right) = - \frac{17}{2}, \\
    u_{44} &= a_{44} - \ell_{41} u_{14} - \ell_{42} u_{24} - \ell_{43} u_{34} = 3 - \left(0\right)\left(2\right) - \left(-1\right)\left(-5\right) - \frac{1}{3}\left(- \frac{17}{2}\right) = \frac{5}{6}, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0 & 0\\3 & 1 & 0 & 0\\4 & \frac{1}{2} & 1 & 0\\0 & -1 & \frac{1}{3} & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}1 & 0 & 3 & 2\\0 & -2 & -4 & -5\\0 & 0 & -12 & - \frac{17}{2}\\0 & 0 & 0 & \frac{5}{6}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{{y}} = \mathbf{{b}}\)
\begin{align*}
    y_{1} &= 21, \\
    y_{2} &= 28 - 3\left(21\right) = -35, \\
    y_{3} &= -12 - 4\left(21\right) - \frac{1}{2}\left(-35\right) = - \frac{157}{2}, \\
    y_{4} &= 13 - \left(0\right)\left(21\right) - \left(-1\right)\left(-35\right) - \frac{1}{3}\left(- \frac{157}{2}\right) = \frac{25}{6}.
\end{align*}
\sphinxAtStartPar
Solve \(U \mathbf{{x}} = \mathbf{{y}}\)
\begin{align*}
    x_{4} &= \frac{1}{\frac{5}{6}}\left(\frac{25}{6}\right) = 5, \\
    x_{3} &= \frac{1}{-12}\left(- \frac{157}{2} - \left(- \frac{17}{2}\right)\left(5\right)\right) = 3, \\
    x_{2} &= \frac{1}{-2}\left(-35 - \left(-4\right)\left(3\right) - \left(-5\right)\left(5\right)\right) = -1, \\
    x_{1} &= 21 - \left(0\right)\left(-1\right) - 3\left(3\right) - 2\left(5\right) = 2.
\end{align*}
\sphinxAtStartPar
(d)
\begin{align*}
        x_1 + 5 x_2 + 2 x_3 + 2 x_4 &= -10,\\
    - 2 x_1 - 4 x_2 + 2 x_3         &=  10,\\
      3 x_1 +   x_2 - 2 x_3 -   x_4 &= -2,\\
    - 3 x_1 - 3 x_2 + 4 x_3 -   x_4 &=  4.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 1 = 1, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{1}\left(-2\right) = -2, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{1}\left(3\right) = 3, \\
    \ell_{41} &= \frac{1}{u_{11}}\left(a_{41}\right) = \frac{1}{1}\left(-3\right) = -3, \\
    \\
    u_{12} &= a_{12} = 5 = 5, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = -4 - \left(-2\right)\left(5\right) = 6, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{6}\left(1 - 3\left(5\right)\right) = - \frac{7}{3}, \\
    \ell_{42} &= \frac{1}{u_{22}}\left(a_{42} - \ell_{41} u_{12}\right) = \frac{1}{6}\left(-3 - \left(-3\right)\left(5\right)\right) = 2, \\
    \\
    u_{13} &= a_{13} = 2 = 2, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = 2 - \left(-2\right)\left(2\right) = 6, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = -2 - 3\left(2\right) - \left(- \frac{7}{3}\right)\left(6\right) = 6, \\
    \ell_{43} &= \frac{1}{u_{33}}\left(a_{43} - \ell_{41} u_{13} - \ell_{42} u_{23}\right) = \frac{1}{6}\left(4 - \left(-3\right)\left(2\right) - 2\left(6\right)\right) = - \frac{1}{3}, \\
    \\
    u_{14} &= a_{14} = 2 = 2, \\
    u_{24} &= a_{24} - \ell_{21} u_{14} = 0 - \left(-2\right)\left(2\right) = 4, \\
    u_{34} &= a_{34} - \ell_{31} u_{14} - \ell_{32} u_{24} = -1 - 3\left(2\right) - \left(- \frac{7}{3}\right)\left(4\right) = \frac{7}{3}, \\
    u_{44} &= a_{44} - \ell_{41} u_{14} - \ell_{42} u_{24} - \ell_{43} u_{34} = -1 - \left(-3\right)\left(2\right) - 2\left(4\right) - \left(- \frac{1}{3}\right)\left(\frac{7}{3}\right) = - \frac{20}{9}, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0 & 0\\-2 & 1 & 0 & 0\\3 & - \frac{7}{3} & 1 & 0\\-3 & 2 & - \frac{1}{3} & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}1 & 5 & 2 & 2\\0 & 6 & 6 & 4\\0 & 0 & 6 & \frac{7}{3}\\0 & 0 & 0 & - \frac{20}{9}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{{y}} = \mathbf{{b}}\)
\begin{align*}
    y_{1} &= -10, \\
    y_{2} &= 10 - \left(-2\right)\left(-10\right) = -10, \\
    y_{3} &= -2 - 3\left(-10\right) - \left(- \frac{7}{3}\right)\left(-10\right) = \frac{14}{3}, \\
    y_{4} &= 4 - \left(-3\right)\left(-10\right) - 2\left(-10\right) - \left(- \frac{1}{3}\right)\left(\frac{14}{3}\right) = - \frac{40}{9}.
\end{align*}
\sphinxAtStartPar
Solve \(U \mathbf{{x}} = \mathbf{{y}}\)
\begin{align*}
    x_{4} &= \frac{1}{- \frac{20}{9}}\left(- \frac{40}{9}\right) = 2, \\
    x_{3} &= \frac{1}{6}\left(\frac{14}{3} - \frac{7}{3}\left(2\right)\right) = 0, \\
    x_{2} &= \frac{1}{6}\left(-10 - 6\left(0\right) - 4\left(2\right)\right) = -3, \\
    x_{1} &= -10 - 5\left(-3\right) - 2\left(0\right) - 2\left(2\right) = 1.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 6.2}

\sphinxAtStartPar
Using pen and paper, solve the systems from {\hyperref[\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:ex6-1}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 6.1}}}} using {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-section}]{\sphinxcrossref{\DUrole{std,std-ref}{LUP decomposition}}}}.

\sphinxAtStartPar
(a)
\subsubsection*{Solution}

\sphinxAtStartPar
Perform partial pivoting on the \(A\) matrix
\begin{align*}
    & \left[\begin{matrix}1 & 5 & 2 & 2\\-2 & -4 & 2 & 0\\3 & 1 & -2 & -1\\-3 & -3 & 4 & -1\end{matrix}\right]
    \xrightarrow{R_{1} \leftrightarrow R_{3}}
    \left[\begin{matrix}3 & 1 & -2 & -1\\-2 & -4 & 2 & 0\\1 & 5 & 2 & 2\\-3 & -3 & 4 & -1\end{matrix}\right]
    \xrightarrow{R_{2} \leftrightarrow R_{3}}\\
    &
    \left[\begin{matrix}3 & 1 & -2 & -1\\1 & 5 & 2 & 2\\-2 & -4 & 2 & 0\\-3 & -3 & 4 & -1\end{matrix}\right]
    \xrightarrow{R_{3} \leftrightarrow R_{4}}
    \left[\begin{matrix}3 & 1 & -2 & -1\\1 & 5 & 2 & 2\\-3 & -3 & 4 & -1\\-2 & -4 & 2 & 0\end{matrix}\right]
    , \\
    & \left[\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{1} \leftrightarrow R_{3}}
    \left[\begin{matrix}0 & 0 & 1 & 0\\0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right]\\
    &
    \xrightarrow{R_{2} \leftrightarrow R_{3}}
    \left[\begin{matrix}0 & 0 & 1 & 0\\1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{3} \leftrightarrow R_{4}}
    \left[\begin{matrix}0 & 0 & 1 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\\0 & 1 & 0 & 0\end{matrix}\right]
.
\end{align*}
\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 4 = 4, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{4}\left(2\right) = \frac{1}{2}, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{4}\left(0\right) = 0, \\
    \\
    u_{12} &= a_{12} = 9 = 9, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = 3 - \frac{1}{2}\left(9\right) = - \frac{3}{2}, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{- \frac{3}{2}}\left(3 - \left(0\right)\left(9\right)\right) = -2, \\
    \\
    u_{13} &= a_{13} = -1 = -1, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = -1 - \frac{1}{2}\left(-1\right) = - \frac{1}{2}, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = 2 - \left(0\right)\left(-1\right) - \left(-2\right)\left(- \frac{1}{2}\right) = 1, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0\\\frac{1}{2} & 1 & 0\\0 & -2 & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}4 & 9 & -1\\0 & - \frac{3}{2} & - \frac{1}{2}\\0 & 0 & 1\end{matrix}\right], \qquad
    P = \left[\begin{matrix}0 & 1 & 0\\1 & 0 & 0\\0 & 0 & 1\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = P \mathbf{b}\)
\begin{align*} \left[\begin{matrix}1 & 0 & 0\\\frac{1}{2} & 1 & 0\\0 & -2 & 1\end{matrix}\right] \mathbf{y} = \left[\begin{matrix}0 & 1 & 0\\1 & 0 & 0\\0 & 0 & 1\end{matrix}\right] \left[\begin{matrix}4\\18\\11\end{matrix}\right] = \left[\begin{matrix}18\\4\\11\end{matrix}\right]. \end{align*}\begin{align*}
    y_{1} &= 18, \\
    y_{2} &= 4 - \frac{1}{2}\left(18\right) = -5, \\
    y_{3} &= 11 - \left(0\right)\left(18\right) - \left(-2\right)\left(-5\right) = 1.
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{3} &= 1 = 1, \\
    x_{2} &= \frac{1}{- \frac{3}{2}}\left(-5 - \left(- \frac{1}{2}\right)\left(1\right)\right) = 3, \\
    x_{1} &= \frac{1}{4}\left(18 - 9\left(3\right) - \left(-1\right)\left(1\right)\right) = -2.
\end{align*}
\sphinxAtStartPar
(b)
\subsubsection*{Solution}

\sphinxAtStartPar
Perform partial pivoting on the \(A\) matrix
\begin{align*}
    & \left[\begin{matrix}3 & 9 & 5\\1 & 2 & 2\\2 & 4 & 5\end{matrix}\right]
    \xrightarrow{R_{2} \leftrightarrow R_{3}}
    \left[\begin{matrix}3 & 9 & 5\\2 & 4 & 5\\1 & 2 & 2\end{matrix}\right]
    , \\
    & \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{2} \leftrightarrow R_{3}}
    \left[\begin{matrix}1 & 0 & 0\\0 & 0 & 1\\0 & 1 & 0\end{matrix}\right]
.
\end{align*}
\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 3 = 3, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{3}\left(2\right) = \frac{2}{3}, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{3}\left(1\right) = \frac{1}{3}, \\
    \\
    u_{12} &= a_{12} = 9 = 9, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = 4 - \frac{2}{3}\left(9\right) = -2, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{-2}\left(2 - \frac{1}{3}\left(9\right)\right) = \frac{1}{2}, \\
    \\
    u_{13} &= a_{13} = 5 = 5, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = 5 - \frac{2}{3}\left(5\right) = \frac{5}{3}, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = 2 - \frac{1}{3}\left(5\right) - \frac{1}{2}\left(\frac{5}{3}\right) = - \frac{1}{2}, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0\\\frac{2}{3} & 1 & 0\\\frac{1}{3} & \frac{1}{2} & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}3 & 9 & 5\\0 & -2 & \frac{5}{3}\\0 & 0 & - \frac{1}{2}\end{matrix}\right], \qquad
    P = \left[\begin{matrix}1 & 0 & 0\\0 & 0 & 1\\0 & 1 & 0\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = P \mathbf{b}\)
\begin{align*} \left[\begin{matrix}1 & 0 & 0\\\frac{2}{3} & 1 & 0\\\frac{1}{3} & \frac{1}{2} & 1\end{matrix}\right] \mathbf{y} = \left[\begin{matrix}1 & 0 & 0\\0 & 0 & 1\\0 & 1 & 0\end{matrix}\right] \left[\begin{matrix}20\\3\\4\end{matrix}\right] = \left[\begin{matrix}20\\4\\3\end{matrix}\right]. \end{align*}\begin{align*}
    y_{1} &= 20, \\
    y_{2} &= 4 - \frac{2}{3}\left(20\right) = - \frac{28}{3}, \\
    y_{3} &= 3 - \frac{1}{3}\left(20\right) - \frac{1}{2}\left(- \frac{28}{3}\right) = 1.
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{3} &= \frac{1}{- \frac{1}{2}}\left(1\right) = -2, \\
    x_{2} &= \frac{1}{-2}\left(- \frac{28}{3} - \frac{5}{3}\left(-2\right)\right) = 3, \\
    x_{1} &= \frac{1}{3}\left(20 - 9\left(3\right) - 5\left(-2\right)\right) = 1.
\end{align*}
\sphinxAtStartPar
(c)
\subsubsection*{Solution}

\sphinxAtStartPar
Perform partial pivoting on the \(A\) matrix
\begin{align*}
    & \left[\begin{matrix}1 & 0 & 3 & 2\\3 & -2 & 5 & 1\\4 & -1 & -2 & -3\\0 & 2 & 0 & 3\end{matrix}\right]
    \xrightarrow{R_{1} \leftrightarrow R_{3}}
    \left[\begin{matrix}4 & -1 & -2 & -3\\3 & -2 & 5 & 1\\1 & 0 & 3 & 2\\0 & 2 & 0 & 3\end{matrix}\right]
    , \\
    & \left[\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{1} \leftrightarrow R_{3}}
    \left[\begin{matrix}0 & 0 & 1 & 0\\0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
.
\end{align*}
\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 4 = 4, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{4}\left(3\right) = \frac{3}{4}, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{4}\left(1\right) = \frac{1}{4}, \\
    \ell_{41} &= \frac{1}{u_{11}}\left(a_{41}\right) = \frac{1}{4}\left(0\right) = 0, \\
    \\
    u_{12} &= a_{12} = -1 = -1, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = -2 - \frac{3}{4}\left(-1\right) = - \frac{5}{4}, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{- \frac{5}{4}}\left(0 - \frac{1}{4}\left(-1\right)\right) = - \frac{1}{5}, \\
    \ell_{42} &= \frac{1}{u_{22}}\left(a_{42} - \ell_{41} u_{12}\right) = \frac{1}{- \frac{5}{4}}\left(2 - \left(0\right)\left(-1\right)\right) = - \frac{8}{5}, \\
    \\
    u_{13} &= a_{13} = -2 = -2, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = 5 - \frac{3}{4}\left(-2\right) = \frac{13}{2}, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = 3 - \frac{1}{4}\left(-2\right) - \left(- \frac{1}{5}\right)\left(\frac{13}{2}\right) = \frac{24}{5}, \\
    \ell_{43} &= \frac{1}{u_{33}}\left(a_{43} - \ell_{41} u_{13} - \ell_{42} u_{23}\right) = \frac{1}{\frac{24}{5}}\left(0 - \left(0\right)\left(-2\right) - \left(- \frac{8}{5}\right)\left(\frac{13}{2}\right)\right) \\
    &= \frac{13}{6}, \\
    \\
    u_{14} &= a_{14} = -3 = -3, \\
    u_{24} &= a_{24} - \ell_{21} u_{14} = 1 - \frac{3}{4}\left(-3\right) = \frac{13}{4}, \\
    u_{34} &= a_{34} - \ell_{31} u_{14} - \ell_{32} u_{24} = 2 - \frac{1}{4}\left(-3\right) - \left(- \frac{1}{5}\right)\left(\frac{13}{4}\right) = \frac{17}{5}, \\
    u_{44} &= a_{44} - \ell_{41} u_{14} - \ell_{42} u_{24} - \ell_{43} u_{34} \\
    &= 3 - \left(0\right)\left(-3\right) - \left(- \frac{8}{5}\right)\left(\frac{13}{4}\right) - \frac{13}{6}\left(\frac{17}{5}\right) = \frac{5}{6}, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0 & 0\\\frac{3}{4} & 1 & 0 & 0\\\frac{1}{4} & - \frac{1}{5} & 1 & 0\\0 & - \frac{8}{5} & \frac{13}{6} & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}4 & -1 & -2 & -3\\0 & - \frac{5}{4} & \frac{13}{2} & \frac{13}{4}\\0 & 0 & \frac{24}{5} & \frac{17}{5}\\0 & 0 & 0 & \frac{5}{6}\end{matrix}\right], \\
    P &= \left[\begin{matrix}0 & 0 & 1 & 0\\0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = P \mathbf{b}\)
\begin{align*} \left[\begin{matrix}1 & 0 & 0 & 0\\\frac{3}{4} & 1 & 0 & 0\\\frac{1}{4} & - \frac{1}{5} & 1 & 0\\0 & - \frac{8}{5} & \frac{13}{6} & 1\end{matrix}\right] \mathbf{y} = \left[\begin{matrix}0 & 0 & 1 & 0\\0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right] \left[\begin{matrix}21\\28\\-12\\13\end{matrix}\right] = \left[\begin{matrix}-12\\28\\21\\13\end{matrix}\right]. \end{align*}\begin{align*}
    y_{1} &= -12, \\
    y_{2} &= 28 - \frac{3}{4}\left(-12\right) = 37, \\
    y_{3} &= 21 - \frac{1}{4}\left(-12\right) - \left(- \frac{1}{5}\right)\left(37\right) = \frac{157}{5}, \\
    y_{4} &= 13 - \left(0\right)\left(-12\right) - \left(- \frac{8}{5}\right)\left(37\right) - \frac{13}{6}\left(\frac{157}{5}\right) = \frac{25}{6}.
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{4} &= \frac{1}{\frac{5}{6}}\left(\frac{25}{6}\right) = 5, \\
    x_{3} &= \frac{1}{\frac{24}{5}}\left(\frac{157}{5} - \frac{17}{5}\left(5\right)\right) = 3, \\
    x_{2} &= \frac{1}{- \frac{5}{4}}\left(37 - \frac{13}{2}\left(3\right) - \frac{13}{4}\left(5\right)\right) = -1, \\
    x_{1} &= \frac{1}{4}\left(-12 - \left(-1\right)\left(-1\right) - \left(-2\right)\left(3\right) - \left(-3\right)\left(5\right)\right) = 2.
\end{align*}
\sphinxAtStartPar
(d)
\subsubsection*{Solution}

\sphinxAtStartPar
Perform partial pivoting on the \(A\) matrix
\begin{align*}
    & \left[\begin{matrix}1 & 5 & 2 & 2\\-2 & -4 & 2 & 0\\3 & 1 & -2 & -1\\-3 & -3 & 4 & -1\end{matrix}\right]
    \xrightarrow{R_{1} \leftrightarrow R_{3}}
    \left[\begin{matrix}3 & 1 & -2 & -1\\-2 & -4 & 2 & 0\\1 & 5 & 2 & 2\\-3 & -3 & 4 & -1\end{matrix}\right] 
    \xrightarrow{R_{2} \leftrightarrow R_{3}}\\
    &
    \left[\begin{matrix}3 & 1 & -2 & -1\\1 & 5 & 2 & 2\\-2 & -4 & 2 & 0\\-3 & -3 & 4 & -1\end{matrix}\right]
    \xrightarrow{R_{3} \leftrightarrow R_{4}}
    \left[\begin{matrix}3 & 1 & -2 & -1\\1 & 5 & 2 & 2\\-3 & -3 & 4 & -1\\-2 & -4 & 2 & 0\end{matrix}\right]
    , \\
    & \left[\begin{matrix}1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{1} \leftrightarrow R_{3}}
    \left[\begin{matrix}0 & 0 & 1 & 0\\0 & 1 & 0 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{2} \leftrightarrow R_{3}}\\
    &
    \left[\begin{matrix}0 & 0 & 1 & 0\\1 & 0 & 0 & 0\\0 & 1 & 0 & 0\\0 & 0 & 0 & 1\end{matrix}\right]
    \xrightarrow{R_{3} \leftrightarrow R_{4}}
    \left[\begin{matrix}0 & 0 & 1 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\\0 & 1 & 0 & 0\end{matrix}\right]
.
\end{align*}
\sphinxAtStartPar
Calculate LU decomposition of the \(A\) matrix
\begin{align*}
    u_{11} &= a_{11} = 3 = 3, \\
    \ell_{21} &= \frac{1}{u_{11}}\left(a_{21}\right) = \frac{1}{3}\left(1\right) = \frac{1}{3}, \\
    \ell_{31} &= \frac{1}{u_{11}}\left(a_{31}\right) = \frac{1}{3}\left(-3\right) = -1, \\
    \ell_{41} &= \frac{1}{u_{11}}\left(a_{41}\right) = \frac{1}{3}\left(-2\right) = - \frac{2}{3}, \\
    \\
    u_{12} &= a_{12} = 1 = 1, \\
    u_{22} &= a_{22} - \ell_{21} u_{12} = 5 - \frac{1}{3}\left(1\right) = \frac{14}{3}, \\
    \ell_{32} &= \frac{1}{u_{22}}\left(a_{32} - \ell_{31} u_{12}\right) = \frac{1}{\frac{14}{3}}\left(-3 - \left(-1\right)\left(1\right)\right) = - \frac{3}{7}, \\
    \ell_{42} &= \frac{1}{u_{22}}\left(a_{42} - \ell_{41} u_{12}\right) = \frac{1}{\frac{14}{3}}\left(-4 - \left(- \frac{2}{3}\right)\left(1\right)\right) = - \frac{5}{7}, \\
    \\
    u_{13} &= a_{13} = -2 = -2, \\
    u_{23} &= a_{23} - \ell_{21} u_{13} = 2 - \frac{1}{3}\left(-2\right) = \frac{8}{3}, \\
    u_{33} &= a_{33} - \ell_{31} u_{13} - \ell_{32} u_{23} = 4 - \left(-1\right)\left(-2\right) - \left(- \frac{3}{7}\right)\left(\frac{8}{3}\right) = \frac{22}{7}, \\
    \ell_{43} &= \frac{1}{u_{33}}\left(a_{43} - \ell_{41} u_{13} - \ell_{42} u_{23}\right) \\
    &= \frac{1}{\frac{22}{7}}\left(2 - \left(- \frac{2}{3}\right)\left(-2\right) - \left(- \frac{5}{7}\right)\left(\frac{8}{3}\right)\right) = \frac{9}{11}, \\
    \\
    u_{14} &= a_{14} = -1 = -1, \\
    u_{24} &= a_{24} - \ell_{21} u_{14} = 2 - \frac{1}{3}\left(-1\right) = \frac{7}{3}, \\
    u_{34} &= a_{34} - \ell_{31} u_{14} - \ell_{32} u_{24} = -1 - \left(-1\right)\left(-1\right) - \left(- \frac{3}{7}\right)\left(\frac{7}{3}\right) = -1, \\
    u_{44} &= a_{44} - \ell_{41} u_{14} - \ell_{42} u_{24} - \ell_{43} u_{34} \\
    &= 0 - \left(- \frac{2}{3}\right)\left(-1\right) - \left(- \frac{5}{7}\right)\left(\frac{7}{3}\right) - \frac{9}{11}\left(-1\right) = \frac{20}{11}, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0 & 0\\\frac{1}{3} & 1 & 0 & 0\\-1 & - \frac{3}{7} & 1 & 0\\- \frac{2}{3} & - \frac{5}{7} & \frac{9}{11} & 1\end{matrix}\right], \qquad
    U = \left[\begin{matrix}3 & 1 & -2 & -1\\0 & \frac{14}{3} & \frac{8}{3} & \frac{7}{3}\\0 & 0 & \frac{22}{7} & -1\\0 & 0 & 0 & \frac{20}{11}\end{matrix}\right], \\
    & P = \left[\begin{matrix}0 & 0 & 1 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\\0 & 1 & 0 & 0\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = P \mathbf{b}\)
\begin{align*} \left[\begin{matrix}1 & 0 & 0 & 0\\\frac{1}{3} & 1 & 0 & 0\\-1 & - \frac{3}{7} & 1 & 0\\- \frac{2}{3} & - \frac{5}{7} & \frac{9}{11} & 1\end{matrix}\right] \mathbf{y} = \left[\begin{matrix}0 & 0 & 1 & 0\\1 & 0 & 0 & 0\\0 & 0 & 0 & 1\\0 & 1 & 0 & 0\end{matrix}\right] \left[\begin{matrix}-10\\10\\-2\\4\end{matrix}\right] = \left[\begin{matrix}-2\\-10\\4\\10\end{matrix}\right]. \end{align*}\begin{align*}
    y_{1} &= -2, \\
    y_{2} &= -10 - \frac{1}{3}\left(-2\right) = - \frac{28}{3}, \\
    y_{3} &= 4 - \left(-1\right)\left(-2\right) - \left(- \frac{3}{7}\right)\left(- \frac{28}{3}\right) = -2, \\
    y_{4} &= 10 - \left(- \frac{2}{3}\right)\left(-2\right) - \left(- \frac{5}{7}\right)\left(- \frac{28}{3}\right) - \frac{9}{11}\left(-2\right) = \frac{40}{11}.
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{4} &= \frac{1}{\frac{20}{11}}\left(\frac{40}{11}\right) = 2, \\
    x_{3} &= \frac{1}{\frac{22}{7}}\left(-2 - \left(-1\right)\left(2\right)\right) = 0, \\
    x_{2} &= \frac{1}{\frac{14}{3}}\left(- \frac{28}{3} - \frac{8}{3}\left(0\right) - \frac{7}{3}\left(2\right)\right) = -3, \\
    x_{1} &= \frac{1}{3}\left(-2 - 1\left(-3\right) - \left(-2\right)\left(0\right) - \left(-1\right)\left(2\right)\right) = 1.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 6.3}

\sphinxAtStartPar
Using pen and paper, solve the following systems of linear equations using {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky decomposition}}}}.

\sphinxAtStartPar
(a)
\begin{align*}
    16x_1 +16x_2 +4x_3 &=-8,\\
    16x_1 +25x_2 +10x_3 &=-47,\\
    4x_1 +10x_2 +6x_3 &=-30.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate the Cholesky decomposition of the matrix \(A\)
\begin{align*}
    \ell_{11} &= \sqrt{ a_{11} } = \sqrt{ 16 } = 4, \\
    \ell_{21} &= \frac{1}{\ell_{11}} \left( a_{12} \right) = \frac{1}{4} \left( 16 \right) = 4, \\
    \ell_{31} &= \frac{1}{\ell_{11}} \left( a_{13} \right) = \frac{1}{4} \left( 4 \right) = 1, \\
    \\
    \ell_{22} &= \sqrt{ a_{22} - \ell_{21}^2 } = \sqrt{ 25 - 4^2 } = \sqrt{ 9 } = 3, \\
    \ell_{32} &= \frac{1}{\ell_{22}} \left( a_{23} - \ell_{31} \ell_{21} \right) = \frac{1}{3} \left( 10 - 1 \left( 4 \right) \right) = 2, \\
    \\
    \ell_{33} &= \sqrt{ a_{33} - \ell_{31}^2 - \ell_{32}^2 } = \sqrt{ 6 - 1^2 - 2^2 } = \sqrt{ 1 } = 1, \\
    \\
    \therefore L &= \left[\begin{matrix}4 & 0 & 0\\4 & 3 & 0\\1 & 2 & 1\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = \mathbf{b}\)
\begin{align*}
    y_{1} &= \frac{1}{4} \left( -8\right) = -2, \\
    y_{2} &= \frac{1}{3} \left( -47 - 4 \left( -2 \right)\right) = -13, \\
    y_{3} &= -30 - 1 \left( -2 \right) - 2 \left( -13 \right) = -2.
\end{align*}
\sphinxAtStartPar
Solve \(L^T \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{3} &= -2 = -2, \\
    x_{2} &= \frac{1}{3} \left(-13 - 2 \left( -2 \right) \right) = -3, \\
    x_{1} &= \frac{1}{4} \left(-2 - 4 \left( -3 \right) - 1 \left( -2 \right) \right) = 3.
\end{align*}
\sphinxAtStartPar
(b)
\begin{align*}
    4x_1 +2x_2 +8x_3 &=36,\\
    2x_1 +17x_2 +20x_3 &=50,\\
    8x_1 +20x_2 +41x_3 &=122.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate the Cholesky decomposition of the matrix \(A\)
\begin{align*}
    \ell_{11} &= \sqrt{ a_{11} } = \sqrt{ 4 } = 2, \\
    \ell_{21} &= \frac{1}{\ell_{11}} \left( a_{12} \right) = \frac{1}{2} \left( 2 \right) = 1, \\
    \ell_{31} &= \frac{1}{\ell_{11}} \left( a_{13} \right) = \frac{1}{2} \left( 8 \right) = 4, \\
    \\
    \ell_{22} &= \sqrt{ a_{22} - \ell_{21}^2 } = \sqrt{ 17 - 1^2 } = \sqrt{ 16 } = 4, \\
    \ell_{32} &= \frac{1}{\ell_{22}} \left( a_{23} - \ell_{31} \ell_{21} \right) = \frac{1}{4} \left( 20 - 4 \left( 1 \right) \right) = 4, \\
    \\
    \ell_{33} &= \sqrt{ a_{33} - \ell_{31}^2 - \ell_{32}^2 } = \sqrt{ 41 - 4^2 - 4^2 } = \sqrt{ 9 } = 3, \\
    \\
    \therefore L &= \left[\begin{matrix}2 & 0 & 0\\1 & 4 & 0\\4 & 4 & 3\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = \mathbf{b}\)
\begin{align*}
    y_{1} &= \frac{1}{2} \left( 36\right) = 18, \\
    y_{2} &= \frac{1}{4} \left( 50 - 1 \left( 18 \right)\right) = 8, \\
    y_{3} &= \frac{1}{3} \left( 122 - 4 \left( 18 \right) - 4 \left( 8 \right)\right) = 6.
\end{align*}
\sphinxAtStartPar
Solve \(L^T \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{3} &= \frac{1}{3} \left(6 \right) = 2, \\
    x_{2} &= \frac{1}{4} \left(8 - 4 \left( 2 \right) \right) = 0, \\
    x_{1} &= \frac{1}{2} \left(18 - 1 \left( 0 \right) - 4 \left( 2 \right) \right) = 5.
\end{align*}
\sphinxAtStartPar
(c)
\begin{align*}
    9x_1 -9x_2 -6x_4 &=12,\\
    -9x_1 +25x_2 +8x_3 -10x_4 &=-116,\\
    8x_2 +8x_3 -2x_4 &=-58,\\
    -6x_1 -10x_2 -2x_3 +33x_4 &=91.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate the Cholesky decomposition of the matrix \(A\)
\begin{align*}
    \ell_{11} &= \sqrt{ a_{11} } = \sqrt{ 9 } = 3, \\
    \ell_{21} &= \frac{1}{\ell_{11}} \left( a_{12} \right) = \frac{1}{3} \left( -9 \right) = -3, \\
    \ell_{31} &= \frac{1}{\ell_{11}} \left( a_{13} \right) = \frac{1}{3} \left( 0 \right) = 0, \\
    \ell_{41} &= \frac{1}{\ell_{11}} \left( a_{14} \right) = \frac{1}{3} \left( -6 \right) = -2, \\
    \\
    \ell_{22} &= \sqrt{ a_{22} - \ell_{21}^2 } = \sqrt{ 25 - -3^2 } = \sqrt{ 16 } = 4, \\
    \ell_{32} &= \frac{1}{\ell_{22}} \left( a_{23} - \ell_{31} \ell_{21} \right) = \frac{1}{4} \left( 8 - \left( 0 \right) \left( -3 \right) \right) = 2, \\
    \ell_{42} &= \frac{1}{\ell_{22}} \left( a_{24} - \ell_{41} \ell_{21} \right) = \frac{1}{4} \left( -10 - \left( -2 \right) \left( -3 \right) \right) = -4, \\
    \\
    \ell_{33} &= \sqrt{ a_{33} - \ell_{31}^2 - \ell_{32}^2 } = \sqrt{ 8 - 0^2 - 2^2 } = \sqrt{ 4 } = 2, \\
    \ell_{43} &= \frac{1}{\ell_{33}} \left( a_{34} - \ell_{41} \ell_{31} - \ell_{42} \ell_{32} \right) = \frac{1}{2} \left( -2 - \left( -2 \right) \left( 0 \right) - \left( -4 \right) \left( 2 \right) \right) = 3, \\
    \\
    \ell_{44} &= \sqrt{ a_{44} - \ell_{41}^2 - \ell_{42}^2 - \ell_{43}^2 } = \sqrt{ 33 - -2^2 - -4^2 - 3^2 } = \sqrt{ 4 } = 2, \\
    \\
    \therefore L &= \left[\begin{matrix}3 & 0 & 0 & 0\\-3 & 4 & 0 & 0\\0 & 2 & 2 & 0\\-2 & -4 & 3 & 2\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = \mathbf{b}\)
\begin{align*}
    y_{1} &= \frac{1}{3} \left( 12\right) = 4, \\
    y_{2} &= \frac{1}{4} \left( -116 - \left( -3 \right) \left( 4 \right)\right) = -26, \\
    y_{3} &= \frac{1}{2} \left( -58 - \left( 0 \right) \left( 4 \right) - 2 \left( -26 \right)\right) = -3, \\
    y_{4} &= \frac{1}{2} \left( 91 - \left( -2 \right) \left( 4 \right) - \left( -4 \right) \left( -26 \right) - 3 \left( -3 \right)\right) = 2.
\end{align*}
\sphinxAtStartPar
Solve \(L^T \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{4} &= \frac{1}{2} \left(2 \right) = 1, \\
    x_{3} &= \frac{1}{2} \left(-3 - 3 \left( 1 \right) \right) = -3, \\
    x_{2} &= \frac{1}{4} \left(-26 - 2 \left( -3 \right) - \left( -4 \right) \left( 1 \right) \right) = -4, \\
    x_{1} &= \frac{1}{3} \left(4 - \left( -3 \right) \left( -4 \right) - \left( 0 \right) \left( -3 \right) - \left( -2 \right) \left( 1 \right) \right) = -2.
\end{align*}
\sphinxAtStartPar
(d)
\begin{align*}
    x_1 +5x_2 -x_3 +2x_4 &=14,\\
    5x_1 +29x_2 +3x_3 +12x_4 &=82,\\
    -x_1 +3x_2 +42x_3 -13x_4 &=40,\\
    2x_1 +12x_2 -13x_3 +39x_4 &=-34.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
Calculate the Cholesky decomposition of the matrix \(A\)
\begin{align*}
    \ell_{11} &= \sqrt{ a_{11} } = \sqrt{ 1 } = 1, \\
    \ell_{21} &= \frac{1}{\ell_{11}} \left( a_{12} \right) = \frac{1}{1} \left( 5 \right) = 5, \\
    \ell_{31} &= \frac{1}{\ell_{11}} \left( a_{13} \right) = \frac{1}{1} \left( -1 \right) = -1, \\
    \ell_{41} &= \frac{1}{\ell_{11}} \left( a_{14} \right) = \frac{1}{1} \left( 2 \right) = 2, \\
    \\
    \ell_{22} &= \sqrt{ a_{22} - \ell_{21}^2 } = \sqrt{ 29 - 5^2 } = \sqrt{ 4 } = 2, \\
    \ell_{32} &= \frac{1}{\ell_{22}} \left( a_{23} - \ell_{31} \ell_{21} \right) = \frac{1}{2} \left( 3 - \left( -1 \right) \left( 5 \right) \right) = 4, \\
    \ell_{42} &= \frac{1}{\ell_{22}} \left( a_{24} - \ell_{41} \ell_{21} \right) = \frac{1}{2} \left( 12 - 2 \left( 5 \right) \right) = 1, \\
    \\
    \ell_{33} &= \sqrt{ a_{33} - \ell_{31}^2 - \ell_{32}^2 } = \sqrt{ 42 - -1^2 - 4^2 } = \sqrt{ 25 } = 5, \\
    \ell_{43} &= \frac{1}{\ell_{33}} \left( a_{34} - \ell_{41} \ell_{31} - \ell_{42} \ell_{32} \right) = \frac{1}{5} \left( -13 - 2 \left( -1 \right) - 1 \left( 4 \right) \right) = -3, \\
    \\
    \ell_{44} &= \sqrt{ a_{44} - \ell_{41}^2 - \ell_{42}^2 - \ell_{43}^2 } = \sqrt{ 39 - 2^2 - 1^2 - -3^2 } = \sqrt{ 25 } = 5, \\
    \\
    \therefore L &= \left[\begin{matrix}1 & 0 & 0 & 0\\5 & 2 & 0 & 0\\-1 & 4 & 5 & 0\\2 & 1 & -3 & 5\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(L \mathbf{y} = \mathbf{b}\)
\begin{align*}
    y_{1} &= 14 = 14, \\
    y_{2} &= \frac{1}{2} \left( 82 - 5 \left( 14 \right)\right) = 6, \\
    y_{3} &= \frac{1}{5} \left( 40 - \left( -1 \right) \left( 14 \right) - 4 \left( 6 \right)\right) = 6, \\
    y_{4} &= \frac{1}{5} \left( -34 - 2 \left( 14 \right) - 1 \left( 6 \right) - \left( -3 \right) \left( 6 \right)\right) = -10.
\end{align*}
\sphinxAtStartPar
Solve \(L^T \mathbf{x} = \mathbf{y}\)
\begin{align*}
    x_{4} &= \frac{1}{5} \left(-10 \right) = -2, \\
    x_{3} &= \frac{1}{5} \left(6 - \left( -3 \right) \left( -2 \right) \right) = 0, \\
    x_{2} &= \frac{1}{2} \left(6 - 4 \left( 0 \right) - 1 \left( -2 \right) \right) = 4, \\
    x_{1} &= 14 - 5 \left( 4 \right) - \left( -1 \right) \left( 0 \right) - 2 \left( -2 \right) = -2.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 6.4}

\sphinxAtStartPar
Using pen and paper, solve the following system of equations using QR decomposition with the {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gramschmidt-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Gram\sphinxhyphen{}Schmidt process}}}}

\sphinxAtStartPar
(a)
\begin{align*}
    x_1 +x_2 &=9,\\
    -x_1 &=-5.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
\(j = 1\):
\begin{align*}
    \mathbf{u}_{1} &= \mathbf{a}_{1} = \left[\begin{matrix}1 & -1\end{matrix}\right]^T, \\
    r_{11} &= \| \mathbf{u}_{1} \| = \sqrt{2}, \\
    \mathbf{q}_{1} &= \frac{\mathbf{u}_{1}}{r_{11}} = \frac{\left[\begin{matrix}1 & -1\end{matrix}\right]^T}{\sqrt{2}} = \left[\begin{matrix}\frac{\sqrt{2}}{2} & - \frac{\sqrt{2}}{2}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
\(j = 2\):
\begin{align*}
    r_{12} &= \mathbf{q}_{1} \cdot \mathbf{a}_{2} = \frac{\sqrt{2}}{2}, \\
    \mathbf{u}_{2} &= \mathbf{a}_{2} - r_{12} \mathbf{q}_{1} = \left[\begin{matrix}\frac{1}{2} & \frac{1}{2}\end{matrix}\right]^T, \\
    r_{22} &= \| \mathbf{u}_{2} \| = \frac{\sqrt{2}}{2}, \\
    \mathbf{q}_{2} &= \frac{\mathbf{u}_{2}}{r_{22}} = \frac{\left[\begin{matrix}\frac{1}{2} & \frac{1}{2}\end{matrix}\right]^T}{\frac{\sqrt{2}}{2}} = \left[\begin{matrix}\frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{2}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
therefore
\begin{align*}
    Q &= \left[\begin{matrix}\frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{2}\\- \frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{2}\end{matrix}\right], \qquad R = \left[\begin{matrix}\sqrt{2} & \frac{\sqrt{2}}{2}\\0 & \frac{\sqrt{2}}{2}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(R \mathbf{{x}} = Q^T \mathbf{{b}}\)
\begin{align*}
    \left[\begin{matrix}\sqrt{2} & \frac{\sqrt{2}}{2}\\0 & \frac{\sqrt{2}}{2}\end{matrix}\right] \mathbf{x} = \left[\begin{matrix}\frac{\sqrt{2}}{2} & - \frac{\sqrt{2}}{2}\\\frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{2}\end{matrix}\right]\left[\begin{matrix}9\\-5\end{matrix}\right] = \left[\begin{matrix}7 \sqrt{2}\\2 \sqrt{2}\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_{2} &= \frac{1}{\frac{\sqrt{2}}{2}} (2 \sqrt{2}) = 4, \\
    x_{1} &= \frac{1}{\sqrt{2}} (7 \sqrt{2} - \frac{\sqrt{2}}{2}(4)) = 5.
\end{align*}
\sphinxAtStartPar
(b)
\begin{align*}
    6x_1 +6x_2 +x_3 &=3,\\
    3x_1 +6x_2 +x_3 &=0,\\
    2x_1 +x_2 +x_3 &=4.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
\(j = 1\):
\begin{align*}
    \mathbf{u}_{1} &= \mathbf{a}_{1} = \left[\begin{matrix}6 & 3 & 2\end{matrix}\right]^T, \\
    r_{11} &= \| \mathbf{u}_{1} \| = 7, \\
    \mathbf{q}_{1} &= \frac{\mathbf{u}_{1}}{r_{11}} = \frac{\left[\begin{matrix}6 & 3 & 2\end{matrix}\right]^T}{7} = \left[\begin{matrix}\frac{6}{7} & \frac{3}{7} & \frac{2}{7}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
\(j = 2\):
\begin{align*}
    r_{12} &= \mathbf{q}_{1} \cdot \mathbf{a}_{2} = 8, \\
    \mathbf{u}_{2} &= \mathbf{a}_{2} - r_{12} \mathbf{q}_{1} = \left[\begin{matrix}- \frac{6}{7} & \frac{18}{7} & - \frac{9}{7}\end{matrix}\right]^T, \\
    r_{22} &= \| \mathbf{u}_{2} \| = 3, \\
    \mathbf{q}_{2} &= \frac{\mathbf{u}_{2}}{r_{22}} = \frac{\left[\begin{matrix}- \frac{6}{7} & \frac{18}{7} & - \frac{9}{7}\end{matrix}\right]^T}{3} = \left[\begin{matrix}- \frac{2}{7} & \frac{6}{7} & - \frac{3}{7}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
\(j = 3\):
\begin{align*}
    r_{13} &= \mathbf{q}_{1} \cdot \mathbf{a}_{3} = \frac{11}{7}, \\
    r_{23} &= \mathbf{q}_{2} \cdot \mathbf{a}_{3} = \frac{1}{7}, \\
    \mathbf{u}_{3} &= \mathbf{a}_{3} - r_{13} \mathbf{q}_{1} - r_{23} \mathbf{q}_{2} = \left[\begin{matrix}- \frac{15}{49} & \frac{10}{49} & \frac{30}{49}\end{matrix}\right]^T, \\
    r_{33} &= \| \mathbf{u}_{3} \| = \frac{5}{7}, \\
    \mathbf{q}_{3} &= \frac{\mathbf{u}_{3}}{r_{33}} = \frac{\left[\begin{matrix}- \frac{15}{49} & \frac{10}{49} & \frac{30}{49}\end{matrix}\right]^T}{\frac{5}{7}} = \left[\begin{matrix}- \frac{3}{7} & \frac{2}{7} & \frac{6}{7}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
therefore
\begin{align*}
    Q &= \left[\begin{matrix}\frac{6}{7} & - \frac{2}{7} & - \frac{3}{7}\\\frac{3}{7} & \frac{6}{7} & \frac{2}{7}\\\frac{2}{7} & - \frac{3}{7} & \frac{6}{7}\end{matrix}\right], \qquad R = \left[\begin{matrix}7 & 8 & \frac{11}{7}\\0 & 3 & \frac{1}{7}\\0 & 0 & \frac{5}{7}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(R \mathbf{{x}} = Q^T \mathbf{{b}}\)
\begin{align*}
    \left[\begin{matrix}7 & 8 & \frac{11}{7}\\0 & 3 & \frac{1}{7}\\0 & 0 & \frac{5}{7}\end{matrix}\right] \mathbf{x} = \left[\begin{matrix}\frac{6}{7} & \frac{3}{7} & \frac{2}{7}\\- \frac{2}{7} & \frac{6}{7} & - \frac{3}{7}\\- \frac{3}{7} & \frac{2}{7} & \frac{6}{7}\end{matrix}\right]\left[\begin{matrix}3\\0\\4\end{matrix}\right] = \left[\begin{matrix}\frac{26}{7}\\- \frac{18}{7}\\\frac{15}{7}\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_{3} &= \frac{1}{\frac{5}{7}} (\frac{15}{7}) = 3, \\
    x_{2} &= \frac{1}{3} (- \frac{18}{7} - \frac{1}{7}(3)) = -1, \\
    x_{1} &= \frac{1}{7} (\frac{26}{7} - 8(-1) - \frac{11}{7}(3)) = 1.
\end{align*}
\sphinxAtStartPar
(c)
\begin{align*}
    x_1 + 2 x_2 +   x_3 &= 3,\\
    x_1 + 4 x_2 + 3 x_3 &= 9,\\
    x_1 - 4 x_2 + 6 x_3 &= 29,\\
    x_1 + 2 x_2 +   x_3 &= 3.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
\(j = 1\):
\begin{align*}
    \mathbf{u}_{1} &= \mathbf{a}_{1} = \left[\begin{matrix}1 & 1 & 1 & 1\end{matrix}\right]^T, \\
    r_{11} &= \| \mathbf{u}_{1} \| = 2, \\
    \mathbf{q}_{1} &= \frac{\mathbf{u}_{1}}{r_{11}} = \frac{\left[\begin{matrix}1 & 1 & 1 & 1\end{matrix}\right]^T}{2} = \left[\begin{matrix}\frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
\(j = 2\):
\begin{align*}
    r_{12} &= \mathbf{q}_{1} \cdot \mathbf{a}_{2} = 2, \\
    \mathbf{u}_{2} &= \mathbf{a}_{2} - r_{12} \mathbf{q}_{1} = \left[\begin{matrix}1 & 3 & -5 & 1\end{matrix}\right]^T, \\
    r_{22} &= \| \mathbf{u}_{2} \| = 6, \\
    \mathbf{q}_{2} &= \frac{\mathbf{u}_{2}}{r_{22}} = \frac{\left[\begin{matrix}1 & 3 & -5 & 1\end{matrix}\right]^T}{6} = \left[\begin{matrix}\frac{1}{6} & \frac{1}{2} & - \frac{5}{6} & \frac{1}{6}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
\(j = 3\):
\begin{align*}
    r_{13} &= \mathbf{q}_{1} \cdot \mathbf{a}_{3} = \frac{11}{2}, \\
    r_{23} &= \mathbf{q}_{2} \cdot \mathbf{a}_{3} = - \frac{19}{6}, \\
    \mathbf{u}_{3} &= \mathbf{a}_{3} - r_{13} \mathbf{q}_{1} - r_{23} \mathbf{q}_{2} = \left[\begin{matrix}- \frac{11}{9} & \frac{11}{6} & \frac{11}{18} & - \frac{11}{9}\end{matrix}\right]^T, \\
    r_{33} &= \| \mathbf{u}_{3} \| = \frac{11 \sqrt{2}}{6}, \\
    \mathbf{q}_{3} &= \frac{\mathbf{u}_{3}}{r_{33}} = \frac{\left[\begin{matrix}- \frac{11}{9} & \frac{11}{6} & \frac{11}{18} & - \frac{11}{9}\end{matrix}\right]^T}{\frac{11 \sqrt{2}}{6}} \\
    &= \left[\begin{matrix}- \frac{\sqrt{2}}{3} & \frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{6} & - \frac{\sqrt{2}}{3}\end{matrix}\right]^T, \\
     \\
\end{align*}
\sphinxAtStartPar
therefore
\begin{align*}
    Q &= \left[\begin{matrix}\frac{1}{2} & \frac{1}{6} & - \frac{\sqrt{2}}{3}\\\frac{1}{2} & \frac{1}{2} & \frac{\sqrt{2}}{2}\\\frac{1}{2} & - \frac{5}{6} & \frac{\sqrt{2}}{6}\\\frac{1}{2} & \frac{1}{6} & - \frac{\sqrt{2}}{3}\end{matrix}\right], \qquad R = \left[\begin{matrix}2 & 2 & \frac{11}{2}\\0 & 6 & - \frac{19}{6}\\0 & 0 & \frac{11 \sqrt{2}}{6}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(R \mathbf{{x}} = Q^T \mathbf{{b}}\)
\begin{align*}
    \left[\begin{matrix}2 & 2 & \frac{11}{2}\\0 & 6 & - \frac{19}{6}\\0 & 0 & \frac{11 \sqrt{2}}{6}\end{matrix}\right] \mathbf{x} = \left[\begin{matrix}\frac{1}{2} & \frac{1}{2} & \frac{1}{2} & \frac{1}{2}\\\frac{1}{6} & \frac{1}{2} & - \frac{5}{6} & \frac{1}{6}\\- \frac{\sqrt{2}}{3} & \frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{6} & - \frac{\sqrt{2}}{3}\end{matrix}\right]\left[\begin{matrix}3\\9\\29\\3\end{matrix}\right] = \left[\begin{matrix}22\\- \frac{56}{3}\\\frac{22 \sqrt{2}}{3}\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_{3} &= \frac{1}{\frac{11 \sqrt{2}}{6}} (\frac{22 \sqrt{2}}{3}) = 4, \\
    x_{2} &= \frac{1}{6} (- \frac{56}{3} - (- \frac{19}{6})(4)) = -1, \\
    x_{1} &= \frac{1}{2} (22 - 2(-1) - \frac{11}{2}(4)) = 1.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 6.5}

\sphinxAtStartPar
Using pen and paper, solve the system of equations from part (b) of {\hyperref[\detokenize{6_Direct_methods/6.6_Direct_methods_exercises:ex6-4}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 6.4}}}} using QR decomposition with {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Householder transformations}}}}.
\subsubsection*{Solution}

\sphinxAtStartPar
Column \(j = 1\):
\begin{align*}
    \mathbf{u} &= \mathbf{r}_{1} + \operatorname{sign}(r_{11}) \| \mathbf{r}_{1} \| \mathbf{e} = \left[\begin{matrix}6 & 3 & 2\end{matrix}\right]^T + 7 \left[\begin{matrix}1 & 0 & 0\end{matrix}\right]^T \\
    &= \left[\begin{matrix}13 & 3 & 2\end{matrix}\right]^T, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|} = \frac{\left[\begin{matrix}13 & 3 & 2\end{matrix}\right]^T}{\sqrt{182}}, \\
    H &= I_3 - 2\mathbf{vv}^T = I_3 - \frac{2}{182}\left[\begin{matrix}\frac{\sqrt{182}}{14}\\\frac{3 \sqrt{182}}{182}\\\frac{\sqrt{182}}{91}\end{matrix}\right]\left[\begin{matrix}\frac{\sqrt{182}}{14} & \frac{3 \sqrt{182}}{182} & \frac{\sqrt{182}}{91}\end{matrix}\right] \\
      &= I_3 - \frac{1}{91}\left[\begin{matrix}\frac{13}{14} & \frac{3}{14} & \frac{1}{7}\\\frac{3}{14} & \frac{9}{182} & \frac{3}{91}\\\frac{1}{7} & \frac{3}{91} & \frac{2}{91}\end{matrix}\right] = \left[\begin{matrix}- \frac{6}{7} & - \frac{3}{7} & - \frac{2}{7}\\- \frac{3}{7} & \frac{82}{91} & - \frac{6}{91}\\- \frac{2}{7} & - \frac{6}{91} & \frac{87}{91}\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
Updating \(R\) and \(Q\)
\begin{align*}
    R &= H R = \left[\begin{matrix}- \frac{6}{7} & - \frac{3}{7} & - \frac{2}{7}\\- \frac{3}{7} & \frac{82}{91} & - \frac{6}{91}\\- \frac{2}{7} & - \frac{6}{91} & \frac{87}{91}\end{matrix}\right]\left[\begin{matrix}6 & 6 & 1\\3 & 6 & 1\\2 & 1 & 1\end{matrix}\right] = \left[\begin{matrix}-7 & -8 & - \frac{11}{7}\\0 & \frac{36}{13} & \frac{37}{91}\\0 & - \frac{15}{13} & \frac{55}{91}\end{matrix}\right], \\
    Q &= Q H = \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{matrix}\right]\left[\begin{matrix}- \frac{6}{7} & - \frac{3}{7} & - \frac{2}{7}\\- \frac{3}{7} & \frac{82}{91} & - \frac{6}{91}\\- \frac{2}{7} & - \frac{6}{91} & \frac{87}{91}\end{matrix}\right] = \left[\begin{matrix}- \frac{6}{7} & - \frac{3}{7} & - \frac{2}{7}\\- \frac{3}{7} & \frac{82}{91} & - \frac{6}{91}\\- \frac{2}{7} & - \frac{6}{91} & \frac{87}{91}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Column \(j = 2\):
\begin{align*}
    \mathbf{u} &= \mathbf{r}_{2} + \operatorname{sign}(r_{22}) \| \mathbf{r}_{2} \| \mathbf{e} = \left[\begin{matrix}\frac{36}{13} & - \frac{15}{13}\end{matrix}\right]^T + 3 \left[\begin{matrix}1 & 0\end{matrix}\right]^T = \left[\begin{matrix}\frac{75}{13} & - \frac{15}{13}\end{matrix}\right]^T, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|} = \frac{\left[\begin{matrix}\frac{75}{13} & - \frac{15}{13}\end{matrix}\right]^T}{\frac{15 \sqrt{26}}{13}}, \\
    H &= I_2 - 2\mathbf{vv}^T = I_2 - \frac{2}{\frac{450}{13}}\left[\begin{matrix}\frac{5 \sqrt{26}}{26}\\- \frac{\sqrt{26}}{26}\end{matrix}\right]\left[\begin{matrix}\frac{5 \sqrt{26}}{26} & - \frac{\sqrt{26}}{26}\end{matrix}\right] \\
      &= I_2 - \frac{13}{225}\left[\begin{matrix}\frac{25}{26} & - \frac{5}{26}\\- \frac{5}{26} & \frac{1}{26}\end{matrix}\right] = \left[\begin{matrix}- \frac{12}{13} & \frac{5}{13}\\\frac{5}{13} & \frac{12}{13}\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
Adding the first 1 rows and columns of the identity matrix to \(H\)
\begin{align*}
    H &= \left[\begin{matrix}1 & 0 & 0\\0 & - \frac{12}{13} & \frac{5}{13}\\0 & \frac{5}{13} & \frac{12}{13}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Updating \(R\) and \(Q\)
\begin{align*}
    R = H R &= \left[\begin{matrix}1 & 0 & 0\\0 & - \frac{12}{13} & \frac{5}{13}\\0 & \frac{5}{13} & \frac{12}{13}\end{matrix}\right]\left[\begin{matrix}-7 & -8 & - \frac{11}{7}\\0 & \frac{36}{13} & \frac{37}{91}\\0 & - \frac{15}{13} & \frac{55}{91}\end{matrix}\right] \\
    &= \left[\begin{matrix}-7 & -8 & - \frac{11}{7}\\0 & -3 & - \frac{1}{7}\\0 & 0 & \frac{5}{7}\end{matrix}\right], \\
    Q = Q H &= \left[\begin{matrix}- \frac{6}{7} & - \frac{3}{7} & - \frac{2}{7}\\- \frac{3}{7} & \frac{82}{91} & - \frac{6}{91}\\- \frac{2}{7} & - \frac{6}{91} & \frac{87}{91}\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0\\0 & - \frac{12}{13} & \frac{5}{13}\\0 & \frac{5}{13} & \frac{12}{13}\end{matrix}\right] \\
    &= \left[\begin{matrix}- \frac{6}{7} & \frac{2}{7} & - \frac{3}{7}\\- \frac{3}{7} & - \frac{6}{7} & \frac{2}{7}\\- \frac{2}{7} & \frac{3}{7} & \frac{6}{7}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Column \(j = 3\):
\begin{align*}
    \mathbf{u} &= \mathbf{r}_{3} + \operatorname{sign}(r_{33}) \| \mathbf{r}_{3} \| \mathbf{e} = \left[\begin{matrix}\frac{5}{7}\end{matrix}\right]^T + \frac{5}{7} \left[\begin{matrix}1\end{matrix}\right]^T = \left[\begin{matrix}\frac{10}{7}\end{matrix}\right]^T, \\
    \mathbf{v} &= \frac{\mathbf{u}}{\| \mathbf{u} \|} = \frac{\left[\begin{matrix}\frac{10}{7}\end{matrix}\right]^T}{\frac{10}{7}}, \\
    H &= I_1 - 2\mathbf{vv}^T = I_1 - \frac{2}{\frac{100}{49}}\left[\begin{matrix}1\end{matrix}\right]\left[\begin{matrix}1\end{matrix}\right] \\
      &= I_1 - \frac{49}{50}\left[\begin{matrix}1\end{matrix}\right] = \left[\begin{matrix}-1\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
Adding the first 2 rows and columns of the identity matrix to \(H\)
\begin{align*}
    H &= \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & -1\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Updating \(R\) and \(Q\)
\begin{align*}
    R &= H R = \left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & -1\end{matrix}\right]\left[\begin{matrix}-7 & -8 & - \frac{11}{7}\\0 & -3 & - \frac{1}{7}\\0 & 0 & \frac{5}{7}\end{matrix}\right] = \left[\begin{matrix}-7 & -8 & - \frac{11}{7}\\0 & -3 & - \frac{1}{7}\\0 & 0 & - \frac{5}{7}\end{matrix}\right], \\
    Q &= Q H = \left[\begin{matrix}- \frac{6}{7} & \frac{2}{7} & - \frac{3}{7}\\- \frac{3}{7} & - \frac{6}{7} & \frac{2}{7}\\- \frac{2}{7} & \frac{3}{7} & \frac{6}{7}\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & -1\end{matrix}\right] = \left[\begin{matrix}- \frac{6}{7} & \frac{2}{7} & \frac{3}{7}\\- \frac{3}{7} & - \frac{6}{7} & - \frac{2}{7}\\- \frac{2}{7} & \frac{3}{7} & - \frac{6}{7}\end{matrix}\right].
\end{align*}
\sphinxAtStartPar
Solve \(R \mathbf{{x}} = Q^T \mathbf{{b}}\)
\begin{align*}
    \left[\begin{matrix}-7 & -8 & - \frac{11}{7}\\0 & -3 & - \frac{1}{7}\\0 & 0 & - \frac{5}{7}\end{matrix}\right] \mathbf{x} = \left[\begin{matrix}- \frac{6}{7} & - \frac{3}{7} & - \frac{2}{7}\\\frac{2}{7} & - \frac{6}{7} & \frac{3}{7}\\\frac{3}{7} & - \frac{2}{7} & - \frac{6}{7}\end{matrix}\right]\left[\begin{matrix}3\\0\\4\end{matrix}\right] = \left[\begin{matrix}- \frac{26}{7}\\\frac{18}{7}\\- \frac{15}{7}\end{matrix}\right],
\end{align*}
\sphinxAtStartPar
gives
\begin{align*}
    x_{3} &= \frac{1}{- \frac{5}{7}} \left(- \frac{15}{7} \right) = 3, \\
    x_{2} &= \frac{1}{-3} \left(\frac{18}{7} - \left( - \frac{1}{7} \right) \left( 3 \right) \right) = -1, \\
    x_{1} &= \frac{1}{-7} \left(- \frac{26}{7} - \left( -8 \right) \left( -1 \right) - \left( - \frac{11}{7} \right) \left( 3 \right) \right) = 1.
\end{align*}\end{sphinxadmonition}

\sphinxstepscope


\chapter{Indirect Methods}
\label{\detokenize{7_Indirect_methods/7.0_Indirect_methods:indirect-methods}}\label{\detokenize{7_Indirect_methods/7.0_Indirect_methods:indirect-methods-chapter}}\label{\detokenize{7_Indirect_methods/7.0_Indirect_methods::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Learning outcomes}

\sphinxAtStartPar
On successful completion of this chapter readers will be able to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
understand the concept of an indirect method when used to solve a system of linear equations;

\item {} 
\sphinxAtStartPar
apply the Jacobi, Gauss\sphinxhyphen{}Seidel and SOR methods to solve a linear system;

\item {} 
\sphinxAtStartPar
use the residual to determine the accuracy of the current estimate of the solution to the linear system;

\item {} 
\sphinxAtStartPar
determine whether an indirect method is convergent for a particular linear system and analyse the theoretical rate of convergence for indirect methods.

\end{itemize}


\section{Indirect methods}
\label{\detokenize{7_Indirect_methods/7.0_Indirect_methods:id1}}
\sphinxAtStartPar
Indirect methods for solving systems of linear equations use an iterative approach to repeatedly update estimates of the exact solution to the linear system. They are called \sphinxstylestrong{indirect methods} since multiple applications of the method is required to calculate a solution unlike {\hyperref[\detokenize{6_Direct_methods/6.0_Direct_methods:direct-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{direct methods}}}} such as Gaussian elimination and LU decomposition which require a single application to calculate the solution. However, direct methods are inefficient for large systems of equations for which we tend to use indirect methods instead.

\sphinxAtStartPar
An indirect method for solving a system of linear equations of the form \(A \mathbf{x}= \mathbf{b}\) is
\begin{equation}\label{equation:7_Indirect_methods/7.0_Indirect_methods:iteration-matrix-equation}
\begin{split}\mathbf{x}^{(k+1)} =T\mathbf{x}^{(k)} + \mathbf{c},\end{split}
\end{equation}
\sphinxAtStartPar
where \(\mathbf{x}^{(k)}\) and \(\mathbf{x}^{(k+1)}\) are the current and improved estimates of \(\mathbf{x}\), \(T\) is an \sphinxstylestrong{iteration matrix} and \(\mathbf{c}\) is some vector. This equation is iterated updating the values of the estimates such that \(\mathbf{x}^{(k)} \to \mathbf{x}\) as \(k\to \infty\). Note that unlike direct methods which will calculate the exact solution, indirect only calculate an estimate (albeit very close) of the exact solution.

\sphinxstepscope


\section{Jacobi method}
\label{\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method}}\label{\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-section}}\label{\detokenize{7_Indirect_methods/7.1_Jacobi_method::doc}}
\sphinxAtStartPar
The Jacobi method is the simplest indirect method. Splitting the coefficient matrix \(A\) into the of elements from the lower triangular, diagonal and upper triangular parts of \(A\) to form matrices \(L\),\(D\) and \(U\) such that \(A = L + D + U\), e.g.,
\begin{align*}
    L&=\begin{pmatrix}
        0 & 0 & \cdots  & 0\\
        a_{21}  & 0 & \ddots  & \vdots \\
        \vdots  & \ddots  & \ddots  & 0\\
        a_{n1}  & \cdots  & a_{n,n-1}  & 0
    \end{pmatrix},&
    D&=\begin{pmatrix}
        a_{11}  & 0 & \cdots  & 0\\
        0 & a_{22}  & \ddots  & \vdots \\
        \vdots  & \ddots  & \ddots  & 0\\
        0 & \cdots  & 0 & a_{nn} 
    \end{pmatrix}, \\ \\
    U&=\begin{pmatrix}
        0 & a_{12}  & \cdots  & a_{1n}  \\
        0 & 0 & \ddots  & \vdots  \\
        \vdots  & \ddots  & \ddots  & a_{n-1,n}  \\
        0 & \cdots  & 0 & 0 
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Rewriting the linear system \(A\mathbf{x}=\mathbf{b}\) using \(L\), \(D\) and \(U\) gives
\begin{align*}
    (L+D+U)\mathbf{x}&=\mathbf{b}\\
    (L+U)\mathbf{x}+D\mathbf{x}&=\mathbf{b}\\
    D\mathbf{x}&=\mathbf{b}-(L+U)\mathbf{x}\\
    \mathbf{x}&=D^{-1} (\mathbf{b}-(L+U)\mathbf{x}).
\end{align*}
\sphinxAtStartPar
Let the \(\mathbf{x}\) on the left\sphinxhyphen{}hand side be \(\mathbf{x}^{(k+1)}\) and the \(\mathbf{x}\) on the right\sphinxhyphen{}hand side be \(\mathbf{x}^{(k)}\) then
\begin{equation}\label{equation:7_Indirect_methods/7.1_Jacobi_method:matrix-form-of-the-jacobi-method-equation}
\begin{split}\mathbf{x}^{(k+1)} = D^{-1} (\mathbf{b} - (L + U)\mathbf{x}^{(k)}),\end{split}
\end{equation}
\sphinxAtStartPar
and writing this out for each element gives the Jacobi method gives the following definition of the Jacobi method.

\begin{sphinxadmonition}{note}{Definition: The Jacobi method}

\sphinxAtStartPar
The Jacobi method for solving a system of linear equations of the form \(A \mathbf{x} = \mathbf{b}\) is
\begin{equation}\label{equation:7_Indirect_methods/7.1_Jacobi_method:jacobi-method-equation}
\begin{split}    x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j = 1}^{i-1} a_{ij} x_j^{(k)} - \sum_{j = i+1}^n a_{ij} x_j^{(k)} \right), \qquad i = 1, \ldots ,n.\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
The iteration matrix for the Jacobi method can be determined by rearranging equation \eqref{equation:7_Indirect_methods/7.1_Jacobi_method:matrix-form-of-the-jacobi-method-equation}
\begin{align*}
    \mathbf{x}^{(k+1)} &= D^{-1}(\mathbf{b} - (L + U) \mathbf{x}^{(k)}) \\
    &= - D^{-1}(L + U) \mathbf{x}^{(k)} + D^{-1}\mathbf{b},
\end{align*}
\sphinxAtStartPar
and comparing to equation \eqref{equation:7_Indirect_methods/7.0_Indirect_methods:iteration-matrix-equation} we have

\begin{sphinxadmonition}{note}{Definition: Iteration matrix for the Jacobi method}

\sphinxAtStartPar
The iteration matrix for the Jacobi method is
\begin{equation}\label{equation:7_Indirect_methods/7.1_Jacobi_method:jacobi-method-iteration-matrix-equation}
\begin{split}T_J = - D^{-1}(L + U),\end{split}
\end{equation}
\sphinxAtStartPar
where \(A = L + D + U\) such that \(L\), \(D\) and \(U\) are lower triangular, diagonal and upper triangular matrices respectively.
\end{sphinxadmonition}

\sphinxAtStartPar
The iteration matrix is used to analyse the convergence properties of the method.

\sphinxAtStartPar
The Jacobi method is applied by iterating equation \eqref{equation:7_Indirect_methods/7.1_Jacobi_method:jacobi-method-equation} until the estimate \(\mathbf{x}^{(k+1)}\) is accurate enough for our needs. Since we do not know what the exact solution is, we need a way to estimate the error in our approximations. Since \(\mathbf{x}^{(k)}\) is an approximation of the exact solution \(\mathbf{x}\) then if \(\mathbf{e}^{(k)}\) is the error of the \(k\)th iteration we have \(\mathbf{x} = \mathbf{x}^{(k)} + \mathbf{e}^{(k)}\). Substituting this into the linear system \(A\mathbf{x} = \mathbf{b}\) and rearranging gives
\begin{align*}
    A (\mathbf{x}^{(k)} +\mathbf{e}^{(k)}) &= \mathbf{b} \\
    A\mathbf{e}^{(k)} &= \mathbf{b} - A\mathbf{x}^{(k)}.
\end{align*}
\sphinxAtStartPar
Let \(\mathbf{r}^{(k)} = A\mathbf{e}^{(k)}\) be an \(n \times 1\) column vector known as the \sphinxstylestrong{residual}

\begin{sphinxadmonition}{note}{Definition: The residual}
\begin{equation}\label{equation:7_Indirect_methods/7.1_Jacobi_method:residual-equation}
\begin{split}\mathbf{r}  = \mathbf{b} - A \mathbf{x}^{(k)}.\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
As \(\mathbf{x}^{(k)} \to \mathbf{x}\), \(\mathbf{r} \to 0\) so we can use the following convergence criteria
\begin{align*}
    \max(|\mathbf{r}|) < tol,
\end{align*}
\sphinxAtStartPar
where \(tol\) is some small number. The smaller the value of \(tol\) the closer \(\mathbf{x}^{(k)}\) is to the exact solution but of course this will require more iterations. In practice a compromise is made between the accuracy required and the computational resources available. Typical values of \(tol\) are around \(10^{-4}\) or \(10^{-6}\).

\begin{sphinxadmonition}{note}{Example 7.1}

\sphinxAtStartPar
Use the Jacobi method to solve the following system of linear equations
\begin{align*}
    4x_1 +3x_2 &=-2, \\
    3x_1 +4x_2 -x_3 &=-8, \\
    -x_2 +4x_3 &=14.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
The Jacobi method for this system is
\begin{align*}
    x_{1}^{(k+1)} &= \frac{1}{4} \left( -2 - 3 x_{2}^{(k)} \right), \\
    x_{2}^{(k+1)} &= \frac{1}{4} \left( -8 - 3 x_{1}^{(k)} + x_{3}^{(k)} \right), \\
    x_{3}^{(k+1)} &= \frac{1}{4} \left( 14 + x_{2}^{(k)} \right).
\end{align*}
\sphinxAtStartPar
Using starting values of \(\mathbf{x} = \mathbf{0}\). Calculating the first iteration
\begin{align*}
    x_{1}^{(1)} &= \frac{1}{4} \left( -2 - 3 (-2.0) \right) = -0.5, \\
    x_{2}^{(1)} &= \frac{1}{4} \left( -8 - 3 (-0.5) + -3.5 \right) = -2.0, \\
    x_{3}^{(1)} &= \frac{1}{4} \left( 14 + 2.0 \right) = 3.5.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(1)} = \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} -2 \\ -8 \\ 14 \end{pmatrix} -
    \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}
    \begin{pmatrix} -0.5 \\ -2.0 \\ 3.5 \end{pmatrix} =
    \begin{pmatrix} 6.0 \\ 5.0 \\ -2.0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(1)} |) = 6.0 > 10^{-4}\) we continue iterating. Calculating the second iteration
\begin{align*}
    x_{1}^{(2)} &= \frac{1}{4} \left( -2 - 3 (-0.75) \right) = 1.0, \\
    x_{2}^{(2)} &= \frac{1}{4} \left( -8 - 3 (1.0) + -3.0 \right) = -0.75, \\
    x_{3}^{(2)} &= \frac{1}{4} \left( 14 + 0.75 \right) = 3.0.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(2)} = \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} -2 \\ -8 \\ 14 \end{pmatrix} -
    \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}
    \begin{pmatrix} 1.0 \\ -0.75 \\ 3.0 \end{pmatrix} =
    \begin{pmatrix} -3.75 \\ -5.0 \\ 1.25 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(2)} |) = 5.0 > 10^{-4}\) we continue iterating. The Jacobi method was iterated until \(\max(|\mathbf{r}|) < 10^{-4}\) and a selection of the iteration values are given in the table below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(k\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{0}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{1}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{2}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(\max(\mathbf{r})\)
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
14.000000
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}0.500000
&
\sphinxAtStartPar
\sphinxhyphen{}2.000000
&
\sphinxAtStartPar
3.500000
&
\sphinxAtStartPar
6.000000
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
1.000000
&
\sphinxAtStartPar
\sphinxhyphen{}0.750000
&
\sphinxAtStartPar
3.000000
&
\sphinxAtStartPar
5.000000
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0.062500
&
\sphinxAtStartPar
\sphinxhyphen{}2.000000
&
\sphinxAtStartPar
3.312500
&
\sphinxAtStartPar
3.750000
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
1.000000
&
\sphinxAtStartPar
\sphinxhyphen{}1.218750
&
\sphinxAtStartPar
3.000000
&
\sphinxAtStartPar
3.125000
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
0.414062
&
\sphinxAtStartPar
\sphinxhyphen{}2.000000
&
\sphinxAtStartPar
3.195312
&
\sphinxAtStartPar
2.343750
\\
\hline
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
\\
\hline
\sphinxAtStartPar
48
&
\sphinxAtStartPar
1.000000
&
\sphinxAtStartPar
\sphinxhyphen{}1.999975
&
\sphinxAtStartPar
3.000000
&
\sphinxAtStartPar
0.000101
\\
\hline
\sphinxAtStartPar
49
&
\sphinxAtStartPar
0.999981
&
\sphinxAtStartPar
\sphinxhyphen{}2.000000
&
\sphinxAtStartPar
3.000006
&
\sphinxAtStartPar
0.000076
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
So the Jacobi method took 48 iterations to converge to the solution \(x_1 =1\), \(x_2 =-2\) and \(x_3 = 3\).
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{7_Indirect_methods/7.1_Jacobi_method:python-code}}
\sphinxAtStartPar
The code below defines the function called \sphinxcode{\sphinxupquote{jacobi()}} which solves a linear system of equations of the form \(A \mathbf{b} = \mathbf{x}\) using the Jacobi method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{jacobi}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{xo} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{xo}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The inputs are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}} \sphinxhyphen{} the coefficient matrix;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} \sphinxhyphen{} the constant vector;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tol}} \sphinxhyphen{} the convergence tolerance (optional, default is \(10^{-6}\)).

\end{itemize}

\sphinxAtStartPar
An \(n\) element array \sphinxcode{\sphinxupquote{x}} is initialised to all zeros and will contain the solution vector \(\mathbf{x}\) for the system of linear equations. The Jacobi method is calculated until the maximum absolute residual value is less than \sphinxcode{\sphinxupquote{tol}} or 100 iterations have been calculated, whichever comes first. Since the Jacobi method only uses previous estimates to calculate the next estimates we store the old values in \sphinxcode{\sphinxupquote{xo}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{jacobi}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}4}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{1.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x1 = 0.999981
x2 = \PYGZhy{}2.000000
x3 = 3.000006
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Gauss\sphinxhyphen{}Seidel method}
\label{\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method}}\label{\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-section}}\label{\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method::doc}}
\sphinxAtStartPar
In the previous section on the {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi method}}}} we saw that the solution to the linear system of equations \(A \mathbf{x} = \mathbf{x}\) can be calculated by estimating the solution \(\mathbf{x}\) and calculate an improved estimation \(\mathbf{x}^{(k+1)}\) using values from the current estimation \(\mathbf{x}^{(k)}\). We continue to calculate the improved estimates until the largest absolute value in the {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:residual-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{residual}}}} is less than some convergence tolerance. When calculating the values in \(\mathbf{x}^{(k+1)}\) we only use values from the previous estimate \(\mathbf{x}^{k}\)
\begin{align*}
    x_i^{(k+1)} &= \frac{1}{a_{ii}} \left( b_i - \sum_{j=1}^n a_{ij} x_j^{(k)} \right), \\
    &= \frac{1}{a_{ii}} \left( b_i - \underbrace{a_{i1} x_1^{(k)} - \cdots - a_{i,j-1} x_{j-1}^{(k)}}_{\mathsf{already\,calculated}} - \underbrace{a_{i,j+1} x_{j+1}^{(k)} - \cdots - a_{in} x_n^{(k)}}_{\mathsf{yet\, to\, be\, calculated}} \right)
\end{align*}
\sphinxAtStartPar
so when calculating \(x_i\), we have already calculated the next values of \(x_1, x_2, \ldots, x_{i-1}\). We can improve the speed of which the Jacobi method converges by using these new values to calculate \(x_i^{(k+1)}\). This gives us the \sphinxstylestrong{Gauss\sphinxhyphen{}Seidel method}

\begin{sphinxadmonition}{note}{Definition: The Gauss\sphinxhyphen{}Seidel method}
\begin{equation}\label{equation:7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-equation}
\begin{split}x_i^{(k+1)} = \frac{1}{a_{ii} }\left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} -\sum_{j=i+1}^n a_{ij} x_j^{(k)} \right), \qquad i=1, \ldots , n\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
The iteration matrix for the Gauss\sphinxhyphen{}Seidel method can be found by rearranging \((L+D+U)\mathbf{x}=\mathbf{b}\)
\begin{align*}
    (L+D+U)\mathbf{x}&=\mathbf{b}\\
    (L+D)\mathbf{x}&=\mathbf{b}-U\mathbf{x}\\
    \mathbf{x}&=-(L+D)^{-1} U\mathbf{x}+(L+D)^{-1} \mathbf{x}.
\end{align*}
\sphinxAtStartPar
So the matrix equation for the Gauss\sphinxhyphen{}Seidel method is
\begin{align*}
    \mathbf{x}^{(k+1)} =-(L+D)^{-1} U\mathbf{x}^{(k)} +(L+D)^{-1} \mathbf{x}^{(k+1)},
\end{align*}
\sphinxAtStartPar
and the iteration matrix is

\begin{sphinxadmonition}{note}{Definition: Iteration matrix for the Gauss\sphinxhyphen{}Seidel method}
\begin{equation}\label{equation:7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-iteration-matrix-equation}
\begin{split}T_{GS} =-(L+D)^{-1} U.\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 7.2}

\sphinxAtStartPar
Use the Gauss\sphinxhyphen{}Seidel method to solve the system of linear equations from {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}}
\begin{align*}
    4x_1 +3x_2 &=-2,\\
    3x_1 +4x_2 -x_3 &=-8,\\
    -x_2 +4x_3 &=14.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
The Gauss\sphinxhyphen{}Seidel method for this system is
\begin{align*}
    x_{1}^{(k+1)} &= \frac{1}{4} \left( -2 - 3 x_{2}^{(k)} \right), \\
    x_{2}^{(k+1)} &= \frac{1}{4} \left( -8 - 3 x_{1}^{(k+1)} + x_{3}^{(k)} \right), \\
    x_{3}^{(k+1)} &= \frac{1}{4} \left( 14 + x_{2}^{(k+1)} \right).
\end{align*}
\sphinxAtStartPar
Using starting values of \(\mathbf{x} = \mathbf{0}\). Calculating the first iteration
\begin{align*}
    x_{1}^{(1)} &= \frac{1}{4} \left( -2 - 3 (-1.625) \right) = -0.5, \\
    x_{2}^{(1)} &= \frac{1}{4} \left( -8 - 3 (-0.5) + -3.09375 \right) = -1.625, \\
    x_{3}^{(1)} &= \frac{1}{4} \left( 14 + 1.625 \right) = 3.09375.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(1)} = \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} -2 \\ -8 \\ 14 \end{pmatrix} -
    \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}
    \begin{pmatrix} -0.5 \\ -1.625 \\ 3.09375 \end{pmatrix} =
    \begin{pmatrix} 4.875 \\ 3.09375 \\ 0.0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(1)} |) = 4.875 > 10^{-4}\) we continue iterating. Calculating the second iteration
\begin{align*}
    x_{1}^{(2)} &= \frac{1}{4} \left( -2 - 3 (-1.765625) \right) = 0.71875, \\
    x_{2}^{(2)} &= \frac{1}{4} \left( -8 - 3 (0.71875) + -3.058594 \right) = -1.765625, \\
    x_{3}^{(2)} &= \frac{1}{4} \left( 14 + 1.765625 \right) = 3.058594.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(2)} = \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} -2 \\ -8 \\ 14 \end{pmatrix} -
    \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}
    \begin{pmatrix} 0.71875 \\ -1.765625 \\ 3.058594 \end{pmatrix} =
    \begin{pmatrix} 0.421875 \\ -0.035156 \\ 0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(2)} |) = 0.421875 > 10^{-4}\) we continue iterating. The Gauss\sphinxhyphen{}Seidel method was iterated until \(|\mathbf{r}| < 10^{-4}\) and a selection of the iteration values are given in the table below. Note that the Gauss\sphinxhyphen{}Seidel method took 19 iterations to achieve convergence to \(tol=10^{-4}\) whereas the {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi method}}}} took 48 iterations to achieve the same accuracy.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(k\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{0}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{1}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{2}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(\max(\mathbf{r})\)
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
14.000000
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}0.500000
&
\sphinxAtStartPar
\sphinxhyphen{}1.625000
&
\sphinxAtStartPar
3.093750
&
\sphinxAtStartPar
4.875000
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0.718750
&
\sphinxAtStartPar
\sphinxhyphen{}1.765625
&
\sphinxAtStartPar
3.058594
&
\sphinxAtStartPar
0.421875
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0.824219
&
\sphinxAtStartPar
\sphinxhyphen{}1.853516
&
\sphinxAtStartPar
3.036621
&
\sphinxAtStartPar
0.263672
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0.890137
&
\sphinxAtStartPar
\sphinxhyphen{}1.908447
&
\sphinxAtStartPar
3.022888
&
\sphinxAtStartPar
0.164795
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
0.931335
&
\sphinxAtStartPar
\sphinxhyphen{}1.942780
&
\sphinxAtStartPar
3.014305
&
\sphinxAtStartPar
0.102997
\\
\hline
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar
\(\vdots\)
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
19
&
\sphinxAtStartPar
0.999905
&
\sphinxAtStartPar
\sphinxhyphen{}1.999921
&
\sphinxAtStartPar
3.000020
&
\sphinxAtStartPar
0.000143
\\
\hline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
0.999940
&
\sphinxAtStartPar
\sphinxhyphen{}1.999950
&
\sphinxAtStartPar
3.000012
&
\sphinxAtStartPar
0.000089
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:python-code}}
\sphinxAtStartPar
The code below defines the function \sphinxcode{\sphinxupquote{gauss\_seidel()}} which solves a linear system of equations of the for \(A \mathbf{x} = \mathbf{b}\) using the Gauss\sphinxhyphen{}Seidel method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gauss\PYGZus{}seidel}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Convergence of indirect methods}
\label{\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods:convergence-of-indirect-methods}}\label{\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods:convergence-of-indirect-methods-section}}\label{\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods::doc}}
\sphinxAtStartPar
We have seen that both the {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi}}}} and {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel}}}} methods are iterated until the estimates of the solution converge to a given tolerance. In {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}} required 49 iterations to converge to the solution of a system of linear equations whereas in {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.2}}}} only required 20 iterations to converge to the solution for the same system.

\sphinxAtStartPar
Not all indirect methods will converge for a given system of linear equations, we can establish whether a method will be convergent using the theorem below. Let \(\mathbf{e}^{(k)} = |\mathbf{x} - \mathbf{x}^{(k)}|\) be the error between the exact solution \(\mathbf{x}\) and the estimate \(\mathbf{x}^{(k)}\). The error from one estimate to the next is updated using the iteration matrix for the method
\begin{align*}
    \mathbf{e}^{(k+1)} = T\mathbf{e}^{(k)}.
\end{align*}
\sphinxAtStartPar
We can write the first error, \(\mathbf{e}^{(0)}\) as a linear combination of some vectors \(\mathbf{v}_i\)
\begin{align*}
    \mathbf{e}^{(0)} =\alpha_1 \mathbf{v}_1 +\alpha_2 \mathbf{v}_2 +\cdots +\alpha_n \mathbf{v}_n =\sum_{i=1}^n \alpha_i \mathbf{v}_i,
\end{align*}
\sphinxAtStartPar
where \(\alpha_i\) are scalars. If \(\mathbf{v}_i\) are the \sphinxhref{https://en.wikipedia.org/wiki/Eigenvalues\_and\_eigenvectors}{eigenvectors} of the matrix \(T\) with eigenvalues \(\lambda_i\) so \(T\mathbf{v}_i = \lambda_i \mathbf{v}_i\) then iterating \(\mathbf{e}^{(k)}\) gives
\begin{align*}
    \mathbf{e}^{(1)} &= T\mathbf{e}^{(0)} =T\left(\sum_{i=1}^n \alpha_i \mathbf{v}_i \right)=\sum_{i=1}^n \alpha_i T\mathbf{v}_i = \sum_{i=1}^n \alpha_i \lambda_i \mathbf{v}_i , \\
    \mathbf{e}^{(2)} &=T\mathbf{e}^{(1)} =T\left(\sum_{i=1}^n \alpha_i \lambda_i \mathbf{v}_i \right)=\sum_{i=1}^n \alpha_i \lambda_i T\mathbf{v}_i =\sum_{i=1}^n \alpha_i \lambda_i^2 \mathbf{v}_i , \\
    &\vdots \\
    \mathbf{e}^{(k+1)} &=\sum_{i=1}^n \alpha_i \lambda_i^{k+1} \mathbf{v}_i .
\end{align*}
\sphinxAtStartPar
If \(|\lambda_1|>\lambda_2, \lambda_3, \ldots \lambda_n\) then
\begin{align*}
    \mathbf{e}^{(k+1)} =\alpha_1 \lambda_1^{k+1} \mathbf{v}_1 +\sum_{i=2}^n \alpha_i \lambda_i^{k+1} \mathbf{v}_i =\lambda_1^{k+1} \left(\alpha_1 \mathbf{v}_1 +\sum_{i=2}^n \alpha_i \mathbf{v}_i {\left(\frac{\lambda_i }{\lambda_1 }\right)}^{k+1} \right)
\end{align*}
\sphinxAtStartPar
and since \(\lambda_i / \lambda_ 1 < 1\) then
\begin{align*}
    \lim_{k\to \infty } \mathbf{e}^{(k+1)} =\alpha_1 \lambda_1^{k+1} \mathbf{v}_1 .
\end{align*}
\sphinxAtStartPar
This means that as the number of iterations increases, the error varies by a factor of \(\lambda_1^{k+1}\) where \(\lambda_1\) is the largest eigenvalue of \(T\) which is known as the \sphinxstylestrong{spectral radius}.

\begin{sphinxadmonition}{note}{Definition: Spectral radius}

\sphinxAtStartPar
Let \(\lambda_1, \lambda_2, \ldots, \lambda_n\) be the eigenvalues of a matrix \(A\) then the spectral radius of \(A\) denoted by \(\rho(A)\) is
\begin{equation}\label{equation:7_Indirect_methods/7.3_Convergence_of_indirect_methods:spectral-radius-equation}
\begin{split}\begin{align*}
    \rho(A) = \max_i(|\lambda_i|).
\end{align*}\end{split}
\end{equation}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Theorem: Convergence criteria for an indirect method}

\sphinxAtStartPar
The spectral radius of \(T\) gives us the following information about an indirect method
\begin{itemize}
\item {} 
\sphinxAtStartPar
If \(\rho (T) > 1\) then the errors will increase over each iteration, therefore for an indirect method to converge to the solution we require \(\rho (T)< 1\).

\item {} 
\sphinxAtStartPar
The smaller the value of \(\rho (T)\) the faster the errors will tend to zero.
\textbackslash{}end\{itemize\}

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 7.3}

\sphinxAtStartPar
Show that the Jacobi and Gauss\sphinxhyphen{}Seidel methods are convergent of the system of linear equations from {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}}.
\subsubsection*{Solution}

\sphinxAtStartPar
The coefficient matrix for this linear system is
\begin{align*}
    A = \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
so
\begin{align*}
    L &= \begin{pmatrix} 0 & 0 & 0 \\ 3 & 0 & 0 \\ 0 & -1 & 0 \end{pmatrix}, &
    D &= \begin{pmatrix} 4 & 0 & 0 \\ 0 & 4 & 0 \\ 0 & 0 & 4 \end{pmatrix}, \\
    U &= \begin{pmatrix} 0 & 3 & 0 \\ 0 & 0 & -1 \\ 0 & 0 & 0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The iteration matrices for the Jacobi and Gauss\sphinxhyphen{}Seidel methods are given in equations \eqref{equation:7_Indirect_methods/7.1_Jacobi_method:jacobi-method-iteration-matrix-equation} and \eqref{equation:7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-iteration-matrix-equation} which for this system are
\begin{align*}
    T_J &= -D ( L + U) 
    = -\begin{pmatrix} 4 & 0 & 0 \\ 0 & 4 & 0 \\ 0 & 0 & 4 \end{pmatrix} \left(
    \begin{pmatrix} 0 & 0 & 0 \\ 3 & 0 & 0 \\ 0 & -1 & 0 \end{pmatrix} +
    \begin{pmatrix} 4 & 0 & 0 \\ 0 & 4 & 0 \\ 0 & 0 & 4 \end{pmatrix} \right) \\
    &= - \begin{pmatrix} \frac{1}{4} & 0 & 0 \\ 0 & \frac{1}{4} & 0 \\ 0 & 0 & \frac{1}{4} \end{pmatrix}
    \begin{pmatrix} 0 & 3 & 0 \\ 3 & 0 & -1 \\ 0 & -1 & 0 \end{pmatrix} 
    = \begin{pmatrix} 0 & -\frac{3}{4} & 0 \\ -\frac{3}{4} & 0 & \frac{1}{4} \\ 0 & \frac{1}{4} & 0 \end{pmatrix}, \\
    T_{GS} &= - (L + D)^{-1} U 
    = - \begin{pmatrix} 3 & 0 & 0 \\ 3 & 4 & 0 \\ 0 & -1 & 4 \end{pmatrix}^{-1}
    \begin{pmatrix} 0 & 3 & 0 \\ 0 & 0 & -1 \\ 0 & 0 & 0 \end{pmatrix} \\ 
    &= \begin{pmatrix} -\frac{1}{4} & 0 & 0 \\ \frac{3}{16} & \frac{1}{4} & 0 \\ \frac{3}{64} & -\frac{1}{16} & \frac{1}{4} \end{pmatrix}
    \begin{pmatrix} 0 & 3 & 0 \\ 0 & 0 & -1 \\ 0 & 0 & 0 \end{pmatrix} =
    \begin{pmatrix} 0 & -\frac{3}{4} & 0 \\ 0 & \frac{9}{16} & \frac{1}{4} \\ 0 & \frac{9}{64} & \frac{1}{16} \end{pmatrix}
\end{align*}
\sphinxAtStartPar
Calculating the spectral radius for these iteration matrices gives \(\rho(T_J )=0.7906\) and \(\rho (T_{GS})=0.625\) which are both less than 1 so both of these methods are convergent for this system. Furthermore, the Gauss\sphinxhyphen{}Seidel method will converge faster than the Jacobi method since it has a smaller spectral radius.
\end{sphinxadmonition}

\sphinxstepscope


\section{The Successive Over Relaxation (SOR) method}
\label{\detokenize{7_Indirect_methods/7.4_SOR_method:the-successive-over-relaxation-sor-method}}\label{\detokenize{7_Indirect_methods/7.4_SOR_method:sor-method-section}}\label{\detokenize{7_Indirect_methods/7.4_SOR_method::doc}}
\sphinxAtStartPar
The \sphinxstylestrong{Successive Over Relaxation (SOR)} method improves on the convergence rate of the {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel}}}} method by applying a weighting factor to the updated estimates to adjust the extent of the change. Let \(\omega\) be a \sphinxstylestrong{relaxation parameter} in the range \([0,2]\) then the SOR method is

\begin{sphinxadmonition}{note}{Definition: The Successive Over Relaxation (SOR) method}

\sphinxAtStartPar
The SOR method for solving a system of linear equations of the form \(A \mathbf{x} = \mathbf{b}\) is
\begin{equation}\label{equation:7_Indirect_methods/7.4_SOR_method:sor-method-equation}
\begin{split}x_i^{(k+1)} =(1 - \omega) x_i^{(k)} + \frac{\omega}{a_{ii} }\left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} -\sum_{j=i+1}^n a_{ij} x_j^{(k)} \right), \qquad i = 1, \ldots, n.\end{split}
\end{equation}
\sphinxAtStartPar
where \(\omega \in [0, 2]\).
\end{sphinxadmonition}

\sphinxAtStartPar
The iteration matrix for the SOR method is derived by writing the coefficient matrix of the linear system \(A\mathbf{x}=\mathbf{b}\) using
\begin{align*}
    A = L+\left(1-\frac{1}{\omega }\right)D+\frac{1}{\omega }D+U.
\end{align*}
\sphinxAtStartPar
Substituting into the linear system \(A \mathbf{x} = \mathbf{b}\) and rearranging
\begin{align*}
    \left(L+\left(1-\frac{1}{\omega }\right)D+\frac{1}{\omega }D+U\right)\mathbf{x}&=\mathbf{b}\\
    (D+\omega L)\mathbf{x}+((\omega -1)D+\omega U)\mathbf{x}&=\omega \mathbf{b}\\
    (D+\omega L)\mathbf{x}&=((1-\omega )D-\omega U)\mathbf{x}+\omega \mathbf{b}\\
    \mathbf{x}&=(D+\omega L)^{-1} ((1-\omega )D-\omega U)\mathbf{x}+(D+\omega L)^{-1} \omega \mathbf{b}.
\end{align*}
\sphinxAtStartPar
So the matrix form of the SOR method is
\begin{align*}
    \mathbf{x}^{(k+1)} =(D+\omega L)^{-1} ((1-\omega )D-\omega U)\mathbf{x}^{(k)} +(D+\omega L)^{-1} \omega \mathbf{b}
\end{align*}
\sphinxAtStartPar
and the iteration matrix is

\begin{sphinxadmonition}{note}{Definition: Iteration matrix for the SOR method}
\begin{equation}\label{equation:7_Indirect_methods/7.4_SOR_method:sor-method-iteration-matrix-equation}
\begin{split}T_{SOR} =(D+\omega L)^{-1} ((1-\omega )D-\omega U).\end{split}
\end{equation}\end{sphinxadmonition}

\sphinxAtStartPar
The value of \(\omega\) affects the rate of convergence of the SOR method and is determined by how the Gauss\sphinxhyphen{}Seidel method converges to the exact solution. Consider the diagrams in \hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:over-relaxation-figure}]{Fig.\@ \ref{\detokenize{7_Indirect_methods/7.4_SOR_method:over-relaxation-figure}}} and \hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:under-relaxation-figure}]{Fig.\@ \ref{\detokenize{7_Indirect_methods/7.4_SOR_method:under-relaxation-figure}}} below that shows the two types of convergence of the Gauss\sphinxhyphen{}Seidel method. When we have \sphinxhref{https://en.wikipedia.org/wiki/Monotonic\_function}{monotonic} convergence where each successive iteration approaches the exact solution from a single side (\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:over-relaxation-figure}]{Fig.\@ \ref{\detokenize{7_Indirect_methods/7.4_SOR_method:over-relaxation-figure}}}), the rate of convergence is improved by using \(\omega > 1\) so that the change in subsequent approximations is increased. When we have oscillatory convergence where successive iterations overshoot the exact solution (\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:under-relaxation-figure}]{Fig.\@ \ref{\detokenize{7_Indirect_methods/7.4_SOR_method:under-relaxation-figure}}}) the rate of convergence is improved by using \(\omega < 1\) so that the change in the subsequent approximation is decreased.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sor_1}.png}
\caption{The estimated solution approaches the exact solution monotonically.}\label{\detokenize{7_Indirect_methods/7.4_SOR_method:over-relaxation-figure}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sor_2}.png}
\caption{The estimated solution oscillates about the exact solution.}\label{\detokenize{7_Indirect_methods/7.4_SOR_method:under-relaxation-figure}}\end{figure}


\subsection{Optimum value of the relaxation parameter}
\label{\detokenize{7_Indirect_methods/7.4_SOR_method:optimum-value-of-the-relaxation-parameter}}\label{\detokenize{7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-section}}
\sphinxAtStartPar
The optimum value of \(\omega\) will be the one that minimises the spectral radius of the iteration matrix. The {\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:sor-method-iteration-matrix-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{iteration matrix}}}} will depend on the value of \(\omega\). One way to estimate the optimum value of \(\omega\) is to calculate \(\rho(T_{SOR})\) for values in the range \(\omega \in [0, 2]\) and choose the value of \(\omega\) which minimises this value. This has been done for the system of linear equations from {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}} and the plot is shown in \hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-figure}]{Fig.\@ \ref{\detokenize{7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-figure}}}.

\begin{figure}[htbp]
\centering
\capstart
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{7.4_SOR_method_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}
\caption{Plot of the spectral radius \(\rho(T_{SOR})\) of the iteration matrix for the SOR method when used to solve the system of linear equations from {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}}.}\label{\detokenize{7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-figure}}\end{figure}

\sphinxAtStartPar
So an estimation of the optimum value of the relaxation parameters is \(\omega = 1.25\).

\sphinxAtStartPar
If the coefficient matrix \(A\) has real eigenvalues we can use the following theorem to calculate the exact value of \(\omega\).

\begin{sphinxadmonition}{note}{Theorem: Optimum relaxation parameter}

\sphinxAtStartPar
If a system of linear equations of the form \(A\mathbf{x}=\mathbf{b}\) has a coefficient matrix \(A\) with all real eigenvalues then the optimum relaxation parameter for the SOR method can be calculated using
\begin{equation}\label{equation:7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-equation}
\begin{split}\omega_{opt} = 1+{\left(\frac{\rho (T_J )}{1+\sqrt{1-\rho (T_J )^2 }}\right)}^2,\end{split}
\end{equation}
\sphinxAtStartPar
where \(\rho(T_J)\) is the spectral radius of the iteration matrix of the {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-iteration-matrix-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi method}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 7.4}

\sphinxAtStartPar
Determine the optimum relaxation parameter for the SOR method when applied to the system of linear equations from {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}} by calculating \(\rho(T_{SOR})\) for a range of \(\omega\) values and using equation \eqref{equation:7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-equation} (if possible).
\subsubsection*{Solution}

\sphinxAtStartPar
The coefficient matrix is
\begin{align*}
    A = \begin{pmatrix}
        4 & 3 & 0 \\ 
        3 & 4 & -1 \\
        0 & -1 & 4
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
The plot below shows the value of \(\rho(T_{SOR})\) for a range of \(\omega\) values. The minimum value of \(\rho(T_{SOR})\) corresponds to \(\omega = 1.2405\).
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{7.4_SOR_method_1_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\sphinxAtStartPar
The eigenvalues of \(A\) are
\begin{align*}
    0 &= \begin{vmatrix}
        4 - \lambda & 3 & 0 \\
        3 & 4 - \lambda & -1 \\
        0 & -1 & 4 - \lambda
    \end{vmatrix}
    = (4 - \lambda)(\lambda^2 - 7\lambda + 6), \\
    \therefore \lambda &= 4, 4 \pm \sqrt{10},
\end{align*}
\sphinxAtStartPar
so \(A\) has real eigenvalues. The iteration matrix for the Jacobi method applied to this system is
\begin{align*}
    T_J &= -D^{-1}(L + U)
    = - \begin{pmatrix}
        \frac{1}{4} & 0 & 0 \\ 
        0 & \frac{1}{4} & 0 \\
        0 & 0 & \frac{1}{4}
    \end{pmatrix}
    \begin{pmatrix}
        0 & 3 & 0 \\
        3 & 0 & -1 \\
        0 & -1 & 0 
    \end{pmatrix} \\
    &= \begin{pmatrix}
        0 & -\frac{3}{4} & 0 \\
        -\frac{3}{4} & 0 & \frac{1}{4} \\
        0 & \frac{1}{4} & 0
    \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Calculating \(\rho(T_J)\)
\begin{align*}
    0 &= \begin{vmatrix}
        -\lambda & -\frac{3}{4} & 0 \\
        -\frac{3}{4} & -\lambda & \frac{1}{4} \\
        0 & \frac{1}{4} & -\lambda
    \end{vmatrix} =
    -\lambda \left( \lambda^2 + \frac{5}{8} \right), \\
    \therefore \lambda &= 0, \pm \frac{\sqrt{10}}{4}
\end{align*}
\sphinxAtStartPar
so \(\rho(T_J) = \frac{\sqrt{10}}{4}\). Using equation \eqref{equation:7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-equation}
\begin{align*}
    \omega = 1 + \left( \frac{\frac{\sqrt{10}}{4}}{1 + \sqrt{1 - (\frac{\sqrt{10}}{4})^2}} \right)^2 = \frac{4}{5}(4 - \sqrt{6}) \approx 1.2404.
\end{align*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Example 7.5}

\sphinxAtStartPar
Use the SOR method with \(\omega = 1.24\) to solve the system of linear equations from {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{example 7.1}}}}
\begin{align*}
    4x_1 +3x_2 &=-2,\\
    3x_1 +4x_2 -x_3 &=-8,\\
    -x_2 +4x_3 &=14.
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
The SOR method for this system is
\begin{align*}
    x_{1}^{(k+1)} &= (1 - \omega)x_{1}^{(k)} + \frac{\omega}{4} \left( -2 - 3 x_{2}^{(k)} \right), \\
    x_{2}^{(k+1)} &= (1 - \omega)x_{2}^{(k)} + \frac{\omega}{4} \left( -8 - 3 x_{1}^{(k+1)} + x_{3}^{(k)} \right), \\
    x_{3}^{(k+1)} &= (1 - \omega)x_{3}^{(k)} + \frac{\omega}{4} \left( 14 + x_{2}^{(k+1)} \right).
\end{align*}
\sphinxAtStartPar
Using starting values of \(\mathbf{x} = \mathbf{0}\). Calculating the first iteration
\begin{align*}
    x_{1}^{(1)} &= (1 - 1.24)(-0.5) \frac{1.24}{4} \left( -2 - 3 (-1.625) \right) = -0.5, \\
    x_{2}^{(1)} &= (1 - 1.24)(-1.625) \frac{1.24}{4} \left( -8 - 3 (-0.5) + -3.09375 \right) = -1.625, \\
    x_{3}^{(1)} &= (1 - 1.24)(3.09375) \frac{1.24}{4} \left( 14 + 1.625 \right) = 3.09375.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(1)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} -2 \\ -8 \\ 14 \end{pmatrix} -
    \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}
    \begin{pmatrix} -0.5 \\ -1.625 \\ 3.09375 \end{pmatrix} \\
    &=
    \begin{pmatrix} 4.875 \\ 3.09375 \\ 0.0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(1)} |) = 4.875 > 10^{-4}\) we continue iterating. Calculating the second iteration
\begin{align*}
    x_{1}^{(2)} &= (1 - 1.24)(0.71875) \frac{1.24}{4} \left( -2 - 3 (-1.765625) \right) = 0.71875, \\
    x_{2}^{(2)} &= (1 - 1.24)(-1.765625) \frac{1.24}{4} \left( -8 - 3 (0.71875) + -3.05859375 \right) \\
    &= -1.765625, \\
    x_{3}^{(2)} &= (1 - 1.24)(3.05859375) \frac{1.24}{4} \left( 14 + 1.765625 \right) = 3.05859375.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(2)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} -2 \\ -8 \\ 14 \end{pmatrix} -
    \begin{pmatrix} 4 & 3 & 0 \\ 3 & 4 & -1 \\ 0 & -1 & 4 \end{pmatrix}
    \begin{pmatrix} 0.71875 \\ -1.765625 \\ 3.05859375 \end{pmatrix} \\
    &=
    \begin{pmatrix} 0.421875 \\ -0.03515625 \\ 0.0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(2)} |) = 0.421875 > 10^{-4}\) we continue iterating. The SOR method was iterated until \(|\mathbf{r}| < 10^{-4}\) and the iteration values are given in the table below. Note that the SOR method took 9 iterations to achieve convergence to \(tol=10^{-4}\) whereas the {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi method}}}} took 49 iterations and the {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-example}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel method}}}} took 19 iterations to achieve the same accuracy.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(k\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{0}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{1}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(x_{2}\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(\max(\mathbf{r})\)
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
0.000000
&
\sphinxAtStartPar
14.000000
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxhyphen{}0.620000
&
\sphinxAtStartPar
\sphinxhyphen{}1.903400
&
\sphinxAtStartPar
3.749946
&
\sphinxAtStartPar
6.190200
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
1.298962
&
\sphinxAtStartPar
\sphinxhyphen{}2.068735
&
\sphinxAtStartPar
2.798705
&
\sphinxAtStartPar
0.989642
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0.992173
&
\sphinxAtStartPar
\sphinxhyphen{}2.038626
&
\sphinxAtStartPar
3.036337
&
\sphinxAtStartPar
0.214321
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
1.037801
&
\sphinxAtStartPar
\sphinxhyphen{}2.014620
&
\sphinxAtStartPar
2.986747
&
\sphinxAtStartPar
0.107343
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
1.004524
&
\sphinxAtStartPar
\sphinxhyphen{}2.004807
&
\sphinxAtStartPar
3.001690
&
\sphinxAtStartPar
0.011569
\\
\hline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
1.003385
&
\sphinxAtStartPar
\sphinxhyphen{}2.001470
&
\sphinxAtStartPar
2.999139
&
\sphinxAtStartPar
0.009129
\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
1.000555
&
\sphinxAtStartPar
\sphinxhyphen{}2.000430
&
\sphinxAtStartPar
3.000073
&
\sphinxAtStartPar
0.000929
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
1.000267
&
\sphinxAtStartPar
\sphinxhyphen{}2.000122
&
\sphinxAtStartPar
2.999944
&
\sphinxAtStartPar
0.000701
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
1.000050
&
\sphinxAtStartPar
\sphinxhyphen{}2.000034
&
\sphinxAtStartPar
3.000003
&
\sphinxAtStartPar
0.000096
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsection{Python code}
\label{\detokenize{7_Indirect_methods/7.4_SOR_method:python-code}}
\sphinxAtStartPar
The code below defines a function called \sphinxcode{\sphinxupquote{sor()}} which solves a linear system of equations of the for \(A \mathbf{x} = \mathbf{b}\) using the Gauss\sphinxhyphen{}Seidel method with a relaxation parameter \(\omega\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sor}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{omega}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{mysum} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{mysum} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{omega}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{omega} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{mysum}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Chapter summary}
\label{\detokenize{7_Indirect_methods/7.5_Indirect_methods_summary:chapter-summary}}\label{\detokenize{7_Indirect_methods/7.5_Indirect_methods_summary::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Indirect methods use an iterative approach to improve an estimate of the solution to a system of linear equations. The methods are iterated until the estimates have achieved the required accuracy.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi method}}}} is uses information from the previous iteration only to update the estimates.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel method}}}} uses values of estimates already calculated in a given iteration to update the estimates. This means that the Gauss\sphinxhyphen{}Seidel method will converge to a solution faster than the Jacobi method.

\item {} 
\sphinxAtStartPar
An indirect method will {\hyperref[\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods:convergence-of-indirect-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{converge}}}} to the exact solution if the value of the spectral radius (the largest absolute eigenvalue) of the iteration matrix for a linear system is less than 1.

\item {} 
\sphinxAtStartPar
The smaller the value of the spectral radius, the faster the method will converge to the exact solution.

\item {} 
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:sor-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SOR method}}}} uses a relaxation parameter to adjust how much estimates will change over a single iteration. The value of the relaxation parameter is chosen to minimise the spectral radius.

\end{itemize}

\sphinxstepscope


\section{Indirect methods exercises}
\label{\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:indirect-methods-exercises}}\label{\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises::doc}}
\begin{sphinxadmonition}{note}{Exercise 7.1}

\sphinxAtStartPar
Using a pen and calculator, calculate the first 2 iterations of the Jacobi method for solving the system of linear equations below. Use starting values of \(x_i^{(0)} = 0 \) and work to 4 decimal places.
\begin{align*}
    4x_1 +x_2 -x_3 +x_4 &=14,\\
    x_1 +4x_2 -x_3 -x_4 &=10,\\
    -x_1 -x_2 +5x_3 +x_4 &=-15,\\
    x_1 -x_2 +x_3 +3x_4 &=3.
\end{align*}\subsubsection*{Solution (click to show)}

\sphinxAtStartPar
The Jacobi method for this system is
\begin{align*}
    x_{1}^{(k+1)} &= \frac{1}{5} \left( 14 - x_{2}^{(k)} + x_{3}^{(k)} - x_{4}^{(k)} \right), \\
    x_{2}^{(k+1)} &= \frac{1}{4} \left( 10 - x_{1}^{(k)} + x_{3}^{(k)} + x_{4}^{(k)} \right), \\
    x_{3}^{(k+1)} &= \frac{1}{5} \left( -15 + x_{1}^{(k)} + x_{2}^{(k)} - x_{4}^{(k)} \right), \\
    x_{4}^{(k+1)} &= \frac{1}{3} \left( 3 - x_{1}^{(k)} + x_{2}^{(k)} - x_{3}^{(k)} \right).
\end{align*}
\sphinxAtStartPar
Using starting values of \(\mathbf{x} = \mathbf{0}\). Calculating the first iteration
\begin{align*}
    x_{1}^{(1)} &= \frac{1}{5} \left( 14 - 2.5 + 3.0 - 1.0 \right) = 2.8, \\
    x_{2}^{(1)} &= \frac{1}{4} \left( 10 - 2.8 + 3.0 + -1.0 \right) = 2.5, \\
    x_{3}^{(1)} &= \frac{1}{5} \left( -15 + -2.8 + -2.5 - 1.0 \right) = -3.0, \\
    x_{4}^{(1)} &= \frac{1}{3} \left( 3 - 2.8 + -2.5 - -3.0 \right) = 1.0.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(1)} = \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} 14 \\ 10 \\ -15 \\ 3 \end{pmatrix} -
    \begin{pmatrix} 5 & 1 & -1 & 1 \\ 1 & 4 & -1 & -1 \\ -1 & -1 & 5 & 1 \\ 1 & -1 & 1 & 3 \end{pmatrix}
    \begin{pmatrix} 2.8 \\ 2.5 \\ -3.0 \\ 1.0 \end{pmatrix} =
    \begin{pmatrix} -6.5 \\ -4.8 \\ 4.3 \\ 2.7 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(1)} |) = 6.5 > 10^{-4}\) we continue iterating. Calculating the second iteration
\begin{align*}
    x_{1}^{(2)} &= \frac{1}{5} \left( 14 - 1.3 + 2.14 - 1.9 \right) = 1.5, \\
    x_{2}^{(2)} &= \frac{1}{4} \left( 10 - 1.5 + 2.14 + -1.9 \right) = 1.3, \\
    x_{3}^{(2)} &= \frac{1}{5} \left( -15 + -1.5 + -1.3 - 1.9 \right) = -2.14, \\
    x_{4}^{(2)} &= \frac{1}{3} \left( 3 - 1.5 + -1.3 - -2.14 \right) = 1.9.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(2)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} 14 \\ 10 \\ -15 \\ 3 \end{pmatrix} -
    \begin{pmatrix} 5 & 1 & -1 & 1 \\ 1 & 4 & -1 & -1 \\ -1 & -1 & 5 & 1 \\ 1 & -1 & 1 & 3 \end{pmatrix}
    \begin{pmatrix} 1.5 \\ 1.3 \\ -2.14 \\ 1.9 \end{pmatrix} \\
    &=
    \begin{pmatrix} 1.16 \\ 3.06 \\ -3.4 \\ -0.76 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(2)} |) = 3.4 > 10^{-4}\) we continue iterating.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 7.2}

\sphinxAtStartPar
Repeat question 1 using the Gauss\sphinxhyphen{}Seidel method.
\subsubsection*{Solution}

\sphinxAtStartPar
The Gauss\sphinxhyphen{}Seidel method for this system is
\begin{align*}
    x_{1}^{(k+1)} &= \frac{1}{5} \left( 14 - x_{2}^{(k)} + x_{3}^{(k)} - x_{4}^{(k)} \right), \\
    x_{2}^{(k+1)} &= \frac{1}{4} \left( 10 - x_{1}^{(k+1)} + x_{3}^{(k)} + x_{4}^{(k)} \right), \\
    x_{3}^{(k+1)} &= \frac{1}{5} \left( -15 + x_{1}^{(k+1)} + x_{2}^{(k+1)} - x_{4}^{(k)} \right), \\
    x_{4}^{(k+1)} &= \frac{1}{3} \left( 3 - x_{1}^{(k+1)} + x_{2}^{(k+1)} - x_{3}^{(k+1)} \right).
\end{align*}
\sphinxAtStartPar
Using starting values of \(\mathbf{x} = \mathbf{0}\). Calculating the first iteration
\begin{align*}
    x_{1}^{(1)} &= \frac{1}{5} \left( 14 - 1.8 + 2.08 - 1.36 \right) = 2.8, \\
    x_{2}^{(1)} &= \frac{1}{4} \left( 10 - 2.8 + 2.08 + -1.36 \right) = 1.8, \\
    x_{3}^{(1)} &= \frac{1}{5} \left( -15 + -2.8 + -1.8 - 1.36 \right) = -2.08, \\
    x_{4}^{(1)} &= \frac{1}{3} \left( 3 - 2.8 + -1.8 - -2.08 \right) = 1.36.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(1)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} 14 \\ 10 \\ -15 \\ 3 \end{pmatrix} -
    \begin{pmatrix} 5 & 1 & -1 & 1 \\ 1 & 4 & -1 & -1 \\ -1 & -1 & 5 & 1 \\ 1 & -1 & 1 & 3 \end{pmatrix}
    \begin{pmatrix} 2.8 \\ 1.8 \\ -2.08 \\ 1.36 \end{pmatrix} \\
    &=
    \begin{pmatrix} -5.24 \\ -0.72 \\ -1.36 \\ 0.0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(1)} |) = 5.24 > 10^{-4}\) we continue iterating. Calculating the second iteration
\begin{align*}
    x_{1}^{(2)} &= \frac{1}{5} \left( 14 - 1.882 + 2.5452 - 1.89173 \right) = 1.752, \\
    x_{2}^{(2)} &= \frac{1}{4} \left( 10 - 1.752 + 2.5452 + -1.89173 \right) = 1.882, \\
    x_{3}^{(2)} &= \frac{1}{5} \left( -15 + -1.752 + -1.882 - 1.89173 \right) = -2.5452, \\
    x_{4}^{(2)} &= \frac{1}{3} \left( 3 - 1.752 + -1.882 - -2.5452 \right) = 1.89173.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(2)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} 14 \\ 10 \\ -15 \\ 3 \end{pmatrix} -
    \begin{pmatrix} 5 & 1 & -1 & 1 \\ 1 & 4 & -1 & -1 \\ -1 & -1 & 5 & 1 \\ 1 & -1 & 1 & 3 \end{pmatrix}
    \begin{pmatrix} 1.752 \\ 1.882 \\ -2.5452 \\ 1.89173 \end{pmatrix} \\
    &=
    \begin{pmatrix} -1.07893 \\ 0.06653 \\ -0.53173 \\ 0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(2)} |) = 1.07893 > 10^{-4}\) we continue iterating.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 7.3}

\sphinxAtStartPar
Repeat question 1 using the SOR method using the optimum value for the relaxation parameter.
\subsubsection*{Solution}

\sphinxAtStartPar
The iteration matrix for the Jacobi method for this system of linear equations is
\begin{align*}
    T_J &= -D^{-1} (L + U) \\
    &= 
    \begin{pmatrix} 5 & 0 & 0 & 0 \\ 0 & 4 & 0 & 0 \\ 0 & 0 & 5 & 0 \\ 0 & 0 & 0 & 3 \end{pmatrix}^1
    \left(
    \begin{pmatrix} 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ -1 & -1 & 0 & 0 \\ 1 & -1 & 1 & 0 \end{pmatrix} +
    \begin{pmatrix} 0 & 1 & -1 & 1 \\ 0 & 0 & -1 & -1 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 \end{pmatrix}
    \right) \\
    &= 
    \begin{pmatrix} \frac{1}{5} & 0 & 0 & 0 \\ 0 & \frac{1}{4} & 0 & 0 \\ 0 & 0 & \frac{1}{5} & 0 \\ 0 & 0 & 0 & \frac{1}{3} \end{pmatrix}
    \begin{pmatrix} 0 & 1 & -1 & 1 \\ 1 & 0 & -1 & -1 \\ -1 & -1 & 0 & 1 \\ 1 & -1 & 1 & 0 \end{pmatrix} 
    = 
    \begin{pmatrix}
        0 & - \frac{1}{5} & \frac{1}{5} & - \frac{1}{5} \\
        - \frac{1}{4} & 0 & \frac{1}{4} & \frac{1}{4} \\
        \frac{4}{15} & \frac{2}{15} & \frac{1}{15} & - \frac{1}{5} \\
        - \frac{1}{3} & \frac{1}{3} & - \frac{1}{3} & 0
    \end{pmatrix}
\end{align*}
\sphinxAtStartPar
and the eigenvalues are \(\lambda_1 = -0.5347\), \(\lambda_2 = -0.249523\), \(\lambda_3 = 0.561913\) and \(\lambda_4 =  0.222310\) so \(\rho(T_J) = 0.561913\). Using equation \eqref{equation:7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-equation}
\begin{align*}
    \omega = 1 + \left( \frac{0.561913}{1 + \sqrt{1 - 0.561913^2}} \right)^2 = 1.0946.
\end{align*}
\sphinxAtStartPar
The SOR method for this system is
\begin{align*}
    x_{1}^{(k+1)} &= (1 - \omega)x_{1}^{(k)} + \frac{\omega}{5} \left( 14 - x_{2}^{(k)} + x_{3}^{(k)} - x_{4}^{(k)} \right), \\
    x_{2}^{(k+1)} &= (1 - \omega)x_{2}^{(k)} + \frac{\omega}{4} \left( 10 - x_{1}^{(k+1)} + x_{3}^{(k)} + x_{4}^{(k)} \right), \\
    x_{3}^{(k+1)} &= (1 - \omega)x_{3}^{(k)} + \frac{\omega}{5} \left( -15 + x_{1}^{(k+1)} + x_{2}^{(k+1)} - x_{4}^{(k)} \right), \\
    x_{4}^{(k+1)} &= (1 - \omega)x_{4}^{(k)} + \frac{\omega}{3} \left( 3 - x_{1}^{(k+1)} + x_{2}^{(k+1)} - x_{3}^{(k+1)} \right).
\end{align*}
\sphinxAtStartPar
Using starting values of \(\mathbf{x} = \mathbf{0}\). Calculating the first iteration
\begin{align*}
    x_{1}^{(1)} &= (1 - 1.0946)(2.8) - \frac{1.0946}{5} \left( 14 - 1.8 + 2.08 - 1.36 \right) = 2.8, \\
    x_{2}^{(1)} &= (1 - 1.0946)(1.8) - \frac{1.0946}{4} \left( 10 - 2.8 + 2.08 - 1.36 \right) = 1.8, \\
    x_{3}^{(1)} &= (1 - 1.0946)(-2.08) - \frac{1.0946}{5} \left( -15 - 2.8 - 1.8 - 1.36 \right) = -2.08, \\
    x_{4}^{(1)} &= (1 - 1.0946)(1.36) - \frac{1.0946}{3} \left( 3 - 2.8 - 1.8 - -2.08 \right) = 1.36.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(1)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} 14 \\ 10 \\ -15 \\ 3 \end{pmatrix} -
    \begin{pmatrix} 5 & 1 & -1 & 1 \\ 1 & 4 & -1 & -1 \\ -1 & -1 & 5 & 1 \\ 1 & -1 & 1 & 3 \end{pmatrix}
    \begin{pmatrix} 2.8 \\ 1.8 \\ -2.08 \\ 1.36 \end{pmatrix} \\
    &= \begin{pmatrix} -5.24 \\ -0.72 \\ -1.36 \\ 0\end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(1)} |) = 5.24 > 10^{-4}\) we continue iterating. Calculating the second iteration
\begin{align*}
    x_{1}^{(2)} &= (1 - 1.0946)(1.752) - \frac{1.0946}{5} \left( 14 - 1.882 + 2.5452 - 1.891733 \right) \\ 
    &= 1.752, \\
    x_{2}^{(2)} &= (1 - 1.0946)(1.882) - \frac{1.0946}{4} \left( 10 - 1.752 + 2.5452 - 1.891733 \right) \\
    &= 1.882, \\
    x_{3}^{(2)} &= (1 - 1.0946)(-2.5452) - \frac{1.0946}{5} \left( -15 - 1.752 - 1.882 - 1.891733 \right) \\
    &= -2.5452, \\
    x_{4}^{(2)} &= (1 - 1.0946)(1.891733) - \frac{1.0946}{3} \left( 3 - 1.752 - 1.882 - -2.5452 \right) \\
    &= 1.891733.
\end{align*}
\sphinxAtStartPar
Calculate the residual
\begin{align*}
    \mathbf{r}^{(2)} &= \mathbf{b} - A \mathbf{x}^{(1)} = 
    \begin{pmatrix} 14 \\ 10 \\ -15 \\ 3 \end{pmatrix} -
    \begin{pmatrix} 5 & 1 & -1 & 1 \\ 1 & 4 & -1 & -1 \\ -1 & -1 & 5 & 1 \\ 1 & -1 & 1 & 3 \end{pmatrix}
    \begin{pmatrix} 1.752 \\ 1.882 \\ -2.5452 \\ 1.891733 \end{pmatrix} \\
    &= \begin{pmatrix} -1.078933 \\ 0.066533 \\ -0.531733 \\ -0\end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Since \(\max(| \mathbf{r}^{(2)} |) = 1.078933 > 10^{-4}\) we continue iterating.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 7.4}

\sphinxAtStartPar
Which method would you expect to converge to the solution with the fewest iterations? What quantitative evidence do you have to support your conclusion?
\subsubsection*{Solution}

\sphinxAtStartPar
The iteration matrices for the Jacobi, Gauss\sphinxhyphen{}Seidel and SOR methods (with \(\omega = 1.094573\)) are
\begin{align*}
    T_J &= \begin{pmatrix} 0 & -\frac{1}{5} & \frac{1}{5} & -\frac{1}{5} \\ -\frac{1}{4} & 0 & \frac{1}{4} & \frac{1}{4} \\ \frac{1}{5} & \frac{1}{5} & 0 & -\frac{1}{5} \\ -\frac{1}{3} & \frac{1}{3} & -\frac{1}{3} & 0 \end{pmatrix}, \\
    T_{GS} &= \begin{pmatrix} 0 & -\frac{1}{5} & \frac{1}{5} & -\frac{1}{5} \\ 0 & \frac{1}{20} & \frac{1}{5} & \frac{3}{10} \\ 0 & -\frac{3}{100} & \frac{8}{100} & -\frac{9}{50} \\ 0 & \frac{7}{75} & -\frac{2}{75} & \frac{17}{75} \end{pmatrix}, \\
    T_{SOR} &= \begin{pmatrix} -0.094573 & -0.218915 & 0.218915 & -0.218915 \\ 0.025879 & -0.034668 & 0.213739 & 0.333548 \\ -0.015038 & -0.055513 & 0.000141 & -0.193820 \\ 0.049435 & 0.087478 & -0.001940 & 0.177714 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
and the spectral radii for these matrices are
\begin{align*}
    \rho(T_J) &= 0.561913, \\
    \rho(T_{GS}) &= 0.296149, \\
    \rho(T_{SOR}) &= 0.171610,
\end{align*}
\sphinxAtStartPar
so we would expect the SOR method to convergence the fastest. This is supported by the results in {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-1}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 7.1}}}}, {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-2}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 7.2}}}} and {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-3}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 7.3}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 7.5}

\sphinxAtStartPar
Write a Python program to calculate the solution to {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-1}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 7.1}}}}, {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-2}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 7.2}}}} and {\hyperref[\detokenize{7_Indirect_methods/7.6_Indirect_methods_exercises:ex7-2}]{\sphinxcrossref{\DUrole{std,std-ref}{exercise 7.3}}}} using a convergence tolerance of \(tol=10^{-6}\). How many iterations did each of the three methods take to converge to the solution?
\subsubsection*{Solution}

\sphinxAtStartPar
Code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{jacobi}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{xo} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{xo}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{k}


\PYG{k}{def} \PYG{n+nf}{gauss\PYGZus{}seidel}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{k}


\PYG{k}{def} \PYG{n+nf}{sor}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{omega}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{omega}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{omega} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{s}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{k}


\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{iterations} \PYG{o}{=} \PYG{n}{jacobi}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Jacobi method:       }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{:}\PYG{l+s+s2}{3d}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{iterations} \PYG{o}{=} \PYG{n}{gauss\PYGZus{}seidel}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gauss\PYGZhy{}Seidel method: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{:}\PYG{l+s+s2}{3d}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{iterations} \PYG{o}{=} \PYG{n}{sor}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{l+m+mf}{1.094573}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SOR method:          }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{:}\PYG{l+s+s2}{3d}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Solution:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{    x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Jacobi} \PYG{n}{method}\PYG{p}{:}        \PYG{l+m+mi}{26} \PYG{n}{iterations}
\PYG{n}{Gauss}\PYG{o}{\PYGZhy{}}\PYG{n}{Seidel} \PYG{n}{method}\PYG{p}{:}  \PYG{l+m+mi}{13} \PYG{n}{iterations}
\PYG{n}{SOR} \PYG{n}{method}\PYG{p}{:}            \PYG{l+m+mi}{9} \PYG{n}{iterations}

\PYG{n}{Solution}\PYG{p}{:}
    \PYG{n}{x1} \PYG{o}{=}  \PYG{l+m+mf}{1.438776}
    \PYG{n}{x2} \PYG{o}{=}  \PYG{l+m+mf}{1.979592}
    \PYG{n}{x3} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.734694}
    \PYG{n}{x4} \PYG{o}{=}  \PYG{l+m+mf}{2.091837}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 7.6}

\sphinxAtStartPar
A linear system has the following coefficient matrix. What is the largest value that \(\alpha\) can be in order for the Jacobi method to be convergent?
\begin{align*}
    A = \begin{pmatrix}
        2 & 1 \\
        \alpha  & 2
    \end{pmatrix}
\end{align*}\subsubsection*{Solution}

\sphinxAtStartPar
The iteration matrix for the Jacobi method use to solve this system of linear equations is
\begin{align*}
    T &= -D^{-1}(L + U) 
    = - \begin{pmatrix} 2 & 0 \\ 0 & 2 \end{pmatrix}^{-1}
    \begin{pmatrix} 0 & 1 \\ \alpha & 2 \end{pmatrix} \\
    &= -\begin{pmatrix} \frac{1}{2} & 0 \\ 0 & \frac{1}{2} \end{pmatrix}
    \begin{pmatrix} 0 & 1 \\ \alpha & 2 \end{pmatrix}
    = \begin{pmatrix} 0 & -\frac{1}{2} \\ -\frac{1}{2} \alpha & 0 \end{pmatrix}.
\end{align*}
\sphinxAtStartPar
Calculate the eigenvalues of \(T_J\)
\begin{align*}
    0 &= \begin{vmatrix} -\lambda & -\frac{1}{2} \\ -\frac{1}{2} \alpha & -\lambda \end{vmatrix}
    = \lambda^2 - \frac{1}{4} \alpha, \\
    \therefore \lambda &= \frac{1}{2} \sqrt{\alpha}
\end{align*}
\sphinxAtStartPar
For a method to converge \(\rho(T) < 1\) so \(\frac{1}{2} \sqrt{\alpha} < 1\) therefore \(\alpha < 4\).
\end{sphinxadmonition}

\sphinxstepscope


\part{Appendices}

\sphinxstepscope


\chapter{Cheat Sheet}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:cheat-sheet}}\label{\detokenize{8_Appendices/8.0_Cheat_sheet::doc}}

\section{Initial value problems}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:initial-value-problems}}\begin{description}
\item[{Ordinary Differential Equation (ODE)\index{Ordinary Differential Equation (ODE)@\spxentry{Ordinary Differential Equation}\spxextra{ODE}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Ordinary-Differential-Equation-ODE}}}] \leavevmode
\sphinxAtStartPar
An {\hyperref[\detokenize{1_IVPs/1.0_IVPs:ode-section}]{\sphinxcrossref{\DUrole{std,std-ref}{ODE}}}} is an equation of the for
\begin{equation*}
\begin{split}y^{(n)} = f(t, y, y', y'', \ldots, y^{(n-1)}),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(y(t)\) is a function of the independent variable \(t\).

\item[{Initial Value Problem (IVP)    \index{Initial Value Problem (IVP)@\spxentry{Initial Value Problem}\spxextra{IVP}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Initial-Value-Problem-IVP}}}] \leavevmode
\sphinxAtStartPar
An {\hyperref[\detokenize{1_IVPs/1.0_IVPs:ivp-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{initial value problem}}}} is an ODE where the solution at some initial state is known
\begin{equation*}
\begin{split}y' = f(t, y), \qquad t \in [a, b], \qquad y(a) = \alpha.\end{split}
\end{equation*}
\item[{The Taylor series\index{The Taylor series@\spxentry{The Taylor series}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-Taylor-series}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Taylor series}}}} is a series expansion of a function \(f(t)\)
\begin{equation*}
\begin{split}f(t + h) = \sum_{n=0}^\infty \frac{h^n}{n!}f^{(n)}(t).\end{split}
\end{equation*}
\item[{Truncating the Taylor series\index{Truncating the Taylor series@\spxentry{Truncating the Taylor series}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Truncating-the-Taylor-series}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{1_IVPs/1.1_Taylor_Series:taylor-series-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Truncating the Taylor series}}}} is where all terms after the \(n\)th derivative in the Taylor series are omitted.
\begin{equation*}
\begin{split}f(t + h) \approx f(t) + hf'(t) + \frac{h^2}{2!} f''(t) + \cdots + \frac{h^n}{n!} f^{(n)}(t).\end{split}
\end{equation*}
\item[{The Euler method\index{The Euler method@\spxentry{The Euler method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-Euler-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.2_Euler_Method:euler-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Euler method}}}} is a first\sphinxhyphen{}order accurate numerical method for solving an initial value problem of the form \(y' = f(t, y)\), \(t\in [a, b]\), \(t_0 = \alpha\)
\begin{equation*}
\begin{split}y_{n+1} = y_n + h f(t_n, y_n),\end{split}
\end{equation*}
\sphinxAtStartPar
\(t_n\) is a value of \(t\) at step \(n\), \(y_n = y(t_n)\) and \(h = t_{n+1} - t_n\) is the step length.

\item[{Local Truncation Error (LTE)\index{Local Truncation Error (LTE)@\spxentry{Local Truncation Error}\spxextra{LTE}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Local-Truncation-Error-LTE}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:local-truncation-error-section}]{\sphinxcrossref{\DUrole{std,std-ref}{local truncation error}}}} is the error in the calculation of a single step of a numerical method assuming that the previous values are exact.

\item[{Global Truncation Error (GTE)\index{Global Truncation Error (GTE)@\spxentry{Global Truncation Error}\spxextra{GTE}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Global-Truncation-Error-GTE}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:global-truncation-error-section}]{\sphinxcrossref{\DUrole{std,std-ref}{global truncation error}}}} is the error that has accumulated over all previous steps of a numerical method assuming the initial solution was known to be exact.

\item[{Big\sphinxhyphen{}O notation\index{Big\sphinxhyphen{}O notation@\spxentry{Big\sphinxhyphen{}O notation}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Big-O-notation}}}] \leavevmode
\sphinxAtStartPar
\(f(h) = O(h^n)\) means that as \(h \to 0\) then \(f(h) \to 0\) at least as fast as \(h^n \to 0\).

\item[{Order of a method\index{Order of a method@\spxentry{Order of a method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Order-of-a-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{1_IVPs/1.3_Error_Analysis:global-truncation-error-section}]{\sphinxcrossref{\DUrole{std,std-ref}{order}}}} of a method is the degree of \(O(h^n)\) for the global truncation error of the method.

\item[{Reducing higher order ODE to first\sphinxhyphen{}order ODEs\index{Reducing higher order ODE to first\sphinxhyphen{}order ODEs@\spxentry{Reducing higher order ODE to first\sphinxhyphen{}order ODEs}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Reducing-higher-order-ODE-to-first-order-ODEs}}}] \leavevmode
\sphinxAtStartPar
An \(n\)th order ODE \(y^{(n)} = f(t, y, y', y'', \ldots, y^{(n-1)}\) can be written as a system of \(n\) first order ODES such that
\begin{align*}
    y_1' &= y_2, \\
    y_2' &= y_3, \\
    & \vdots \\
    y_n' &= f(t, y_1, y_2, \ldots, y_n).
\end{align*}
\end{description}


\bigskip\hrule\bigskip



\section{Explicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:explicit-runge-kutta-methods}}\begin{description}
\item[{General form of a Runge\sphinxhyphen{}Kutta method\index{General form of a Runge\sphinxhyphen{}Kutta method@\spxentry{General form of a Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-General-form-of-a-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{2_ERKs/2.0_ERKs:general-form-of-a-rk-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{general form of a Runge\sphinxhyphen{}Kutta method}}}} is
\begin{align*}
    y_{n+1} &= y_n + h\sum_{i=1}^s b_i k_i, \\
    k_i &= f(t_n + c_ih, y_n + h \sum_{j=1}^s a_{ij} k_i,
\end{align*}
\sphinxAtStartPar
where \(k_i\) are intermediate stage valeus.

\item[{Butcher tableau\index{Butcher tableau@\spxentry{Butcher tableau}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Butcher-tableau}}}] \leavevmode
\sphinxAtStartPar
Runge\sphinxhyphen{}Kutta methods can be represented using a {\hyperref[\detokenize{2_ERKs/2.0_ERKs:butcher-tableau-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher tableau}}}} such that
\begin{align*}
    \begin{array}{c|c}
        \mathbf{c} & A \\ \hline
        & \mathbf{b}^\mathrm{T}
    \end{array}
\end{align*}
\sphinxAtStartPar
where \([A]_{ij} = a_{ij}\), \(\mathbf{b} = (b_1, \ldots, b_s)^\mathrm{T}\) and \(\mathbf{c} = (c_1, \ldots, c_s)^\mathrm{T}\).

\item[{Explicit Runge\sphinxhyphen{}Kutta method\index{Explicit Runge\sphinxhyphen{}Kutta method@\spxentry{Explicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Explicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
An {\hyperref[\detokenize{2_ERKs/2.0_ERKs:explicit-and-implicit-rk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{explicit Runge\sphinxhyphen{}Kutta method}}}} is a method where \(c_1 = 0\), \(a_{ij} = 0\) where \(i \leq j\) such that the stage values are explicit functions.

\item[{Order conditions of a Runge\sphinxhyphen{}Kutta method\index{Order conditions of a Runge\sphinxhyphen{}Kutta method@\spxentry{Order conditions of a Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Order-conditions-of-a-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
Comparing the \(n\)th order Taylor series expansion of \(y' = f(t, y)\) to that of the general form of a Runge\sphinxhyphen{}Kutta method gives the {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-section}]{\sphinxcrossref{\DUrole{std,std-ref}{order conditions}}}} which need to be satisfied for an \(n\)th order Runge\sphinxhyphen{}Kutta method.

\item[{The row sum condition\index{The row sum condition@\spxentry{The row sum condition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-row-sum-condition}}}] \leavevmode
\sphinxAtStartPar
The values of \(a_{ij}\) and \(c_i\) must satisfy the {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:row-sum-condition}]{\sphinxcrossref{\DUrole{std,std-ref}{row sum condition}}}} which is \(c_i = \displaystyle_{j=1}^s a_{ij}\).

\item[{The second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method (RK2)\index{The second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method (RK2)@\spxentry{The second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}\spxextra{RK2}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-second-order-explicit-Runge-Kutta-method-RK2}}}] \leavevmode
\sphinxAtStartPar
\sphinxstyleemphasis{The} {\hyperref[\detokenize{2_ERKs/2.1_ERK_Derivation:rk2-derivation-example}]{\sphinxcrossref{\DUrole{std,std-ref}{second\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}}}} has the Butcher tableau
\begin{align*}
    \begin{array}{c|cc}
        0 & 0 \\ 
        1 & 1 \\ \hline
        & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}
\item[{The fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method (RK4)\index{The fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method (RK4)@\spxentry{The fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}\spxextra{RK4}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-fourth-order-explicit-Runge-Kutta-method-RK4}}}] \leavevmode
\sphinxAtStartPar
\sphinxstyleemphasis{The} {\hyperref[\detokenize{2_ERKs/2.2_RK4_Derivation:rk4-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{fourth\sphinxhyphen{}order explicit Runge\sphinxhyphen{}Kutta method}}}} has the Butcher tableau
\begin{align*}
    \begin{array}{c|cccc}
        0 & 0 \\
        \frac{1}{2} & \frac{1}{2} \\
        \frac{1}{2} & 0 & \frac{1}{2} \\ 
        1 & 0 & 0 & 1 \\ \hline
        & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
    \end{array}
\end{align*}
\end{description}


\bigskip\hrule\bigskip



\section{Implicit Runge\sphinxhyphen{}Kutta methods}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:implicit-runge-kutta-methods}}\begin{description}
\item[{Implicit Runge\sphinxhyphen{}Kutta methods (IRK)\index{Implicit Runge\sphinxhyphen{}Kutta methods (IRK)@\spxentry{Implicit Runge\sphinxhyphen{}Kutta methods}\spxextra{IRK}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Implicit-Runge-Kutta-methods-IRK}}}] \leavevmode
\sphinxAtStartPar
An {\hyperref[\detokenize{3_IRKs/3.0_IRKs:irk-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{implicit Runge\sphinxhyphen{}Kutta method}}}} is where the stage values are implicit functions.

\item[{Order of an implicit Runge\sphinxhyphen{}Kutta method\index{Order of an implicit Runge\sphinxhyphen{}Kutta method@\spxentry{Order of an implicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Order-of-an-implicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
Implicit Runge\sphinxhyphen{}Kutta methods can have a higher order of accuracy for the same number of stages as an explicit Runge\sphinxhyphen{}Kutta method. The {\hyperref[\detokenize{3_IRKs/3.0_IRKs:order-of-irk-section}]{\sphinxcrossref{\DUrole{std,std-ref}{order of an implicit Runge\sphinxhyphen{}Kutta methods}}}} is the highest value of \(k\) for which the order conditions \(B(k)\), \(C(\lfloor \frac{k}{2} \rfloor)\) and \(D(\lfloor \frac{k}{2} \rfloor)\) are satisfied where
\begin{align*}
    B(k): && \sum_{i=1}^s b_i c_i^{j-1} = & \frac{1}{j}, & j&=1\ldots k, \\
    C(k): && \sum_{j=1}^s a_{ij} c_j^{\ell-1} = & \frac{1}{\ell}c_i^{\ell} , & i&=1 \ldots s, & \ell &=1 \ldots k,\\
    D(k): && \sum_{i=1}^s b_i c_i^{\ell-1} a_{ij} = & \frac{1}{\ell}b_j (1-c_j^{\ell}), & j&=1 \ldots s, & \ell &=1 \ldots k.
\end{align*}
\item[{Gauss\sphinxhyphen{}Legendre implicit Runge\sphinxhyphen{}Kutta methods\index{Gauss\sphinxhyphen{}Legendre implicit Runge\sphinxhyphen{}Kutta methods@\spxentry{Gauss\sphinxhyphen{}Legendre implicit Runge\sphinxhyphen{}Kutta methods}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Gauss-Legendre-implicit-Runge-Kutta-methods}}}] \leavevmode
\sphinxAtStartPar
An \(s\)\sphinxhyphen{}stage {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:gauss-legendre-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Legendre}}}} implicit Runge\sphinxhyphen{}Kutta method has order \(k = 2s\) and are derived by setting \(c_i\) to be the roots of the Legendre polynomial
\begin{equation*}
\begin{split}P_n(t) = \displaystyle\sum_{k=0}^n \binom{n}{k} \binom{n+k}{k} (t - 1)^k,\end{split}
\end{equation*}
\sphinxAtStartPar
and \(b_i\) and \(a_{ij}\) are chosen to satisfy the \(B(k)\) and \(C(\lfloor \frac{k}{2} \rfloor)\) order conditions. For

\item[{Radau IA implicit Runge\sphinxhyphen{}Kutta method\index{Radau IA implicit Runge\sphinxhyphen{}Kutta method@\spxentry{Radau IA implicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Radau-IA-implicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
An \(s\)\sphinxhyphen{}stage {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:radau-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{Radau IA}}}} implicit Runge\sphinxhyphen{}Kutta method has order \(k = 2s - 1\) and are derived by setting \(c_i\) to be the roots of \(P_s(t) + P_{s-1}(t)\) and the values of \(b_i\) and \(a_{ij}\) are chosen to satisfy the order condition \(D(k)\).

\item[{Radau IIA implicit Runge\sphinxhyphen{}Kutta method \index{Radau IIA implicit Runge\sphinxhyphen{}Kutta method@\spxentry{Radau IIA implicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Radau-IIA-implicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
An \(s\)\sphinxhyphen{}stage {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:radau-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{Radau IIA}}}} implicit Runge\sphinxhyphen{}Kutta method has order \(k = 2s - 1\)  are derived by setting \(c_i\) to be the roots of \(P_s(t) - P_{s-1}(t)\) and the values of \(b_i\) and \(a_{ij}\) are chosen to satisfy the order condition \(C(k)\).

\item[{Diagonally Implicit Runge\sphinxhyphen{}Kutta (DIRK) methods\index{Diagonally Implicit Runge\sphinxhyphen{}Kutta (DIRK) methods@\spxentry{Diagonally Implicit Runge\sphinxhyphen{}Kutta (DIRK) methods}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Diagonally-Implicit-Runge-Kutta-DIRK-methods}}}] \leavevmode
\sphinxAtStartPar
An {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:dirk-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{DIRK}}}} method is an implicit Runge\sphinxhyphen{}Kutta method where \(a_{ij} = 0\) where \(i < j\) and is derived by satisfying the \(B(k)\) and \(C(\lfloor \frac{k}{2} \rfloor)\) and
\begin{equation*}
\begin{split}\mathbf{b}^T A \mathbf{c} = \frac{1}{k!}.\end{split}
\end{equation*}
\sphinxAtStartPar
The stage values of a DIRK method can be calculated sequentially.

\item[{Singly Diagonally Implicit Runge\sphinxhyphen{}Kutta (SDIRK) methods\index{Singly Diagonally Implicit Runge\sphinxhyphen{}Kutta (SDIRK) methods@\spxentry{Singly Diagonally Implicit Runge\sphinxhyphen{}Kutta (SDIRK) methods}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Singly-Diagonally-Implicit-Runge-Kutta-SDIRK-methods}}}] \leavevmode
\sphinxAtStartPar
An {\hyperref[\detokenize{3_IRKs/3.1_Deriving_IRK_methods:sdirk-derivation}]{\sphinxcrossref{\DUrole{std,std-ref}{SDIRK}}}} method an implicit Runge\sphinxhyphen{}Kutta method where \(a_{ij} = 0\) where \(i < j\) and is derived by satisfying the \(B(k)\), \(C(\lfloor \frac{k}{2} \rfloor)\) and \(D(\lfloor \frac{k}{2} \rfloor)\) order conditions.

\item[{Computing the stage values of an implicit Runge\sphinxhyphen{}Kutta method\index{Computing the stage values of an implicit Runge\sphinxhyphen{}Kutta method@\spxentry{Computing the stage values of an implicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Computing-the-stage-values-of-an-implicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{3_IRKs/3.2_Solving_IVPs_using_IRK_methods:solving-ivps-using-irk-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Computing the stage values}}}} of an implicit Runge\sphinxhyphen{}Kutta method requires the solution to a system of nonlinear equations. This is typically done using Newtonâ€™s method but can also be done using the Gauss\sphinxhyphen{}Seidel method.

\end{description}


\bigskip\hrule\bigskip



\section{Stability}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:stability}}\begin{description}
\item[{Stability\index{Stability@\spxentry{Stability}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Stability}}}] \leavevmode
\sphinxAtStartPar
A method is {\hyperref[\detokenize{4_Stability/4.0_Stability:stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stable}}}} if the local truncation errors do not increase from one step to the next.

\item[{Stiffness\index{Stiffness@\spxentry{Stiffness}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Stiffness}}}] \leavevmode
\sphinxAtStartPar
An ODE is {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stiff}}}} if it requires a very small value of the step length \(h\) in order for a method to remain stable.

\item[{Stiffness ratio\index{Stiffness ratio@\spxentry{Stiffness ratio}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Stiffness-ratio}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.0_Stability:stiffness-ratio-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stiffness ratio}}}} gives a measure to whether an system of ODEs is stiff and is calculated using
\begin{align*}
    S = \frac{\max_i(|\lambda_i|)}{\min_i(|\lambda_i|)}.
\end{align*}
\sphinxAtStartPar
If \(S\) is large then the system is considered stiff.

\item[{Test ODE\index{Test ODE@\spxentry{Test ODE}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Test-ODE}}}] \leavevmode
\sphinxAtStartPar
The stability of numerical methods for solving ODEs can be analysed by considering the simple {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:stability-functions-section}]{\sphinxcrossref{\DUrole{std,std-ref}{test ODE}}}} \(y' = \lambda \lambda y\).

\item[{Stability function\index{Stability function@\spxentry{Stability function}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Stability-function}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:stability-function-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{stability function}}}} \(R(z)\) for a method is the change of the solution over a single step of the method when used to solve the test ODE
\begin{equation*}
\begin{split}y_{n+1} = R(z) y_n.\end{split}
\end{equation*}
\item[{Absolute stability\index{Absolute stability@\spxentry{Absolute stability}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Absolute-stability}}}] \leavevmode
\sphinxAtStartPar
A method is considered {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:absolute-stability-section}]{\sphinxcrossref{\DUrole{std,std-ref}{absolutely stable}}}} if \(|R(z)| \leq 1\) for \(z \in \mathbb{C}\).

\item[{Region of absolute stability\index{Region of absolute stability@\spxentry{Region of absolute stability}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Region-of-absolute-stability}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:region-of-absolute-stability-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{region of absolute stability}}}} is the set of values of \(z\) for which the method is absolutely stable.

\item[{Interval of absolute stability\index{Interval of absolute stability@\spxentry{Interval of absolute stability}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Interval-of-absolute-stability}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.1_Stability_functions:interval-of-absolute-stability-section}]{\sphinxcrossref{\DUrole{std,std-ref}{interval of absolute stability}}}} is the range of values of \(h\) for which a method is absolutely stable.

\item[{Stability function of an explicit Runge\sphinxhyphen{}Kutta method\index{Stability function of an explicit Runge\sphinxhyphen{}Kutta method@\spxentry{Stability function of an explicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Stability-function-of-an-explicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.2_RK_stability_function:erk-rz-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stability function of an explicit Runge\sphinxhyphen{}Kutta method}}}} can be determined using
\begin{align*}
    R(z)=1+\sum_{k=0}^{\infty} \mathbf{b}^T A^k \mathbf{e}\,z^{k+1} =1+\mathbf{b}^T \mathbf{e}\,z+\mathbf{b}^T A\mathbf{e}\,z^2 +\mathbf{b}^T A^2 \mathbf{e}\,z^3 + \cdots
\end{align*}
\item[{Order of an explicit Runge\sphinxhyphen{}Kutta method\index{Order of an explicit Runge\sphinxhyphen{}Kutta method@\spxentry{Order of an explicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Order-of-an-explicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
The order of an explicit Runge\sphinxhyphen{}Kutta method is the order of the highest term in the stability function for that method that agrees with the series expansion of \(e^z\)
\begin{align*}
    e^z = \sum_{k=0}^{\infty} \frac{1}{k!} z^k = 1 + z + \frac{1}{2!}z^2 + \frac{1}{3!}z^3 + \frac{1}{4!}z^4 + \cdots
\end{align*}
\item[{Stability function of an implicit Runge\sphinxhyphen{}Kutta method\index{Stability function of an implicit Runge\sphinxhyphen{}Kutta method@\spxentry{Stability function of an implicit Runge\sphinxhyphen{}Kutta method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Stability-function-of-an-implicit-Runge-Kutta-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:implicit-rz-section}]{\sphinxcrossref{\DUrole{std,std-ref}{stability function of an implicit Runge\sphinxhyphen{}Kutta method}}}} can be determined using
\begin{align*}
    R(z) = \frac{\det (I - zA + z\mathbf{e}\mathbf{b}^T)}{\det(I - zA)}.
\end{align*}
\item[{A\sphinxhyphen{}stability\index{A\sphinxhyphen{}stability@\spxentry{A\sphinxhyphen{}stability}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-A-stability}}}] \leavevmode
\sphinxAtStartPar
An implicit method is considered {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability}]{\sphinxcrossref{\DUrole{std,std-ref}{A\sphinxhyphen{}stable}}}} if its region of absolute stability includes all points on the left\sphinxhyphen{}hand side of the complex plane.

\item[{Conditions for A\sphinxhyphen{}stability\index{Conditions for A\sphinxhyphen{}stability@\spxentry{Conditions for A\sphinxhyphen{}stability}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Conditions-for-A-stability}}}] \leavevmode
\sphinxAtStartPar
For a method to be A\sphinxhyphen{}stable it must satisfied the following {\hyperref[\detokenize{4_Stability/4.3_IRK_stability_function:a-stability-theorem}]{\sphinxcrossref{\DUrole{std,std-ref}{conditions}}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
All roots of the denominator of \(R(z)\) have positive real parts

\item {} 
\sphinxAtStartPar
\(E(y)=Q(iy)Q(-iy)-P(iy)P(-iy) \geq 0\) for all \(y\in \mathbb{R}\)

\end{itemize}

\end{description}


\bigskip\hrule\bigskip



\section{Boundary Value Problems}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:boundary-value-problems}}\begin{description}
\item[{Two point Boundary Value Problem (BVP)\index{Two point Boundary Value Problem (BVP)@\spxentry{Two point Boundary Value Problem}\spxextra{BVP}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Two-point-Boundary-Value-Problem-BVP}}}] \leavevmode
\sphinxAtStartPar
A {\hyperref[\detokenize{5_BVPs/5.0_BVPs:bvp-section}]{\sphinxcrossref{\DUrole{std,std-ref}{two point boundary value problem}}}} is an ODE where the solutions at the lower and upper boundaries of the domain are known
\begin{equation*}
\begin{split}y'' = f(t, y), \qquad t \in [a, b], \qquad y(a) = \alpha, \qquad y(b) = \beta.\end{split}
\end{equation*}
\item[{Uniqueness of solutions to a BVP\index{Uniqueness of solutions to a BVP@\spxentry{Uniqueness of solutions to a BVP}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Uniqueness-of-solutions-to-a-BVP}}}] \leavevmode
\sphinxAtStartPar
A BVP may have a {\hyperref[\detokenize{5_BVPs/5.0_BVPs:existence-and-uniqueness-of-bvp-solutions-section}]{\sphinxcrossref{\DUrole{std,std-ref}{unique solution, infinitely many solutions or no solutions}}}}. A BVP of the form \(y'' = p(t) y' + q(t) y + r(t)\) has a unique solution if the following conditions are satisfied
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p(t)\), \(q(t)\) and \(r(t)\) are continuous on \([a, b]\);

\item {} 
\sphinxAtStartPar
\(q(t) > 0\) for all \(t\in [a,b]\).

\end{itemize}

\item[{The shooting method\index{The shooting method@\spxentry{The shooting method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-shooting-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:shooting-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{shooting method}}}} for solving a BVP uses estimates of the initial value of \(y'(a)\) and compares the numerical solution for \(y(b)\) to the known solution \(y(b)=\beta\) and changes the estimates accordingly.

\item[{The secant method\index{The secant method@\spxentry{The secant method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-secant-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.1_Shooting_method:secant-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{secant method}}}} is a root finding method that can be used to calculate improved estimates in the shooting method. If \(s_{i}\) and \(s_{i-1}\) are current and previous guess values of \(y'(a)\) then an improved guess value is
\begin{align*}
    s_{i+1} = s_i - g(s_i)\frac{s_i - s_{i-1}}{g(s_i) - g(s_{i-1})}.
\end{align*}
\sphinxAtStartPar
where \(g(s) = y'(a) - y_n\) and \(y_n\) is the numerical solution for \(y(b)\).

\item[{Finite\sphinxhyphen{}difference approximations\index{Finite\sphinxhyphen{}difference approximations@\spxentry{Finite\sphinxhyphen{}difference approximations}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Finite-difference-approximations}}}] \leavevmode
\sphinxAtStartPar
A {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference approximation}}}} is an approximation of a derivative derived from the Taylor series.

\item[{Finite\sphinxhyphen{}difference methods\index{Finite\sphinxhyphen{}difference methods@\spxentry{Finite\sphinxhyphen{}difference methods}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Finite-difference-methods}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:finite-difference-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{finite\sphinxhyphen{}difference method}}}} uses finite\sphinxhyphen{}difference approximations to approximate a BVP using a system of linear equations (usually tridiagonal).

\item[{The Thomas algorithm\index{The Thomas algorithm@\spxentry{The Thomas algorithm}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-Thomas-algorithm}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{5_BVPs/5.2_Finite_difference_method:thomas-algorithm-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Thomas algorithm}}}} is an efficient method for solving tridiagonal systems of linear equations.

\end{description}


\bigskip\hrule\bigskip



\section{Direct methods}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:direct-methods}}\begin{description}
\item[{System of linear equations\index{System of linear equations@\spxentry{System of linear equations}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-System-of-linear-equations}}}] \leavevmode
\sphinxAtStartPar
A {\hyperref[\detokenize{6_Direct_methods/6.0_Direct_methods:systems-of-linear-equations-section}]{\sphinxcrossref{\DUrole{std,std-ref}{system of linear equations}}}} is a set of linear equations of the form \(A \mathbf{x} = \mathbf{b}\) where the solution vector \(\mathbf{x}\) satisfies all equations in the system.

\item[{Direct methods\index{Direct methods@\spxentry{Direct methods}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Direct-methods}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.0_Direct_methods:direct-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{Direct methods}}}} solve a system of linear equations using a single application of the method.

\item[{LU decomposition\index{LU decomposition@\spxentry{LU decomposition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-LU-decomposition}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:lu-section}]{\sphinxcrossref{\DUrole{std,std-ref}{LU decomposition}}}} factorises a square matrix \(A\) into a lower and upper triangular matrix \(L\) and \(U\) such that \(A = LU\)
\begin{align*}
    u_{ij} &= a_{ij} - \sum_{k=1}^{i-1} \ell_{ik}u_{kj}, & i &= 1, \ldots, j, \\
    \ell_{ij} &= \dfrac{1}{u_{jj}} \left(a_{ij} - \displaystyle \sum_{k=1}^{j-1} \ell_{ik}u_{kj}\right), & i &= j+1, \ldots, n.
\end{align*}
\item[{Croutâ€™s method\index{Crout's method@\spxentry{Crout's method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Crout-s-method}}}] \leavevmode
\sphinxAtStartPar
The solution of a system of linear equations \(A \mathbf{x} = \mathbf{b}\) can be calculated using {\hyperref[\detokenize{6_Direct_methods/6.1_LU_decomposition:crouts-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Croutâ€™s method}}}} where \(L \mathbf{y} = \mathbf{b}\) is solved for \(\mathbf{y}\) by forward substitution and \(U \mathbf{x} = \mathbf{y}\) is solved for \(\mathbf{x}\) by back substitution.

\item[{Partial pivoting\index{Partial pivoting@\spxentry{Partial pivoting}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Partial-pivoting}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:partial-pivoting-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Partial pivoting}}}} uses row swaps to ensure that the pivot elements \(a_{jj}\) have a larger absolute value that the elements in the column beneath it.

\item[{Permutation matrix\index{Permutation matrix@\spxentry{Permutation matrix}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Permutation-matrix}}}] \leavevmode
\sphinxAtStartPar
The permutation matrix is calculated by performing the same row swaps as used in partial pivoting to the identity matrix.

\item[{LUP decomposition\index{LUP decomposition@\spxentry{LUP decomposition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-LUP-decomposition}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-decomposition-section}]{\sphinxcrossref{\DUrole{std,std-ref}{LUP decomposition}}}} factorises a square matrix \(A\) into a lower and upper triangular matrices \(L\) and \(U\) and the permutation matrix \(P\) such that \(PA = LU\).

\item[{Croutâ€™s method with LUP decomposition\index{Crout's method with LUP decomposition@\spxentry{Crout's method with LUP decomposition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Crout-s-method-with-LUP-decomposition}}}] \leavevmode
\sphinxAtStartPar
The solution of a system of linear equations \(A \mathbf{x} = \mathbf{b}\) can be calculated using {\hyperref[\detokenize{6_Direct_methods/6.2_LUP_decomposition:lup-decomposition-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Croutâ€™s method}}}} where \(L \mathbf{y} = P \mathbf{b}\) is solved for \(\mathbf{y}\) by forward substitution and \(U \mathbf{x} = \mathbf{y}\) is solved for \(\mathbf{x}\) by back substitution.

\item[{Positive definite matrix\index{Positive definite matrix@\spxentry{Positive definite matrix}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Positive-definite-matrix}}}] \leavevmode
\sphinxAtStartPar
A matrix is {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-section}]{\sphinxcrossref{\DUrole{std,std-ref}{positive definite}}}} if it is symmetric and the determinants of all upper left square matrices are all positive.

\item[{Cholesky decomposition\index{Cholesky decomposition@\spxentry{Cholesky decomposition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Cholesky-decomposition}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky decomposition}}}} factorises a positive definite matrix \(A\) into a lower triangular matrix \(L\) such that \(A = LL^\mathrm{T}\)
\begin{align*}
    \ell_{jj} &= \sqrt{a_{jj} - \sum_{k=1}^{j-1} \ell_{jk}^2 }, & j &= 1, \ldots, n,\\
    \ell_{ij} &= \dfrac{1}{\ell_{jj} }\left(a_{ij} -\displaystyle \sum_{k=1}^{i-1} \ell_{ik} \ell_{jk} \right), & i &= j + 1,\ldots ,n.
\end{align*}
\item[{The Cholesky\sphinxhyphen{}Crout method\index{The Cholesky\sphinxhyphen{}Crout method@\spxentry{The Cholesky\sphinxhyphen{}Crout method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-Cholesky-Crout-method}}}] \leavevmode
\sphinxAtStartPar
The solution of a system of linear equations \(A \mathbf{x} = \mathbf{b}\) where \(A\) is positive definite can be calculated using the {\hyperref[\detokenize{6_Direct_methods/6.3_Cholesky_decomposition:cholesky-crout-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Cholesky\sphinxhyphen{}Croutâ€™s method}}}} where \(L \mathbf{y} = \mathbf{b}\) is solved for \(\mathbf{y}\) by forward substitution and \(L^\mathrm{T} \mathbf{x} = \mathbf{y}\) is solved for \(\mathbf{x}\) by back substitution.

\item[{Orthogonal vectors\index{Orthogonal vectors@\spxentry{Orthogonal vectors}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Orthogonal-vectors}}}] \leavevmode
\sphinxAtStartPar
A set of vectors \(\lbrace \mathbf{v}_1 ,\mathbf{v}_2 ,\mathbf{v}_3 ,\dots \rbrace\) is said to be {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}]{\sphinxcrossref{\DUrole{std,std-ref}{orthogonal}}}} if \(\mathbf{v}_i \cdot \mathbf{v}_j =0\) for \(i\not= j\).

\item[{Orthonormal vectors\index{Orthonormal vectors@\spxentry{Orthonormal vectors}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Orthonormal-vectors}}}] \leavevmode
\sphinxAtStartPar
A set of orthogonal vectors is {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}]{\sphinxcrossref{\DUrole{std,std-ref}{orthonormal}}}} if the vectors are all unit vectors.

\item[{QR decomposition \index{QR decomposition@\spxentry{QR decomposition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-QR-decomposition}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-section}]{\sphinxcrossref{\DUrole{std,std-ref}{QR decomposition}}}} factorises an \(m \times n\) matrix \(A\) into an orthogonal matrix \(Q\) and an upper triangular matrix \(R\) such that \(A = QR\).

\item[{The Gram\sphinxhyphen{}Schmidt process\index{The Gram\sphinxhyphen{}Schmidt process@\spxentry{The Gram\sphinxhyphen{}Schmidt process}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-Gram-Schmidt-process}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gram-schmidt-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gram\sphinxhyphen{}Schmidt}}}} process applied to a set of \(n\) independent vectors \((\mathbf{a}_1 ,\mathbf{a}_2 ,\dots ,\mathbf{a}_n)\) produces a set of \(n\) orthogonal vectors \((\mathbf{u}_1 ,\mathbf{u}_2 ,\dots ,\mathbf{u}_n)\) by subtracting the projection of \(\mathbf{a}_i\) onto \(\mathbf{u}_j\) for \(j = 1, \ldots, i = 1\).

\item[{QR decomposition using the Gram\sphinxhyphen{}Schmidt process\index{QR decomposition using the Gram\sphinxhyphen{}Schmidt process@\spxentry{QR decomposition using the Gram\sphinxhyphen{}Schmidt process}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-QR-decomposition-using-the-Gram-Schmidt-process}}}] \leavevmode
\sphinxAtStartPar
The QR decomposition of a matrix \(A\) calculated using the {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-gramschmidt-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Gram\sphinxhyphen{}Schmidt process}}}} is

\sphinxAtStartPar
For \(j = 1, \ldots, n\)
\begin{align*}
    r_{ij} &=\mathbf{q}_i \cdot \mathbf{a}_j , \qquad i = 1,\dots ,j-1,\\
    \mathbf{u}_j &= \mathbf{a}_j - \sum_{i=1}^{j-1} r_{ij} \mathbf{q}_i ,\\
    r_{jj} &= \| \mathbf{u}_j \|,\\
    \mathbf{q}_j &=\frac{\mathbf{u}_j }{r_{jj}}.
\end{align*}
\item[{Croutâ€™s method with QR decomposition\index{Crout's method with QR decomposition@\spxentry{Crout's method with QR decomposition}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Crout-s-method-with-QR-decomposition}}}] \leavevmode
\sphinxAtStartPar
The solution of a system of linear equations \(A \mathbf{x} = \mathbf{b}\) where \(A\) is positive definite can be calculated using the {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-crout-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Croutâ€™s method with QR decomposition}}}} by solving \(Rx = Q^\mathrm{T} \mathbf{b}\) using back substitution.

\item[{Householder transformations\index{Householder transformations@\spxentry{Householder transformations}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Householder-transformations}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Householder transformations}}}} reflect a vector about a line that passes through the origin.

\item[{QR decomposition using Householder transformations\index{QR decomposition using Householder transformations@\spxentry{QR decomposition using Householder transformations}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-QR-decomposition-using-Householder-transformations}}}] \leavevmode
\sphinxAtStartPar
The QR decomposition a matrix \(A\) calculated using {\hyperref[\detokenize{6_Direct_methods/6.4_QR_decomposition:qr-householder-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Householder transformations}}}} uses the following steps.

\sphinxAtStartPar
For \(j = 1, \ldots, n\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\mathbf{e} = (1, \underbrace{0, \ldots, 0}_{m-j})^T\);

\item {} 
\sphinxAtStartPar
\(\mathbf{u} = (r_{jj}, r_{j+1,j}, \ldots, r_{m,j})^T\);

\item {} 
\sphinxAtStartPar
\(\mathbf{u} = \mathbf{u} + \operatorname{sign}(r_{jj})\|\mathbf{u}\|\mathbf{e}\);

\item {} 
\sphinxAtStartPar
\(\mathbf{v} = \dfrac{\mathbf{u}}{\| \mathbf{u} \|}\);

\item {} 
\sphinxAtStartPar
\(H = \begin{pmatrix}
      I_{j-1} & 0 \\
      0 & I_{m-j+1} - 2 \mathbf{v}\mathbf{v}^T
  \end{pmatrix}\);

\item {} 
\sphinxAtStartPar
\(R = H R\);

\item {} 
\sphinxAtStartPar
\(Q = Q H\).

\end{itemize}

\end{description}


\bigskip\hrule\bigskip



\section{Indirect methods}
\label{\detokenize{8_Appendices/8.0_Cheat_sheet:indirect-methods}}\begin{description}
\item[{Indirect method\index{Indirect method@\spxentry{Indirect method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Indirect-method}}}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{7_Indirect_methods/7.0_Indirect_methods:indirect-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{Indirect methods}}}} is multiple applications of the method to calculate the solution to a system of linear equations. An estimate is made of the solution \(\mathbf{x}^{(0)}\) and an indirect method is applied to calculate the improved estimate \(\mathbf{x}^{(1)}\). The method is applied repeatedly until two successive estimates agree to some tolerance.

\item[{Jacobi method\index{Jacobi method@\spxentry{Jacobi method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Jacobi-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.1_Jacobi_method:jacobi-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobi method}}}} for calculating the solution to a system of linear equations \(A \mathbf{x} = \mathbf{b}\) is
\begin{align*}
    x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j = 1}^{i-1} a_{ij} x_j^{(k)} - \sum_{j = i+1}^n a_{ij} x_j^{(k)} \right).
\end{align*}
\item[{Gauss\sphinxhyphen{}Seidel method\index{Gauss\sphinxhyphen{}Seidel method@\spxentry{Gauss\sphinxhyphen{}Seidel method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Gauss-Seidel-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.2_Gauss_Seidel_method:gauss-seidel-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{Gauss\sphinxhyphen{}Seidel method}}}} for calculating the solution to a system of linear equations \(A \mathbf{x} = \mathbf{b}\) is
\begin{align*}
    x_i^{(k+1)} = \frac{1}{a_{ii} }\left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} -\sum_{j=i+1}^n a_{ij} x_j^{(k)} \right).
\end{align*}
\item[{The SOR method\index{The SOR method@\spxentry{The SOR method}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-The-SOR-method}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:sor-method-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SOR method}}}} for calculating the solution to a system of linear equations \(A \mathbf{x} = \mathbf{b}\) is
\begin{align*}
    x_i^{(k+1)} =(1 - \omega) x_i^{(k)} + \frac{\omega}{a_{ii} }\left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} -\sum_{j=i+1}^n a_{ij} x_j^{(k)} \right),
\end{align*}
\sphinxAtStartPar
where \(\omega \in [0, 2]\) is a relaxation parameter.

\item[{Iteration matrix\index{Iteration matrix@\spxentry{Iteration matrix}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Iteration-matrix}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.0_Indirect_methods:indirect-methods-chapter}]{\sphinxcrossref{\DUrole{std,std-ref}{iteration matrix}}}} for a method is the matrix \(T\) such that \(\mathbf{x}^{(k+1)} = T\mathbf{x}^{(k)} + \mathbf{c}\) where \(\mathbf{x}^{(k)}\) and \(\mathbf{x}^{(k+1)}\) are current and next estimates of the solution. The iteration matrices for the indirect methods are
\begin{align*}
    \textsf{Jacobi}: && T_J &= - D^{-1}(L + U),\\
    \textsf{Gauss-Seidel}: && T_{GS} &=-(L+D)^{-1} U, \\
    \textsf{SOR}: && T_{SOR} &=(D+\omega L)^{-1} ((1-\omega )D-\omega U),
\end{align*}
\sphinxAtStartPar
where \(A = L + D + U\) and \(L\), \(D\), and \(U\) are lower, diagonal and upper triangular elements of \(A\).

\item[{Spectral radius\index{Spectral radius@\spxentry{Spectral radius}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Spectral-radius}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods:spectral-radius-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{spectral radius}}}} of a matrix is the largest absolute eigenvalue of the matrix.

\item[{Convergence of direct methods\index{Convergence of direct methods@\spxentry{Convergence of direct methods}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Convergence-of-direct-methods}}}] \leavevmode
\sphinxAtStartPar
A direct method will {\hyperref[\detokenize{7_Indirect_methods/7.3_Convergence_of_indirect_methods:convergence-of-indirect-methods-section}]{\sphinxcrossref{\DUrole{std,std-ref}{converge}}}} to a solution if the spectral radius of the iteration matrix is less than 1. The smaller the spectral radius of the convergence matrix, the faster the convergence.

\item[{Optimum value of the relaxation parameter\index{Optimum value of the relaxation parameter@\spxentry{Optimum value of the relaxation parameter}|spxpagem}\phantomsection\label{\detokenize{8_Appendices/8.0_Cheat_sheet:term-Optimum-value-of-the-relaxation-parameter}}}] \leavevmode
\sphinxAtStartPar
The {\hyperref[\detokenize{7_Indirect_methods/7.4_SOR_method:optimum-relaxation-parameter-section}]{\sphinxcrossref{\DUrole{std,std-ref}{optimum value of the relaxation parameter}}}} for the SOR method is the value of \(\omega\) such that the spectral radius of the iteration matrix is minimised. If the coefficient matrix \(A\) has all real eigenvalues then the optimum value of \(\omega\) is
\begin{align*}
    \omega_{opt} = 1+{\left(\frac{\rho (T_J )}{1+\sqrt{1-\rho (T_J )^2 }}\right)}^2,
\end{align*}
\sphinxAtStartPar
where \(\rho(T_J)\) is the spectral radius of the Jacobi method iteration matrix.

\end{description}

\sphinxstepscope


\chapter{Python code}
\label{\detokenize{8_Appendices/8.1_Python:python-code}}\label{\detokenize{8_Appendices/8.1_Python::doc}}
\sphinxAtStartPar
The Python code used in this book is given here for reference.


\section{Importing libraries}
\label{\detokenize{8_Appendices/8.1_Python:importing-libraries}}
\sphinxAtStartPar
The following code is used to import the libraries that we will use here.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://numpy.org/}{NumPy} (pronounced \sphinxstyleemphasis{â€˜num\sphinxhyphen{}pieâ€™}) for performing numerical calculations

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.sympy.org/en/index.html}{SymPy} (pronounced \sphinxstyleemphasis{â€˜sim\sphinxhyphen{}pieâ€™}) for performing symbolic calculations

\item {} 
\sphinxAtStartPar
\sphinxhref{https://matplotlib.org/stable/index.html}{Matplotlib} for plotting solutions

\item {} 
\sphinxAtStartPar
\sphinxhref{https://ipython.org/}{IPython.display} for displaying SymPy output using \(\LaTeX\) fonts (not necessary if not using Jupyter notebooks)

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{Math}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{ODE solvers}
\label{\detokenize{8_Appendices/8.1_Python:ode-solvers}}
\sphinxAtStartPar
The ODE solver functions all solve an initial value problem of the form \(\mathbf{y}' = f(t, \mathbf{y})\), \(t \in [a, b]\) and \(\mathbf{y}_0 = \mathbf{\alpha}\) using a step length of \(h\). The functions return arrays containing the values of \(t_n\) and \(\mathbf{y}\) for the solution domain.


\subsection{The Euler method}
\label{\detokenize{8_Appendices/8.1_Python:the-euler-method}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Defining and solving an IVP}
\label{\detokenize{8_Appendices/8.1_Python:defining-and-solving-an-ivp}}
\sphinxAtStartPar
The following code defines the following ODE and uses the \sphinxcode{\sphinxupquote{euler()}} function with a step length of \(h=0.2\) to compute the solution
\begin{equation*}
\begin{split}y' = ty, \qquad t \in[0, 1], \qquad y(0) = 1.\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{t} \PYG{o}{*} \PYG{n}{y}

\PYG{k}{def} \PYG{n+nf}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{t} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Define IVP parameters}
\PYG{n}{tspan} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} boundaries of the t domain}
\PYG{n}{y0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} solution at the lower boundary}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.2}         \PYG{c+c1}{\PYGZsh{} step length}

\PYG{c+c1}{\PYGZsh{} Calculate the solution to the IVP}
\PYG{n}{t}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{euler}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print table of solution values}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|  t   |   Euler   |   Exact   |  Error   |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{| }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{4.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{9.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ | }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{8.2e}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ |}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|  t   |   Euler   |   Exact   |  Error   |
|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|:\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}:|
| 0.00 |  1.000000 |  1.000000 | 0.00e+00 |
| 0.20 |  1.000000 |  1.020201 | 2.02e\PYGZhy{}02 |
| 0.40 |  1.040000 |  1.083287 | 4.33e\PYGZhy{}02 |
| 0.60 |  1.123200 |  1.197217 | 7.40e\PYGZhy{}02 |
| 0.80 |  1.257984 |  1.377128 | 1.19e\PYGZhy{}01 |
| 1.00 |  1.459261 |  1.648721 | 1.89e\PYGZhy{}01 |
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Ploting the solution}
\label{\detokenize{8_Appendices/8.1_Python:ploting-the-solution}}
\sphinxAtStartPar
The following code uses matplotlib functions to plot the solution.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate exact solution}
\PYG{n}{t\PYGZus{}exact} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{y\PYGZus{}exact} \PYG{o}{=} \PYG{n}{exact}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot solution}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t\PYGZus{}exact}\PYG{p}{,} \PYG{n}{y\PYGZus{}exact}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bo\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Euler}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}y\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8.1_Python_7_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{The RK2 Method}
\label{\detokenize{8_Appendices/8.1_Python:the-rk2-method}}
\sphinxAtStartPar
The RK2 method (second\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method) is defined by the following Butcher tableau.
\begin{align*}
    \begin{array}{c|cc}
        0 & 0 \\
        1 & 1 \\ \hline
        & \frac{1}{2} & \frac{1}{2}
    \end{array}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rk2}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{n}{k2}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{The RK4 method}
\label{\detokenize{8_Appendices/8.1_Python:the-rk4-method}}
\sphinxAtStartPar
The RK4 methods (fourth\sphinxhyphen{}order Runge\sphinxhyphen{}Kutta method) is defined by the following Butcher tableau.
\begin{align*}
    \begin{array}{c|cccc}
        0 & 0 \\
        \frac{1}{2} & \frac{1}{2} \\
        \frac{1}{2} & 0 & \frac{1}{2} \\
        1 & 0 & 0 & 1 \\ \hline
        & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
    \end{array}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rk4}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{k1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{k2} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k1}\PYG{p}{)}
        \PYG{n}{k3} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k2}\PYG{p}{)}
        \PYG{n}{k4} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{n}{k3}\PYG{p}{)}
        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{/} \PYG{l+m+mi}{6} \PYG{o}{*} \PYG{p}{(}\PYG{n}{k1} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{k2} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{k3} \PYG{o}{+} \PYG{n}{k4}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{The third\sphinxhyphen{}order Radau IA implicit Runge\sphinxhyphen{}Kutta method}
\label{\detokenize{8_Appendices/8.1_Python:the-third-order-radau-ia-implicit-runge-kutta-method}}
\sphinxAtStartPar
The third\sphinxhyphen{}order Radau IA implicit Runge\sphinxhyphen{}Kutta method is defined by the following Butcher tableau.
\begin{align*}
    \begin{array}{c|cc}
        0 & \frac{1}{4} & -\frac{1}{4} \\
        \frac{2}{3} & \frac{1}{4} & \frac{5}{12} \\ \hline
        & \frac{1}{4} & \frac{3}{4}
    \end{array}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{radauIA}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{tspan}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{tspan}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)}
    \PYG{n}{neq} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{h}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{nsteps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{neq}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y0}
    \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Y1}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{,} \PYG{n}{Y1o}\PYG{p}{,} \PYG{n}{Y2o} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{neq}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{Y1} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{Y2} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{/}\PYG{l+m+mi}{12} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
            \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{amax}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Y1} \PYG{o}{\PYGZhy{}} \PYG{n}{Y1o}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{amax}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{Y2} \PYG{o}{\PYGZhy{}} \PYG{n}{Y2o}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
                \PYG{k}{break}
            \PYG{n}{Y1o}\PYG{p}{,} \PYG{n}{Y2o} \PYG{o}{=} \PYG{n}{Y1}\PYG{p}{,} \PYG{n}{Y2}

        \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{h} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Y1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{t}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{h}\PYG{p}{,} \PYG{n}{Y2}\PYG{p}{)}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{t}\PYG{p}{,} \PYG{n}{y}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Using SymPy to solve order conditions}
\label{\detokenize{8_Appendices/8.1_Python:using-sympy-to-solve-order-conditions}}
\sphinxAtStartPar
The following code uses SymPy commands to solve the following order conditions where \(c_1 = 1\)
\begin{align*}
    b_1 + b_2 &= 1, \\
    b_2c_2 &= \frac{1}{2}, \\
    a_{21} b_2 &= \frac{1}{2}.
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sympy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{init\PYGZus{}printing}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Declare symbolic variables}
\PYG{n}{a21}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{c2} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a21, b1, b2, c2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{c2} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Define order conditions}
\PYG{n}{eq1} \PYG{o}{=} \PYG{n}{b1} \PYG{o}{+} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n}{eq2} \PYG{o}{=} \PYG{n}{b2} \PYG{o}{*} \PYG{n}{c2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{eq3} \PYG{o}{=} \PYG{n}{a21} \PYG{o}{*} \PYG{n}{b2} \PYG{o}{\PYGZhy{}} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve order conditions}
\PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{eq1}\PYG{p}{,} \PYG{n}{eq2}\PYG{p}{,} \PYG{n}{eq3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8.1_Python_15_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Stability}
\label{\detokenize{8_Appendices/8.1_Python:stability}}

\subsection{Plotting stability regions}
\label{\detokenize{8_Appendices/8.1_Python:plotting-stability-regions}}
\sphinxAtStartPar
The following code plots the region of absolute stability for the Euler method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Generate z values}
\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{meshgrid}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{X} \PYG{o}{+} \PYG{n}{Y} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}

\PYG{c+c1}{\PYGZsh{} Define stability function}
\PYG{n}{R} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{Z}

\PYG{c+c1}{\PYGZsh{} Plot stability region}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}99ccff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{,} \PYG{n}{colors}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{levels}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{equal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Re\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathrm}\PYG{l+s+si}{\PYGZob{}Im\PYGZcb{}}\PYG{l+s+s2}{(z)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{14}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8.1_Python_17_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Stability function for explicit methods}
\label{\detokenize{8_Appendices/8.1_Python:stability-function-for-explicit-methods}}
\sphinxAtStartPar
The following code calculates the stability function for an explicit Runge\sphinxhyphen{}Kutta method defined by the following Butcher tableau.
\begin{align*}\begin{array}{c|cccc}
0 &  &  &  & \\
\frac{1}{2} & \frac{1}{2} &  &  & \\
\frac{3}{4} & 0 & \frac{3}{4} &  & \\
1 & \frac{2}{9} & \frac{1}{3} & \frac{4}{9} & \\ 
\hline
& \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8}
\end{array}\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define ERK method}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
            \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
            \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate stability function}
\PYG{n}{string} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R(z) = 1}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{coefficient} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{T} \PYG{o}{*} \PYG{n}{A} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k} \PYG{o}{*} \PYG{n}{e}
    \PYG{n}{string} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{latex}\PYG{p}{(}\PYG{n}{coefficient}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ z\PYGZca{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{Math}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle R(z) = 1 + 1 z^1 + \frac{1}{2} z^2 + \frac{3}{16} z^3 + \frac{1}{48} z^4\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Stability function for implicit methods}
\label{\detokenize{8_Appendices/8.1_Python:stability-function-for-implicit-methods}}
\sphinxAtStartPar
The following code calculates the stability function for an explicit Runge\sphinxhyphen{}Kutta method defined by the following Butcher tableau.
\begin{align*}
    \begin{array}{c|cc}
    \frac{1}{3} & \frac{5}{12} & -\frac{1}{12} \\
    1 & \frac{3}{4} & \frac{1}{4} \\ \hline
    & \frac{3}{4} & \frac{1}{4}
    \end{array}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define numerator and denominator functions}
\PYG{k}{def} \PYG{n+nf}{P}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{I} \PYG{o}{\PYGZhy{}} \PYG{n}{z} \PYG{o}{*} \PYG{n}{A} \PYG{o}{+} \PYG{n}{z} \PYG{o}{*} \PYG{n}{ebT}\PYG{p}{)}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{Q}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{I} \PYG{o}{\PYGZhy{}} \PYG{n}{z} \PYG{o}{*} \PYG{n}{A}\PYG{p}{)}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Define RK method}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ebT} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{Rational}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate R(z)}
\PYG{n}{z}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z, y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Rz} \PYG{o}{=} \PYG{n}{P}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Q}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Math}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R(z) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{latex}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsimplify}\PYG{p}{(}\PYG{n}{Rz}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle R(z) = \frac{\frac{z^{2}}{16} + \frac{z}{3} + 1}{\frac{z^{2}}{6} - \frac{2 z}{3} + 1}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Checking if an implicit method is A\sphinxhyphen{}stable}
\label{\detokenize{8_Appendices/8.1_Python:checking-if-an-implicit-method-is-a-stable}}
\sphinxAtStartPar
The following code outputs the following conditions for A\sphinxhyphen{}stability
\begin{itemize}
\item {} 
\sphinxAtStartPar
The roots of \(Q(z)\) have positive real parts

\item {} 
\sphinxAtStartPar
\(E(y) = Q(iy)Q(-iy) - P(iy)P(-iy) \geq 0\)

\end{itemize}

\sphinxAtStartPar
where the stability function for the method is \(R(z) = \dfrac{P(z)}{Q(z)}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Check roots of Q have positive real parts}
\PYG{n}{roots} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Math}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{text}\PYG{l+s+se}{\PYGZob{}\PYGZob{}}\PYG{l+s+s2}{roots of }\PYG{l+s+se}{\PYGZcb{}\PYGZcb{}}\PYG{l+s+s2}{Q(z): z = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{latex}\PYG{p}{(}\PYG{n}{roots}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Check E(y) \PYGZgt{}= 0}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)} \PYG{o}{*} \PYG{n}{Q}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)} \PYG{o}{*} \PYG{n}{P}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{y}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Math}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E(y) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{latex}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{simplify}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{.}\PYG{n}{nsimplify}\PYG{p}{(}\PYG{n}{E}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \text{roots of }Q(z): z = \left[ 2 - \sqrt{2} i, \  2 + \sqrt{2} i\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\displaystyle E(y) = \frac{y^{2} \left(55 y^{2} + 288\right)}{2304}\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Direct methods}
\label{\detokenize{8_Appendices/8.1_Python:direct-methods}}

\subsection{LU decomposition}
\label{\detokenize{8_Appendices/8.1_Python:lu-decomposition}}
\sphinxAtStartPar
The following code defines the function \sphinxcode{\sphinxupquote{lu()}} which calculates the LU decomposition of a square matrix \(A\) and returns the lower and upper triangular matrices \(L\) and \(U\) such that \(A = LU\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]} \PYG{o}{*} \PYG{n}{U}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
                
            \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}   
            
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]} \PYG{o}{*} \PYG{n}{U}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
                
            \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{U}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{L}\PYG{p}{,} \PYG{n}{U}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The following code defines the following matrix and uses the function \sphinxcode{\sphinxupquote{lu()}} to calculate the LU decomposition of the matrix.
\begin{align*}
    A = \begin{pmatrix}
        1 & 3 & 0 \\
        2 & -4 & -1 \\
        -3 & 1 & 2
    \end{pmatrix}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define matrix}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate LU decomposition}
\PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{U}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
L = 
[[ 1.  0.  0.]
 [ 2.  1.  0.]
 [\PYGZhy{}3. \PYGZhy{}1.  1.]]

U = 
[[  1.   3.   0.]
 [  0. \PYGZhy{}10.  \PYGZhy{}1.]
 [  0.   0.   1.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Forward and back substitution}
\label{\detokenize{8_Appendices/8.1_Python:forward-and-back-substitution}}
\sphinxAtStartPar
The following code defines the functions \sphinxcode{\sphinxupquote{forward\_substitution()}} and \sphinxcode{\sphinxupquote{back\_substitution()}} which perform forward and back substitution.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{forward\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{L}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
            
        \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{x}


\PYG{k}{def} \PYG{n+nf}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
            
        \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{U}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Croutâ€™s method}
\label{\detokenize{8_Appendices/8.1_Python:crout-s-method}}
\sphinxAtStartPar
The following code calculates the solution to the following system of linear equations using Croutâ€™s method.
\begin{align*}
    \begin{pmatrix}
        1 & 3 & 0 \\
        2 & -4 & -1 \\
        -3 & 1 & 2
    \end{pmatrix}
    \begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix} 
    = \begin{pmatrix} -7 \\ 11 \\ 1 \end{pmatrix}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define linear system}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Calculate LU decomposition}
\PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{L = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{L}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{U = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{U}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{forward\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{back\PYGZus{}substitution}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
L = 
[[ 1.  0.  0.]
 [ 2.  1.  0.]
 [\PYGZhy{}3. \PYGZhy{}1.  1.]]

U = 
[[  1.   3.   0.]
 [  0. \PYGZhy{}10.  \PYGZhy{}1.]
 [  0.   0.   1.]]

x1 = 2.0
x2 = \PYGZhy{}3.0
x3 = 5.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Partial pivoting}
\label{\detokenize{8_Appendices/8.1_Python:partial-pivoting}}
\sphinxAtStartPar
The following code defines the function \sphinxcode{\sphinxupquote{partial\_pivot()}} that performs partial pivoting on a matrix and outputs the matrix and the permutation matrix.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{partial\PYGZus{}pivot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{P} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{maxpivot}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{j}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{maxpivot}\PYG{p}{:}
                \PYG{n}{maxpivot}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i}
                
        \PYG{n}{A}\PYG{p}{[}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{]}
        \PYG{n}{P}\PYG{p}{[}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{P}\PYG{p}{[}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{]}
        
    \PYG{k}{return} \PYG{n}{A}\PYG{p}{,} \PYG{n}{P}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Cholesky decomposition}
\label{\detokenize{8_Appendices/8.1_Python:cholesky-decomposition}}
\sphinxAtStartPar
The following code defines the function \sphinxcode{\sphinxupquote{cholesky()}} which performs Cholesky decomposition on a matrix \(A\) and outputs the lower triangular matrix \(L\) such that \(A = LL^\mathrm{T}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cholesky}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{det}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{n}{n}\PYG{p}{,}\PYG{p}{:}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error! A is not a positive definite matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{return}
        
    \PYG{n}{L} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{)}   
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]} \PYG{o}{*} \PYG{n}{L}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{]}
                
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{j}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{L}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{L}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}   
    
    \PYG{k}{return} \PYG{n}{L}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{QR decomposition using the Gram\sphinxhyphen{}Schmidt process}
\label{\detokenize{8_Appendices/8.1_Python:qr-decomposition-using-the-gram-schmidt-process}}
\sphinxAtStartPar
The following code defines the function \sphinxcode{\sphinxupquote{qr\_gramschidt()}} which performs QR decomposition using the Gram\sphinxhyphen{}Schmidt process on a matrix \(A\) and outputs the orthogonal matrix \(Q\) and upper triangular matrix \(R\) such that \(A = QR\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{qr\PYGZus{}gramschmidt}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nrows}\PYG{p}{,} \PYG{n}{ncols} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ncols}\PYG{p}{,} \PYG{n}{ncols}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ncols}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{R}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{n}{R}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
        \PYG{n}{R}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{/} \PYG{n}{R}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
    
    \PYG{k}{return} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{QR decomposition using the Householder transformations}
\label{\detokenize{8_Appendices/8.1_Python:qr-decomposition-using-the-householder-transformations}}
\sphinxAtStartPar
The following code defines the function \sphinxcode{\sphinxupquote{qr\_householder()}} which performs QR decomposition using the Gram\sphinxhyphen{}Schmidt process on a matrix \(A\) and outputs the orthogonal matrix \(Q\) and upper triangular matrix \(R\) such that \(A = QR\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{qr\PYGZus{}householder}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{e} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{R}\PYG{p}{[}\PYG{n}{j}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{u} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sign}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{e}
        \PYG{n}{v} \PYG{o}{=} \PYG{n}{u} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
        \PYG{n}{H} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
        \PYG{n}{H}\PYG{p}{[}\PYG{n}{j}\PYG{p}{:}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{v}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}
        \PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{R}\PYG{p}{)}
        \PYG{n}{Q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{R}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Indirect methods}
\label{\detokenize{8_Appendices/8.1_Python:indirect-methods}}
\sphinxAtStartPar
The following methods calculate the solutions to the system of linear equations \(A \mathbf{x} = \mathbf{b}\) ceasing iterations when the largest value of the residual is less than \sphinxcode{\sphinxupquote{tol}}.


\subsection{The Jacobi method}
\label{\detokenize{8_Appendices/8.1_Python:the-jacobi-method}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{jacobi}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{xo} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{xo}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{The Gauss\sphinxhyphen{}Seidel method}
\label{\detokenize{8_Appendices/8.1_Python:the-gauss-seidel-method}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gauss\PYGZus{}seidel}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{The SOR method}
\label{\detokenize{8_Appendices/8.1_Python:the-sor-method}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sor}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{omega}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{maxiter} \PYG{o}{=} \PYG{l+m+mi}{100}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{maxiter}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{mysum} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{mysum} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
        
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{omega}\PYG{p}{)} \PYG{o}{*} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{omega} \PYG{o}{/} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{mysum}
            
        \PYG{n}{r} \PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}   
        \PYG{k}{if} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{tol}\PYG{p}{:}
            \PYG{k}{break}
    
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Calculating an iteration matrix}
\label{\detokenize{8_Appendices/8.1_Python:calculating-an-iteration-matrix}}
\sphinxAtStartPar
The following code calculates the iteration matrix for the Jacobi method give the following coefficient matrix
\begin{align*}
    A = \begin{pmatrix} 
        4 & 3 & 0 \\
        3 & 4 & -1 \\
        0 & -1 & 4
    \end{pmatrix}
\end{align*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define coefficient matrix}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Extract L, D and U matrices}
\PYG{n}{L} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tril}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{triu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{D} \PYG{o}{=} \PYG{n}{A} \PYG{o}{\PYGZhy{}} \PYG{n}{L} \PYG{o}{\PYGZhy{}} \PYG{n}{U}

\PYG{c+c1}{\PYGZsh{} Calculate iteration matrix}
\PYG{n}{TJ} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{D}\PYG{p}{,} \PYG{n}{L} \PYG{o}{+} \PYG{n}{U}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TJ = }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{TJ}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
TJ = 
[[  0 \PYGZhy{}12   0]
 [\PYGZhy{}12   0   4]
 [  0   4   0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Calculating the spectral radius of a matrix}
\label{\detokenize{8_Appendices/8.1_Python:calculating-the-spectral-radius-of-a-matrix}}
\sphinxAtStartPar
The following code calculates the spectral radius of the matrix \sphinxcode{\sphinxupquote{TJ}} from above.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rho\PYGZus{}TJ} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eigvals}\PYG{p}{(}\PYG{n}{TJ}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rho(TJ) = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{rho\PYGZus{}TJ}\PYG{l+s+si}{:}\PYG{l+s+s2}{0.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
rho(TJ) = 12.6491
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxthebibliography}{Lam91}
\bibitem[Lam91]{4_Stability/4.0_Stability:id4}
\sphinxAtStartPar
J.D. Lambert. \sphinxstyleemphasis{Numerical Methods for Ordinary Differential Systems: The Initial Value Problem}. Wiley, 1991.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}